_ZN11ArgsManagerD2Ev:
  110|      2|ArgsManager::~ArgsManager() = default;

_Z17internal_bswap_32j:
   54|  6.16M|{
   55|  6.16M|#ifdef bitcoin_builtin_bswap32
   56|  6.16M|    return bitcoin_builtin_bswap32(x);
  ------------------
  |  |   24|  6.16M|#      define bitcoin_builtin_bswap32(x) __builtin_bswap32(x)
  ------------------
   57|       |#else
   58|       |    return (((x & 0xff000000U) >> 24) | ((x & 0x00ff0000U) >>  8) |
   59|       |            ((x & 0x0000ff00U) <<  8) | ((x & 0x000000ffU) << 24));
   60|       |#endif
   61|  6.16M|}
_Z17internal_bswap_64m:
   64|  2.71M|{
   65|  2.71M|#ifdef bitcoin_builtin_bswap64
   66|  2.71M|    return bitcoin_builtin_bswap64(x);
  ------------------
  |  |   27|  2.71M|#      define bitcoin_builtin_bswap64(x) __builtin_bswap64(x)
  ------------------
   67|       |#else
   68|       |     return (((x & 0xff00000000000000ull) >> 56)
   69|       |          | ((x & 0x00ff000000000000ull) >> 40)
   70|       |          | ((x & 0x0000ff0000000000ull) >> 24)
   71|       |          | ((x & 0x000000ff00000000ull) >> 8)
   72|       |          | ((x & 0x00000000ff000000ull) << 8)
   73|       |          | ((x & 0x0000000000ff0000ull) << 24)
   74|       |          | ((x & 0x000000000000ff00ull) << 40)
   75|       |          | ((x & 0x00000000000000ffull) << 56));
   76|       |#endif
   77|  2.71M|}

_Z16htole16_internalt:
   19|  11.0k|{
   20|       |    if constexpr (std::endian::native == std::endian::big) return internal_bswap_16(host_16bits);
   21|  11.0k|        else return host_16bits;
   22|  11.0k|}
_Z16le16toh_internalt:
   29|  2.56k|{
   30|       |    if constexpr (std::endian::native == std::endian::big) return internal_bswap_16(little_endian_16bits);
   31|  2.56k|        else return little_endian_16bits;
   32|  2.56k|}
_Z16htole64_internalm:
   59|   167k|{
   60|       |    if constexpr (std::endian::native == std::endian::big) return internal_bswap_64(host_64bits);
   61|   167k|        else return host_64bits;
   62|   167k|}
_Z16be32toh_internalj:
   44|  4.73M|{
   45|  4.73M|    if constexpr (std::endian::native == std::endian::little) return internal_bswap_32(big_endian_32bits);
   46|       |        else return big_endian_32bits;
   47|  4.73M|}
_Z16htobe32_internalj:
   34|  1.43M|{
   35|  1.43M|    if constexpr (std::endian::native == std::endian::little) return internal_bswap_32(host_32bits);
   36|       |        else return host_32bits;
   37|  1.43M|}
_Z16be64toh_internalm:
   64|  1.93M|{
   65|  1.93M|    if constexpr (std::endian::native == std::endian::little) return internal_bswap_64(big_endian_64bits);
   66|       |        else return big_endian_64bits;
   67|  1.93M|}
_Z16htobe64_internalm:
   54|   780k|{
   55|   780k|    if constexpr (std::endian::native == std::endian::little) return internal_bswap_64(host_64bits);
   56|       |        else return host_64bits;
   57|   780k|}
_Z16htole32_internalj:
   39|   320M|{
   40|       |    if constexpr (std::endian::native == std::endian::big) return internal_bswap_32(host_32bits);
   41|   320M|        else return host_32bits;
   42|   320M|}
_Z16le32toh_internalj:
   49|   722M|{
   50|       |    if constexpr (std::endian::native == std::endian::big) return internal_bswap_32(little_endian_32bits);
   51|   722M|        else return little_endian_32bits;
   52|   722M|}

_ZN15ChaCha20Aligned6SetKeyENSt3__14spanIKSt4byteLm18446744073709551615EEE:
   26|  87.1k|{
   27|  87.1k|    assert(key.size() == KEYLEN);
  ------------------
  |  Branch (27:5): [True: 87.1k, False: 0]
  ------------------
   28|  87.1k|    input[0] = ReadLE32(key.data() + 0);
   29|  87.1k|    input[1] = ReadLE32(key.data() + 4);
   30|  87.1k|    input[2] = ReadLE32(key.data() + 8);
   31|  87.1k|    input[3] = ReadLE32(key.data() + 12);
   32|  87.1k|    input[4] = ReadLE32(key.data() + 16);
   33|  87.1k|    input[5] = ReadLE32(key.data() + 20);
   34|  87.1k|    input[6] = ReadLE32(key.data() + 24);
   35|  87.1k|    input[7] = ReadLE32(key.data() + 28);
   36|  87.1k|    input[8] = 0;
   37|  87.1k|    input[9] = 0;
   38|  87.1k|    input[10] = 0;
   39|  87.1k|    input[11] = 0;
   40|  87.1k|}
_ZN15ChaCha20AlignedD2Ev:
   43|  87.1k|{
   44|  87.1k|    memory_cleanse(input, sizeof(input));
   45|  87.1k|}
_ZN15ChaCha20AlignedC2ENSt3__14spanIKSt4byteLm18446744073709551615EEE:
   48|  87.1k|{
   49|  87.1k|    SetKey(key);
   50|  87.1k|}
_ZN15ChaCha20Aligned4SeekENSt3__14pairIjmEEj:
   53|   126k|{
   54|   126k|    input[8] = block_counter;
   55|   126k|    input[9] = nonce.first;
   56|   126k|    input[10] = nonce.second;
   57|   126k|    input[11] = nonce.second >> 32;
   58|   126k|}
_ZN8ChaCha209KeystreamENSt3__14spanISt4byteLm18446744073709551615EEE:
  283|  97.2k|{
  284|  97.2k|    if (out.empty()) return;
  ------------------
  |  Branch (284:9): [True: 0, False: 97.2k]
  ------------------
  285|  97.2k|    if (m_bufleft) {
  ------------------
  |  Branch (285:9): [True: 6.72k, False: 90.4k]
  ------------------
  286|  6.72k|        unsigned reuse = std::min<size_t>(m_bufleft, out.size());
  287|  6.72k|        std::copy(m_buffer.end() - m_bufleft, m_buffer.end() - m_bufleft + reuse, out.begin());
  288|  6.72k|        m_bufleft -= reuse;
  289|  6.72k|        out = out.subspan(reuse);
  290|  6.72k|    }
  291|  97.2k|    if (out.size() >= m_aligned.BLOCKLEN) {
  ------------------
  |  Branch (291:9): [True: 83.7k, False: 13.4k]
  ------------------
  292|  83.7k|        size_t blocks = out.size() / m_aligned.BLOCKLEN;
  293|  83.7k|        m_aligned.Keystream(out.first(blocks * m_aligned.BLOCKLEN));
  294|  83.7k|        out = out.subspan(blocks * m_aligned.BLOCKLEN);
  295|  83.7k|    }
  296|  97.2k|    if (!out.empty()) {
  ------------------
  |  Branch (296:9): [True: 6.72k, False: 90.4k]
  ------------------
  297|  6.72k|        m_aligned.Keystream(m_buffer);
  298|  6.72k|        std::copy(m_buffer.begin(), m_buffer.begin() + out.size(), out.begin());
  299|  6.72k|        m_bufleft = m_aligned.BLOCKLEN - out.size();
  300|  6.72k|    }
  301|  97.2k|}
_ZN8ChaCha205CryptENSt3__14spanIKSt4byteLm18446744073709551615EEENS1_IS2_Lm18446744073709551615EEE:
  304|   164k|{
  305|   164k|    assert(input.size() == output.size());
  ------------------
  |  Branch (305:5): [True: 164k, False: 0]
  ------------------
  306|       |
  307|   164k|    if (!input.size()) return;
  ------------------
  |  Branch (307:9): [True: 82.4k, False: 82.4k]
  ------------------
  308|  82.4k|    if (m_bufleft) {
  ------------------
  |  Branch (308:9): [True: 0, False: 82.4k]
  ------------------
  309|      0|        unsigned reuse = std::min<size_t>(m_bufleft, input.size());
  310|      0|        for (unsigned i = 0; i < reuse; i++) {
  ------------------
  |  Branch (310:30): [True: 0, False: 0]
  ------------------
  311|      0|            output[i] = input[i] ^ m_buffer[m_aligned.BLOCKLEN - m_bufleft + i];
  312|      0|        }
  313|      0|        m_bufleft -= reuse;
  314|      0|        output = output.subspan(reuse);
  315|      0|        input = input.subspan(reuse);
  316|      0|    }
  317|  82.4k|    if (input.size() >= m_aligned.BLOCKLEN) {
  ------------------
  |  Branch (317:9): [True: 72.8k, False: 9.55k]
  ------------------
  318|  72.8k|        size_t blocks = input.size() / m_aligned.BLOCKLEN;
  319|  72.8k|        m_aligned.Crypt(input.first(blocks * m_aligned.BLOCKLEN), output.first(blocks * m_aligned.BLOCKLEN));
  320|  72.8k|        output = output.subspan(blocks * m_aligned.BLOCKLEN);
  321|  72.8k|        input = input.subspan(blocks * m_aligned.BLOCKLEN);
  322|  72.8k|    }
  323|  82.4k|    if (!input.empty()) {
  ------------------
  |  Branch (323:9): [True: 74.6k, False: 7.81k]
  ------------------
  324|  74.6k|        m_aligned.Keystream(m_buffer);
  325|  2.28M|        for (unsigned i = 0; i < input.size(); i++) {
  ------------------
  |  Branch (325:30): [True: 2.21M, False: 74.6k]
  ------------------
  326|  2.21M|            output[i] = input[i] ^ m_buffer[i];
  327|  2.21M|        }
  328|  74.6k|        m_bufleft = m_aligned.BLOCKLEN - input.size();
  329|  74.6k|    }
  330|  82.4k|}
_ZN8ChaCha20D2Ev:
  333|  87.1k|{
  334|  87.1k|    memory_cleanse(m_buffer.data(), m_buffer.size());
  335|  87.1k|}
_ZN15ChaCha20Aligned9KeystreamENSt3__14spanISt4byteLm18446744073709551615EEE:
   61|   165k|{
   62|   165k|    std::byte* c = output.data();
   63|   165k|    size_t blocks = output.size() / BLOCKLEN;
   64|   165k|    assert(blocks * BLOCKLEN == output.size());
  ------------------
  |  Branch (64:5): [True: 165k, False: 0]
  ------------------
   65|       |
   66|   165k|    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;
   67|   165k|    uint32_t j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;
   68|       |
   69|   165k|    if (!blocks) return;
  ------------------
  |  Branch (69:9): [True: 0, False: 165k]
  ------------------
   70|       |
   71|   165k|    j4 = input[0];
   72|   165k|    j5 = input[1];
   73|   165k|    j6 = input[2];
   74|   165k|    j7 = input[3];
   75|   165k|    j8 = input[4];
   76|   165k|    j9 = input[5];
   77|   165k|    j10 = input[6];
   78|   165k|    j11 = input[7];
   79|   165k|    j12 = input[8];
   80|   165k|    j13 = input[9];
   81|   165k|    j14 = input[10];
   82|   165k|    j15 = input[11];
   83|       |
   84|   165k|    for (;;) {
   85|   165k|        x0 = 0x61707865;
   86|   165k|        x1 = 0x3320646e;
   87|   165k|        x2 = 0x79622d32;
   88|   165k|        x3 = 0x6b206574;
   89|   165k|        x4 = j4;
   90|   165k|        x5 = j5;
   91|   165k|        x6 = j6;
   92|   165k|        x7 = j7;
   93|   165k|        x8 = j8;
   94|   165k|        x9 = j9;
   95|   165k|        x10 = j10;
   96|   165k|        x11 = j11;
   97|   165k|        x12 = j12;
   98|   165k|        x13 = j13;
   99|   165k|        x14 = j14;
  100|   165k|        x15 = j15;
  101|       |
  102|       |        // The 20 inner ChaCha20 rounds are unrolled here for performance.
  103|   165k|        REPEAT10(
  ------------------
  |  |   23|   165k|#define REPEAT10(a) do { {a}; {a}; {a}; {a}; {a}; {a}; {a}; {a}; {a}; {a}; } while(0)
  |  |  ------------------
  |  |  |  Branch (23:84): [Folded, False: 165k]
  |  |  ------------------
  ------------------
  104|   165k|            QUARTERROUND( x0, x4, x8,x12);
  105|   165k|            QUARTERROUND( x1, x5, x9,x13);
  106|   165k|            QUARTERROUND( x2, x6,x10,x14);
  107|   165k|            QUARTERROUND( x3, x7,x11,x15);
  108|   165k|            QUARTERROUND( x0, x5,x10,x15);
  109|   165k|            QUARTERROUND( x1, x6,x11,x12);
  110|   165k|            QUARTERROUND( x2, x7, x8,x13);
  111|   165k|            QUARTERROUND( x3, x4, x9,x14);
  112|   165k|        );
  113|       |
  114|   165k|        x0 += 0x61707865;
  115|   165k|        x1 += 0x3320646e;
  116|   165k|        x2 += 0x79622d32;
  117|   165k|        x3 += 0x6b206574;
  118|   165k|        x4 += j4;
  119|   165k|        x5 += j5;
  120|   165k|        x6 += j6;
  121|   165k|        x7 += j7;
  122|   165k|        x8 += j8;
  123|   165k|        x9 += j9;
  124|   165k|        x10 += j10;
  125|   165k|        x11 += j11;
  126|   165k|        x12 += j12;
  127|   165k|        x13 += j13;
  128|   165k|        x14 += j14;
  129|   165k|        x15 += j15;
  130|       |
  131|   165k|        ++j12;
  132|   165k|        if (!j12) ++j13;
  ------------------
  |  Branch (132:13): [True: 0, False: 165k]
  ------------------
  133|       |
  134|   165k|        WriteLE32(c + 0, x0);
  135|   165k|        WriteLE32(c + 4, x1);
  136|   165k|        WriteLE32(c + 8, x2);
  137|   165k|        WriteLE32(c + 12, x3);
  138|   165k|        WriteLE32(c + 16, x4);
  139|   165k|        WriteLE32(c + 20, x5);
  140|   165k|        WriteLE32(c + 24, x6);
  141|   165k|        WriteLE32(c + 28, x7);
  142|   165k|        WriteLE32(c + 32, x8);
  143|   165k|        WriteLE32(c + 36, x9);
  144|   165k|        WriteLE32(c + 40, x10);
  145|   165k|        WriteLE32(c + 44, x11);
  146|   165k|        WriteLE32(c + 48, x12);
  147|   165k|        WriteLE32(c + 52, x13);
  148|   165k|        WriteLE32(c + 56, x14);
  149|   165k|        WriteLE32(c + 60, x15);
  150|       |
  151|   165k|        if (blocks == 1) {
  ------------------
  |  Branch (151:13): [True: 165k, False: 0]
  ------------------
  152|   165k|            input[8] = j12;
  153|   165k|            input[9] = j13;
  154|   165k|            return;
  155|   165k|        }
  156|      0|        blocks -= 1;
  157|      0|        c += BLOCKLEN;
  158|      0|    }
  159|   165k|}
_ZN15ChaCha20Aligned5CryptENSt3__14spanIKSt4byteLm18446744073709551615EEENS1_IS2_Lm18446744073709551615EEE:
  162|  72.8k|{
  163|  72.8k|    assert(in_bytes.size() == out_bytes.size());
  ------------------
  |  Branch (163:5): [True: 72.8k, False: 0]
  ------------------
  164|  72.8k|    const std::byte* m = in_bytes.data();
  165|  72.8k|    std::byte* c = out_bytes.data();
  166|  72.8k|    size_t blocks = out_bytes.size() / BLOCKLEN;
  167|  72.8k|    assert(blocks * BLOCKLEN == out_bytes.size());
  ------------------
  |  Branch (167:5): [True: 72.8k, False: 0]
  ------------------
  168|       |
  169|  72.8k|    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;
  170|  72.8k|    uint32_t j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;
  171|       |
  172|  72.8k|    if (!blocks) return;
  ------------------
  |  Branch (172:9): [True: 0, False: 72.8k]
  ------------------
  173|       |
  174|  72.8k|    j4 = input[0];
  175|  72.8k|    j5 = input[1];
  176|  72.8k|    j6 = input[2];
  177|  72.8k|    j7 = input[3];
  178|  72.8k|    j8 = input[4];
  179|  72.8k|    j9 = input[5];
  180|  72.8k|    j10 = input[6];
  181|  72.8k|    j11 = input[7];
  182|  72.8k|    j12 = input[8];
  183|  72.8k|    j13 = input[9];
  184|  72.8k|    j14 = input[10];
  185|  72.8k|    j15 = input[11];
  186|       |
  187|  19.8M|    for (;;) {
  188|  19.8M|        x0 = 0x61707865;
  189|  19.8M|        x1 = 0x3320646e;
  190|  19.8M|        x2 = 0x79622d32;
  191|  19.8M|        x3 = 0x6b206574;
  192|  19.8M|        x4 = j4;
  193|  19.8M|        x5 = j5;
  194|  19.8M|        x6 = j6;
  195|  19.8M|        x7 = j7;
  196|  19.8M|        x8 = j8;
  197|  19.8M|        x9 = j9;
  198|  19.8M|        x10 = j10;
  199|  19.8M|        x11 = j11;
  200|  19.8M|        x12 = j12;
  201|  19.8M|        x13 = j13;
  202|  19.8M|        x14 = j14;
  203|  19.8M|        x15 = j15;
  204|       |
  205|       |        // The 20 inner ChaCha20 rounds are unrolled here for performance.
  206|  19.8M|        REPEAT10(
  ------------------
  |  |   23|  19.8M|#define REPEAT10(a) do { {a}; {a}; {a}; {a}; {a}; {a}; {a}; {a}; {a}; {a}; } while(0)
  |  |  ------------------
  |  |  |  Branch (23:84): [Folded, False: 19.8M]
  |  |  ------------------
  ------------------
  207|  19.8M|            QUARTERROUND( x0, x4, x8,x12);
  208|  19.8M|            QUARTERROUND( x1, x5, x9,x13);
  209|  19.8M|            QUARTERROUND( x2, x6,x10,x14);
  210|  19.8M|            QUARTERROUND( x3, x7,x11,x15);
  211|  19.8M|            QUARTERROUND( x0, x5,x10,x15);
  212|  19.8M|            QUARTERROUND( x1, x6,x11,x12);
  213|  19.8M|            QUARTERROUND( x2, x7, x8,x13);
  214|  19.8M|            QUARTERROUND( x3, x4, x9,x14);
  215|  19.8M|        );
  216|       |
  217|  19.8M|        x0 += 0x61707865;
  218|  19.8M|        x1 += 0x3320646e;
  219|  19.8M|        x2 += 0x79622d32;
  220|  19.8M|        x3 += 0x6b206574;
  221|  19.8M|        x4 += j4;
  222|  19.8M|        x5 += j5;
  223|  19.8M|        x6 += j6;
  224|  19.8M|        x7 += j7;
  225|  19.8M|        x8 += j8;
  226|  19.8M|        x9 += j9;
  227|  19.8M|        x10 += j10;
  228|  19.8M|        x11 += j11;
  229|  19.8M|        x12 += j12;
  230|  19.8M|        x13 += j13;
  231|  19.8M|        x14 += j14;
  232|  19.8M|        x15 += j15;
  233|       |
  234|  19.8M|        x0 ^= ReadLE32(m + 0);
  235|  19.8M|        x1 ^= ReadLE32(m + 4);
  236|  19.8M|        x2 ^= ReadLE32(m + 8);
  237|  19.8M|        x3 ^= ReadLE32(m + 12);
  238|  19.8M|        x4 ^= ReadLE32(m + 16);
  239|  19.8M|        x5 ^= ReadLE32(m + 20);
  240|  19.8M|        x6 ^= ReadLE32(m + 24);
  241|  19.8M|        x7 ^= ReadLE32(m + 28);
  242|  19.8M|        x8 ^= ReadLE32(m + 32);
  243|  19.8M|        x9 ^= ReadLE32(m + 36);
  244|  19.8M|        x10 ^= ReadLE32(m + 40);
  245|  19.8M|        x11 ^= ReadLE32(m + 44);
  246|  19.8M|        x12 ^= ReadLE32(m + 48);
  247|  19.8M|        x13 ^= ReadLE32(m + 52);
  248|  19.8M|        x14 ^= ReadLE32(m + 56);
  249|  19.8M|        x15 ^= ReadLE32(m + 60);
  250|       |
  251|  19.8M|        ++j12;
  252|  19.8M|        if (!j12) ++j13;
  ------------------
  |  Branch (252:13): [True: 0, False: 19.8M]
  ------------------
  253|       |
  254|  19.8M|        WriteLE32(c + 0, x0);
  255|  19.8M|        WriteLE32(c + 4, x1);
  256|  19.8M|        WriteLE32(c + 8, x2);
  257|  19.8M|        WriteLE32(c + 12, x3);
  258|  19.8M|        WriteLE32(c + 16, x4);
  259|  19.8M|        WriteLE32(c + 20, x5);
  260|  19.8M|        WriteLE32(c + 24, x6);
  261|  19.8M|        WriteLE32(c + 28, x7);
  262|  19.8M|        WriteLE32(c + 32, x8);
  263|  19.8M|        WriteLE32(c + 36, x9);
  264|  19.8M|        WriteLE32(c + 40, x10);
  265|  19.8M|        WriteLE32(c + 44, x11);
  266|  19.8M|        WriteLE32(c + 48, x12);
  267|  19.8M|        WriteLE32(c + 52, x13);
  268|  19.8M|        WriteLE32(c + 56, x14);
  269|  19.8M|        WriteLE32(c + 60, x15);
  270|       |
  271|  19.8M|        if (blocks == 1) {
  ------------------
  |  Branch (271:13): [True: 72.8k, False: 19.7M]
  ------------------
  272|  72.8k|            input[8] = j12;
  273|  72.8k|            input[9] = j13;
  274|  72.8k|            return;
  275|  72.8k|        }
  276|  19.7M|        blocks -= 1;
  277|  19.7M|        c += BLOCKLEN;
  278|  19.7M|        m += BLOCKLEN;
  279|  19.7M|    }
  280|  72.8k|}

_ZN8ChaCha20C2ENSt3__14spanIKSt4byteLm18446744073709551615EEE:
   92|  87.1k|    ChaCha20(std::span<const std::byte> key) noexcept : m_aligned(key) {}
_ZN8ChaCha204SeekENSt3__14pairIjmEEj:
  105|   126k|    {
  106|   126k|        m_aligned.Seek(nonce, block_counter);
  107|   126k|        m_bufleft = 0;
  108|   126k|    }

_ZN20AEADChaCha20Poly1305C2ENSt3__14spanIKSt4byteLm18446744073709551615EEE:
   16|  83.7k|AEADChaCha20Poly1305::AEADChaCha20Poly1305(std::span<const std::byte> key) noexcept : m_chacha20(key)
   17|  83.7k|{
   18|       |    assert(key.size() == KEYLEN);
  ------------------
  |  Branch (18:5): [True: 83.7k, False: 0]
  ------------------
   19|  83.7k|}
_ZN20AEADChaCha20Poly13057EncryptENSt3__14spanIKSt4byteLm18446744073709551615EEES4_S4_NS0_4pairIjmEENS1_IS2_Lm18446744073709551615EEE:
   70|  42.2k|{
   71|  42.2k|    assert(cipher.size() == plain1.size() + plain2.size() + EXPANSION);
  ------------------
  |  Branch (71:5): [True: 42.2k, False: 0]
  ------------------
   72|       |
   73|       |    // Encrypt using ChaCha20 (starting at block 1).
   74|  42.2k|    m_chacha20.Seek(nonce, 1);
   75|  42.2k|    m_chacha20.Crypt(plain1, cipher.first(plain1.size()));
   76|  42.2k|    m_chacha20.Crypt(plain2, cipher.subspan(plain1.size()).first(plain2.size()));
   77|       |
   78|       |    // Seek to block 0, and compute tag using key drawn from there.
   79|  42.2k|    m_chacha20.Seek(nonce, 0);
   80|  42.2k|    ComputeTag(m_chacha20, aad, cipher.first(cipher.size() - EXPANSION), cipher.last(EXPANSION));
   81|  42.2k|}
_ZN20AEADChaCha20Poly13057DecryptENSt3__14spanIKSt4byteLm18446744073709551615EEES4_NS0_4pairIjmEENS1_IS2_Lm18446744073709551615EEES7_:
   84|  41.4k|{
   85|  41.4k|    assert(cipher.size() == plain1.size() + plain2.size() + EXPANSION);
  ------------------
  |  Branch (85:5): [True: 41.4k, False: 0]
  ------------------
   86|       |
   87|       |    // Verify tag (using key drawn from block 0).
   88|  41.4k|    m_chacha20.Seek(nonce, 0);
   89|  41.4k|    std::byte expected_tag[EXPANSION];
   90|  41.4k|    ComputeTag(m_chacha20, aad, cipher.first(cipher.size() - EXPANSION), expected_tag);
   91|  41.4k|    if (timingsafe_bcmp_internal(UCharCast(expected_tag), UCharCast(cipher.last(EXPANSION).data()), EXPANSION)) return false;
  ------------------
  |  Branch (91:9): [True: 1.32k, False: 40.1k]
  ------------------
   92|       |
   93|       |    // Decrypt (starting at block 1).
   94|  40.1k|    m_chacha20.Crypt(cipher.first(plain1.size()), plain1);
   95|  40.1k|    m_chacha20.Crypt(cipher.subspan(plain1.size()).first(plain2.size()), plain2);
   96|  40.1k|    return true;
   97|  41.4k|}
chacha20poly1305.cpp:_ZN12_GLOBAL__N_110ComputeTagER8ChaCha20NSt3__14spanIKSt4byteLm18446744073709551615EEES6_NS3_IS4_Lm18446744073709551615EEE:
   40|  83.7k|{
   41|  83.7k|    static const std::byte PADDING[16] = {{}};
   42|       |
   43|       |    // Get block of keystream (use a full 64 byte buffer to avoid the need for chacha20's own buffering).
   44|  83.7k|    std::byte first_block[ChaCha20Aligned::BLOCKLEN];
   45|  83.7k|    chacha20.Keystream(first_block);
   46|       |
   47|       |    // Use the first 32 bytes of the first keystream block as poly1305 key.
   48|  83.7k|    Poly1305 poly1305{std::span{first_block}.first(Poly1305::KEYLEN)};
   49|       |
   50|       |    // Compute tag:
   51|       |    // - Process the padded AAD with Poly1305.
   52|  83.7k|    const unsigned aad_padding_length = (16 - (aad.size() % 16)) % 16;
   53|  83.7k|    poly1305.Update(aad).Update(std::span{PADDING}.first(aad_padding_length));
   54|       |    // - Process the padded ciphertext with Poly1305.
   55|  83.7k|    const unsigned cipher_padding_length = (16 - (cipher.size() % 16)) % 16;
   56|  83.7k|    poly1305.Update(cipher).Update(std::span{PADDING}.first(cipher_padding_length));
   57|       |    // - Process the AAD and plaintext length with Poly1305.
   58|  83.7k|    std::byte length_desc[Poly1305::TAGLEN];
   59|  83.7k|    WriteLE64(length_desc, aad.size());
   60|  83.7k|    WriteLE64(length_desc + 8, cipher.size());
   61|  83.7k|    poly1305.Update(length_desc);
   62|       |
   63|       |    // Output tag.
   64|  83.7k|    poly1305.Finalize(tag);
   65|  83.7k|}
chacha20poly1305.cpp:_ZN12_GLOBAL__N_124timingsafe_bcmp_internalEPKhS1_m:
   30|  41.4k|{
   31|  41.4k|    const unsigned char *p1 = b1, *p2 = b2;
   32|  41.4k|    int ret = 0;
   33|   705k|    for (; n > 0; n--)
  ------------------
  |  Branch (33:12): [True: 663k, False: 41.4k]
  ------------------
   34|   663k|        ret |= *p1++ ^ *p2++;
   35|  41.4k|    return (ret != 0);
   36|  41.4k|}

_ZN20AEADChaCha20Poly13057DecryptENSt3__14spanIKSt4byteLm18446744073709551615EEES4_NS0_4pairIjmEENS1_IS2_Lm18446744073709551615EEE:
   57|  41.4k|    {
   58|  41.4k|        return Decrypt(cipher, aad, nonce, plain, {});
   59|  41.4k|    }
_ZN20AEADChaCha20Poly13057EncryptENSt3__14spanIKSt4byteLm18446744073709551615EEES4_NS0_4pairIjmEENS1_IS2_Lm18446744073709551615EEE:
   42|  42.2k|    {
   43|  42.2k|        Encrypt(plain, {}, aad, nonce, cipher);
   44|  42.2k|    }

_Z9WriteLE32ITk8ByteTypeSt4byteEvPT_j:
   51|   320M|{
   52|   320M|    uint32_t v = htole32_internal(x);
   53|   320M|    memcpy(ptr, &v, 4);
   54|   320M|}
_Z8ReadLE32ITk8ByteTypeSt4byteEjPKT_:
   28|   318M|{
   29|   318M|    uint32_t x;
   30|   318M|    memcpy(&x, ptr, 4);
   31|   318M|    return le32toh_internal(x);
   32|   318M|}
_Z9WriteLE64ITk8ByteTypeSt4byteEvPT_m:
   58|   167k|{
   59|   167k|    uint64_t v = htole64_internal(x);
   60|   167k|    memcpy(ptr, &v, 8);
   61|   167k|}
_Z8ReadBE32ITk8ByteTypehEjPKT_:
   73|  4.73M|{
   74|  4.73M|    uint32_t x;
   75|  4.73M|    memcpy(&x, ptr, 4);
   76|  4.73M|    return be32toh_internal(x);
   77|  4.73M|}
_Z9WriteBE32ITk8ByteTypehEvPT_j:
   96|  1.43M|{
   97|  1.43M|    uint32_t v = htobe32_internal(x);
   98|  1.43M|    memcpy(ptr, &v, 4);
   99|  1.43M|}
_Z8ReadBE64ITk8ByteTypehEmPKT_:
   81|  1.93M|{
   82|  1.93M|    uint64_t x;
   83|  1.93M|    memcpy(&x, ptr, 8);
   84|  1.93M|    return be64toh_internal(x);
   85|  1.93M|}
_Z9WriteBE64ITk8ByteTypehEvPT_m:
  103|   780k|{
  104|   780k|    uint64_t v = htobe64_internal(x);
  105|   780k|    memcpy(ptr, &v, 8);
  106|   780k|}
_Z8ReadLE32ITk8ByteTypehEjPKT_:
   28|   404M|{
   29|   404M|    uint32_t x;
   30|   404M|    memcpy(&x, ptr, 4);
   31|   404M|    return le32toh_internal(x);
   32|   404M|}
_Z9WriteLE32ITk8ByteTypehEvPT_j:
   51|   335k|{
   52|   335k|    uint32_t v = htole32_internal(x);
   53|   335k|    memcpy(ptr, &v, 4);
   54|   335k|}

_Z6HexStrNSt3__14spanIKhLm18446744073709551615EEE:
   30|  4.84k|{
   31|  4.84k|    std::string rv(s.size() * 2, '\0');
   32|  4.84k|    static constexpr auto byte_to_hex = CreateByteToHexMap();
   33|  4.84k|    static_assert(sizeof(byte_to_hex) == 512);
   34|       |
   35|  4.84k|    char* it = rv.data();
   36|   217k|    for (uint8_t v : s) {
  ------------------
  |  Branch (36:20): [True: 217k, False: 4.84k]
  ------------------
   37|   217k|        std::memcpy(it, byte_to_hex[v].data(), 2);
   38|   217k|        it += 2;
   39|   217k|    }
   40|       |
   41|  4.84k|    assert(it == rv.data() + rv.size());
  ------------------
  |  Branch (41:5): [True: 4.84k, False: 0]
  ------------------
   42|  4.84k|    return rv;
   43|  4.84k|}

_Z6HexStrNSt3__14spanIKSt4byteLm18446744073709551615EEE:
   19|  1.48k|inline std::string HexStr(const std::span<const std::byte> s) { return HexStr(MakeUCharSpan(s)); }

_ZN12CHMAC_SHA256C2EPKhm:
   10|  44.5k|{
   11|  44.5k|    unsigned char rkey[64];
   12|  44.5k|    if (keylen <= 64) {
  ------------------
  |  Branch (12:9): [True: 44.5k, False: 0]
  ------------------
   13|  44.5k|        memcpy(rkey, key, keylen);
   14|  44.5k|        memset(rkey + keylen, 0, 64 - keylen);
   15|  44.5k|    } else {
   16|      0|        CSHA256().Write(key, keylen).Finalize(rkey);
   17|      0|        memset(rkey + 32, 0, 32);
   18|      0|    }
   19|       |
   20|  2.89M|    for (int n = 0; n < 64; n++)
  ------------------
  |  Branch (20:21): [True: 2.84M, False: 44.5k]
  ------------------
   21|  2.84M|        rkey[n] ^= 0x5c;
   22|  44.5k|    outer.Write(rkey, 64);
   23|       |
   24|  2.89M|    for (int n = 0; n < 64; n++)
  ------------------
  |  Branch (24:21): [True: 2.84M, False: 44.5k]
  ------------------
   25|  2.84M|        rkey[n] ^= 0x5c ^ 0x36;
   26|  44.5k|    inner.Write(rkey, 64);
   27|  44.5k|}
_ZN12CHMAC_SHA2568FinalizeEPh:
   30|  44.5k|{
   31|  44.5k|    unsigned char temp[32];
   32|  44.5k|    inner.Finalize(temp);
   33|  44.5k|    outer.Write(temp, 32).Finalize(hash);
   34|  44.5k|}

_ZN12CHMAC_SHA2565WriteEPKhm:
   25|  44.5k|    {
   26|  44.5k|        inner.Write(data, len);
   27|  44.5k|        return *this;
   28|  44.5k|    }

_ZN12CHMAC_SHA512C2EPKhm:
   10|  26.8k|{
   11|  26.8k|    unsigned char rkey[128];
   12|  26.8k|    if (keylen <= 128) {
  ------------------
  |  Branch (12:9): [True: 26.8k, False: 0]
  ------------------
   13|  26.8k|        memcpy(rkey, key, keylen);
   14|  26.8k|        memset(rkey + keylen, 0, 128 - keylen);
   15|  26.8k|    } else {
   16|      0|        CSHA512().Write(key, keylen).Finalize(rkey);
   17|      0|        memset(rkey + 64, 0, 64);
   18|      0|    }
   19|       |
   20|  3.46M|    for (int n = 0; n < 128; n++)
  ------------------
  |  Branch (20:21): [True: 3.44M, False: 26.8k]
  ------------------
   21|  3.44M|        rkey[n] ^= 0x5c;
   22|  26.8k|    outer.Write(rkey, 128);
   23|       |
   24|  3.46M|    for (int n = 0; n < 128; n++)
  ------------------
  |  Branch (24:21): [True: 3.44M, False: 26.8k]
  ------------------
   25|  3.44M|        rkey[n] ^= 0x5c ^ 0x36;
   26|  26.8k|    inner.Write(rkey, 128);
   27|  26.8k|}
_ZN12CHMAC_SHA5128FinalizeEPh:
   30|  26.8k|{
   31|  26.8k|    unsigned char temp[64];
   32|  26.8k|    inner.Finalize(temp);
   33|  26.8k|    outer.Write(temp, 64).Finalize(hash);
   34|  26.8k|}

_ZN12CHMAC_SHA5125WriteEPKhm:
   25|  73.9k|    {
   26|  73.9k|        inner.Write(data, len);
   27|  73.9k|        return *this;
   28|  73.9k|    }

_ZN14poly1305_donna13poly1305_initEPNS_16poly1305_contextEPKh:
   15|  83.7k|void poly1305_init(poly1305_context *st, const unsigned char key[32]) noexcept {
   16|       |    /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */
   17|  83.7k|    st->r[0] = (ReadLE32(&key[ 0])     ) & 0x3ffffff;
   18|  83.7k|    st->r[1] = (ReadLE32(&key[ 3]) >> 2) & 0x3ffff03;
   19|  83.7k|    st->r[2] = (ReadLE32(&key[ 6]) >> 4) & 0x3ffc0ff;
   20|  83.7k|    st->r[3] = (ReadLE32(&key[ 9]) >> 6) & 0x3f03fff;
   21|  83.7k|    st->r[4] = (ReadLE32(&key[12]) >> 8) & 0x00fffff;
   22|       |
   23|       |    /* h = 0 */
   24|  83.7k|    st->h[0] = 0;
   25|  83.7k|    st->h[1] = 0;
   26|  83.7k|    st->h[2] = 0;
   27|  83.7k|    st->h[3] = 0;
   28|  83.7k|    st->h[4] = 0;
   29|       |
   30|       |    /* save pad for later */
   31|  83.7k|    st->pad[0] = ReadLE32(&key[16]);
   32|  83.7k|    st->pad[1] = ReadLE32(&key[20]);
   33|  83.7k|    st->pad[2] = ReadLE32(&key[24]);
   34|  83.7k|    st->pad[3] = ReadLE32(&key[28]);
   35|       |
   36|  83.7k|    st->leftover = 0;
   37|  83.7k|    st->final = 0;
   38|  83.7k|}
_ZN14poly1305_donna15poly1305_finishEPNS_16poly1305_contextEPh:
  100|  83.7k|void poly1305_finish(poly1305_context *st, unsigned char mac[16]) noexcept {
  101|  83.7k|    uint32_t h0,h1,h2,h3,h4,c;
  102|  83.7k|    uint32_t g0,g1,g2,g3,g4;
  103|  83.7k|    uint64_t f;
  104|  83.7k|    uint32_t mask;
  105|       |
  106|       |    /* process the remaining block */
  107|  83.7k|    if (st->leftover) {
  ------------------
  |  Branch (107:9): [True: 0, False: 83.7k]
  ------------------
  108|      0|        size_t i = st->leftover;
  109|      0|        st->buffer[i++] = 1;
  110|      0|        for (; i < POLY1305_BLOCK_SIZE; i++) {
  ------------------
  |  |   14|      0|#define POLY1305_BLOCK_SIZE 16
  ------------------
  |  Branch (110:16): [True: 0, False: 0]
  ------------------
  111|      0|            st->buffer[i] = 0;
  112|      0|        }
  113|      0|        st->final = 1;
  114|      0|        poly1305_blocks(st, st->buffer, POLY1305_BLOCK_SIZE);
  ------------------
  |  |   14|      0|#define POLY1305_BLOCK_SIZE 16
  ------------------
  115|      0|    }
  116|       |
  117|       |    /* fully carry h */
  118|  83.7k|    h0 = st->h[0];
  119|  83.7k|    h1 = st->h[1];
  120|  83.7k|    h2 = st->h[2];
  121|  83.7k|    h3 = st->h[3];
  122|  83.7k|    h4 = st->h[4];
  123|       |
  124|  83.7k|                 c = h1 >> 26; h1 = h1 & 0x3ffffff;
  125|  83.7k|    h2 +=     c; c = h2 >> 26; h2 = h2 & 0x3ffffff;
  126|  83.7k|    h3 +=     c; c = h3 >> 26; h3 = h3 & 0x3ffffff;
  127|  83.7k|    h4 +=     c; c = h4 >> 26; h4 = h4 & 0x3ffffff;
  128|  83.7k|    h0 += c * 5; c = h0 >> 26; h0 = h0 & 0x3ffffff;
  129|  83.7k|    h1 +=     c;
  130|       |
  131|       |    /* compute h + -p */
  132|  83.7k|    g0 = h0 + 5; c = g0 >> 26; g0 &= 0x3ffffff;
  133|  83.7k|    g1 = h1 + c; c = g1 >> 26; g1 &= 0x3ffffff;
  134|  83.7k|    g2 = h2 + c; c = g2 >> 26; g2 &= 0x3ffffff;
  135|  83.7k|    g3 = h3 + c; c = g3 >> 26; g3 &= 0x3ffffff;
  136|  83.7k|    g4 = h4 + c - (1UL << 26);
  137|       |
  138|       |    /* select h if h < p, or h + -p if h >= p */
  139|  83.7k|    mask = (g4 >> ((sizeof(uint32_t) * 8) - 1)) - 1;
  140|  83.7k|    g0 &= mask;
  141|  83.7k|    g1 &= mask;
  142|  83.7k|    g2 &= mask;
  143|  83.7k|    g3 &= mask;
  144|  83.7k|    g4 &= mask;
  145|  83.7k|    mask = ~mask;
  146|  83.7k|    h0 = (h0 & mask) | g0;
  147|  83.7k|    h1 = (h1 & mask) | g1;
  148|  83.7k|    h2 = (h2 & mask) | g2;
  149|  83.7k|    h3 = (h3 & mask) | g3;
  150|  83.7k|    h4 = (h4 & mask) | g4;
  151|       |
  152|       |    /* h = h % (2^128) */
  153|  83.7k|    h0 = ((h0      ) | (h1 << 26)) & 0xffffffff;
  154|  83.7k|    h1 = ((h1 >>  6) | (h2 << 20)) & 0xffffffff;
  155|  83.7k|    h2 = ((h2 >> 12) | (h3 << 14)) & 0xffffffff;
  156|  83.7k|    h3 = ((h3 >> 18) | (h4 <<  8)) & 0xffffffff;
  157|       |
  158|       |    /* mac = (h + pad) % (2^128) */
  159|  83.7k|    f = (uint64_t)h0 + st->pad[0]            ; h0 = (uint32_t)f;
  160|  83.7k|    f = (uint64_t)h1 + st->pad[1] + (f >> 32); h1 = (uint32_t)f;
  161|  83.7k|    f = (uint64_t)h2 + st->pad[2] + (f >> 32); h2 = (uint32_t)f;
  162|  83.7k|    f = (uint64_t)h3 + st->pad[3] + (f >> 32); h3 = (uint32_t)f;
  163|       |
  164|  83.7k|    WriteLE32(mac +  0, h0);
  165|  83.7k|    WriteLE32(mac +  4, h1);
  166|  83.7k|    WriteLE32(mac +  8, h2);
  167|  83.7k|    WriteLE32(mac + 12, h3);
  168|       |
  169|       |    /* zero out the state */
  170|  83.7k|    st->h[0] = 0;
  171|  83.7k|    st->h[1] = 0;
  172|  83.7k|    st->h[2] = 0;
  173|  83.7k|    st->h[3] = 0;
  174|  83.7k|    st->h[4] = 0;
  175|  83.7k|    st->r[0] = 0;
  176|  83.7k|    st->r[1] = 0;
  177|  83.7k|    st->r[2] = 0;
  178|  83.7k|    st->r[3] = 0;
  179|  83.7k|    st->r[4] = 0;
  180|  83.7k|    st->pad[0] = 0;
  181|  83.7k|    st->pad[1] = 0;
  182|  83.7k|    st->pad[2] = 0;
  183|  83.7k|    st->pad[3] = 0;
  184|  83.7k|}
_ZN14poly1305_donna15poly1305_updateEPNS_16poly1305_contextEPKhm:
  186|   418k|void poly1305_update(poly1305_context *st, const unsigned char *m, size_t bytes) noexcept {
  187|   418k|    size_t i;
  188|       |
  189|       |    /* handle leftover */
  190|   418k|    if (st->leftover) {
  ------------------
  |  Branch (190:9): [True: 71.9k, False: 346k]
  ------------------
  191|  71.9k|        size_t want = (POLY1305_BLOCK_SIZE - st->leftover);
  ------------------
  |  |   14|  71.9k|#define POLY1305_BLOCK_SIZE 16
  ------------------
  192|  71.9k|        if (want > bytes) {
  ------------------
  |  Branch (192:13): [True: 0, False: 71.9k]
  ------------------
  193|      0|            want = bytes;
  194|      0|        }
  195|   609k|        for (i = 0; i < want; i++) {
  ------------------
  |  Branch (195:21): [True: 538k, False: 71.9k]
  ------------------
  196|   538k|            st->buffer[st->leftover + i] = m[i];
  197|   538k|        }
  198|  71.9k|        bytes -= want;
  199|  71.9k|        m += want;
  200|  71.9k|        st->leftover += want;
  201|  71.9k|        if (st->leftover < POLY1305_BLOCK_SIZE) return;
  ------------------
  |  |   14|  71.9k|#define POLY1305_BLOCK_SIZE 16
  ------------------
  |  Branch (201:13): [True: 0, False: 71.9k]
  ------------------
  202|  71.9k|        poly1305_blocks(st, st->buffer, POLY1305_BLOCK_SIZE);
  ------------------
  |  |   14|  71.9k|#define POLY1305_BLOCK_SIZE 16
  ------------------
  203|  71.9k|        st->leftover = 0;
  204|  71.9k|    }
  205|       |
  206|       |    /* process full blocks */
  207|   418k|    if (bytes >= POLY1305_BLOCK_SIZE) {
  ------------------
  |  |   14|   418k|#define POLY1305_BLOCK_SIZE 16
  ------------------
  |  Branch (207:9): [True: 179k, False: 239k]
  ------------------
  208|   179k|        size_t want = (bytes & ~(POLY1305_BLOCK_SIZE - 1));
  ------------------
  |  |   14|   179k|#define POLY1305_BLOCK_SIZE 16
  ------------------
  209|   179k|        poly1305_blocks(st, m, want);
  210|   179k|        m += want;
  211|   179k|        bytes -= want;
  212|   179k|    }
  213|       |
  214|       |    /* store leftover */
  215|   418k|    if (bytes) {
  ------------------
  |  Branch (215:9): [True: 71.9k, False: 346k]
  ------------------
  216|   684k|        for (i = 0; i < bytes; i++) {
  ------------------
  |  Branch (216:21): [True: 613k, False: 71.9k]
  ------------------
  217|   613k|            st->buffer[st->leftover + i] = m[i];
  218|   613k|        }
  219|  71.9k|        st->leftover += bytes;
  220|  71.9k|    }
  221|   418k|}
poly1305.cpp:_ZN14poly1305_donnaL15poly1305_blocksEPNS_16poly1305_contextEPKhm:
   40|   251k|static void poly1305_blocks(poly1305_context *st, const unsigned char *m, size_t bytes) noexcept {
   41|   251k|    const uint32_t hibit = (st->final) ? 0 : (1UL << 24); /* 1 << 128 */
  ------------------
  |  Branch (41:28): [True: 0, False: 251k]
  ------------------
   42|   251k|    uint32_t r0,r1,r2,r3,r4;
   43|   251k|    uint32_t s1,s2,s3,s4;
   44|   251k|    uint32_t h0,h1,h2,h3,h4;
   45|   251k|    uint64_t d0,d1,d2,d3,d4;
   46|   251k|    uint32_t c;
   47|       |
   48|   251k|    r0 = st->r[0];
   49|   251k|    r1 = st->r[1];
   50|   251k|    r2 = st->r[2];
   51|   251k|    r3 = st->r[3];
   52|   251k|    r4 = st->r[4];
   53|       |
   54|   251k|    s1 = r1 * 5;
   55|   251k|    s2 = r2 * 5;
   56|   251k|    s3 = r3 * 5;
   57|   251k|    s4 = r4 * 5;
   58|       |
   59|   251k|    h0 = st->h[0];
   60|   251k|    h1 = st->h[1];
   61|   251k|    h2 = st->h[2];
   62|   251k|    h3 = st->h[3];
   63|   251k|    h4 = st->h[4];
   64|       |
   65|  80.9M|    while (bytes >= POLY1305_BLOCK_SIZE) {
  ------------------
  |  |   14|  80.9M|#define POLY1305_BLOCK_SIZE 16
  ------------------
  |  Branch (65:12): [True: 80.6M, False: 251k]
  ------------------
   66|       |        /* h += m[i] */
   67|  80.6M|        h0 += (ReadLE32(m+ 0)     ) & 0x3ffffff;
   68|  80.6M|        h1 += (ReadLE32(m+ 3) >> 2) & 0x3ffffff;
   69|  80.6M|        h2 += (ReadLE32(m+ 6) >> 4) & 0x3ffffff;
   70|  80.6M|        h3 += (ReadLE32(m+ 9) >> 6) & 0x3ffffff;
   71|  80.6M|        h4 += (ReadLE32(m+12) >> 8) | hibit;
   72|       |
   73|       |        /* h *= r */
   74|  80.6M|        d0 = ((uint64_t)h0 * r0) + ((uint64_t)h1 * s4) + ((uint64_t)h2 * s3) + ((uint64_t)h3 * s2) + ((uint64_t)h4 * s1);
   75|  80.6M|        d1 = ((uint64_t)h0 * r1) + ((uint64_t)h1 * r0) + ((uint64_t)h2 * s4) + ((uint64_t)h3 * s3) + ((uint64_t)h4 * s2);
   76|  80.6M|        d2 = ((uint64_t)h0 * r2) + ((uint64_t)h1 * r1) + ((uint64_t)h2 * r0) + ((uint64_t)h3 * s4) + ((uint64_t)h4 * s3);
   77|  80.6M|        d3 = ((uint64_t)h0 * r3) + ((uint64_t)h1 * r2) + ((uint64_t)h2 * r1) + ((uint64_t)h3 * r0) + ((uint64_t)h4 * s4);
   78|  80.6M|        d4 = ((uint64_t)h0 * r4) + ((uint64_t)h1 * r3) + ((uint64_t)h2 * r2) + ((uint64_t)h3 * r1) + ((uint64_t)h4 * r0);
   79|       |
   80|       |        /* (partial) h %= p */
   81|  80.6M|                      c = (uint32_t)(d0 >> 26); h0 = (uint32_t)d0 & 0x3ffffff;
   82|  80.6M|        d1 += c;      c = (uint32_t)(d1 >> 26); h1 = (uint32_t)d1 & 0x3ffffff;
   83|  80.6M|        d2 += c;      c = (uint32_t)(d2 >> 26); h2 = (uint32_t)d2 & 0x3ffffff;
   84|  80.6M|        d3 += c;      c = (uint32_t)(d3 >> 26); h3 = (uint32_t)d3 & 0x3ffffff;
   85|  80.6M|        d4 += c;      c = (uint32_t)(d4 >> 26); h4 = (uint32_t)d4 & 0x3ffffff;
   86|  80.6M|        h0 += c * 5;  c =           (h0 >> 26); h0 =           h0 & 0x3ffffff;
   87|  80.6M|        h1 += c;
   88|       |
   89|  80.6M|        m += POLY1305_BLOCK_SIZE;
  ------------------
  |  |   14|  80.6M|#define POLY1305_BLOCK_SIZE 16
  ------------------
   90|  80.6M|        bytes -= POLY1305_BLOCK_SIZE;
  ------------------
  |  |   14|  80.6M|#define POLY1305_BLOCK_SIZE 16
  ------------------
   91|  80.6M|    }
   92|       |
   93|   251k|    st->h[0] = h0;
   94|   251k|    st->h[1] = h1;
   95|   251k|    st->h[2] = h2;
   96|   251k|    st->h[3] = h3;
   97|   251k|    st->h[4] = h4;
   98|   251k|}

_ZN8Poly1305C2ENSt3__14spanIKSt4byteLm18446744073709551615EEE:
   50|  83.7k|    {
   51|  83.7k|        assert(key.size() == KEYLEN);
  ------------------
  |  Branch (51:9): [True: 83.7k, False: 0]
  ------------------
   52|  83.7k|        poly1305_donna::poly1305_init(&m_ctx, UCharCast(key.data()));
   53|  83.7k|    }
_ZN8Poly13056UpdateENSt3__14spanIKSt4byteLm18446744073709551615EEE:
   57|   418k|    {
   58|   418k|        poly1305_donna::poly1305_update(&m_ctx, UCharCast(msg.data()), msg.size());
   59|   418k|        return *this;
   60|   418k|    }
_ZN8Poly13058FinalizeENSt3__14spanISt4byteLm18446744073709551615EEE:
   64|  83.7k|    {
   65|  83.7k|        assert(out.size() == TAGLEN);
  ------------------
  |  Branch (65:9): [True: 83.7k, False: 0]
  ------------------
   66|  83.7k|        poly1305_donna::poly1305_finish(&m_ctx, UCharCast(out.data()));
   67|  83.7k|    }

_ZN7CSHA256C2Ev:
  695|   175k|{
  696|   175k|    sha256::Initialize(s);
  697|   175k|}
_ZN7CSHA2565WriteEPKhm:
  700|   648k|{
  701|   648k|    const unsigned char* end = data + len;
  702|   648k|    size_t bufsize = bytes % 64;
  703|   648k|    if (bufsize && bufsize + len >= 64) {
  ------------------
  |  Branch (703:9): [True: 381k, False: 267k]
  |  Branch (703:20): [True: 207k, False: 174k]
  ------------------
  704|       |        // Fill the buffer, and process it.
  705|   207k|        memcpy(buf + bufsize, data, 64 - bufsize);
  706|   207k|        bytes += 64 - bufsize;
  707|   207k|        data += 64 - bufsize;
  708|   207k|        Transform(s, buf, 1);
  709|   207k|        bufsize = 0;
  710|   207k|    }
  711|   648k|    if (end - data >= 64) {
  ------------------
  |  Branch (711:9): [True: 89.0k, False: 559k]
  ------------------
  712|  89.0k|        size_t blocks = (end - data) / 64;
  713|  89.0k|        Transform(s, data, blocks);
  714|  89.0k|        data += 64 * blocks;
  715|  89.0k|        bytes += 64 * blocks;
  716|  89.0k|    }
  717|   648k|    if (end > data) {
  ------------------
  |  Branch (717:9): [True: 374k, False: 273k]
  ------------------
  718|       |        // Fill the buffer with what remains.
  719|   374k|        memcpy(buf + bufsize, data, end - data);
  720|   374k|        bytes += end - data;
  721|   374k|    }
  722|   648k|    return *this;
  723|   648k|}
_ZN7CSHA2568FinalizeEPh:
  726|   175k|{
  727|   175k|    static const unsigned char pad[64] = {0x80};
  728|   175k|    unsigned char sizedesc[8];
  729|   175k|    WriteBE64(sizedesc, bytes << 3);
  730|   175k|    Write(pad, 1 + ((119 - (bytes % 64)) % 64));
  731|   175k|    Write(sizedesc, 8);
  732|   175k|    WriteBE32(hash, s[0]);
  733|   175k|    WriteBE32(hash + 4, s[1]);
  734|   175k|    WriteBE32(hash + 8, s[2]);
  735|   175k|    WriteBE32(hash + 12, s[3]);
  736|   175k|    WriteBE32(hash + 16, s[4]);
  737|   175k|    WriteBE32(hash + 20, s[5]);
  738|   175k|    WriteBE32(hash + 24, s[6]);
  739|   175k|    WriteBE32(hash + 28, s[7]);
  740|   175k|}
sha256.cpp:_ZN12_GLOBAL__N_16sha2569TransformEPjPKhm:
  100|   296k|{
  101|   592k|    while (blocks--) {
  ------------------
  |  Branch (101:12): [True: 296k, False: 296k]
  ------------------
  102|   296k|        uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];
  103|   296k|        uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
  104|       |
  105|   296k|        Round(a, b, c, d, e, f, g, h, 0x428a2f98 + (w0 = ReadBE32(chunk + 0)));
  106|   296k|        Round(h, a, b, c, d, e, f, g, 0x71374491 + (w1 = ReadBE32(chunk + 4)));
  107|   296k|        Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf + (w2 = ReadBE32(chunk + 8)));
  108|   296k|        Round(f, g, h, a, b, c, d, e, 0xe9b5dba5 + (w3 = ReadBE32(chunk + 12)));
  109|   296k|        Round(e, f, g, h, a, b, c, d, 0x3956c25b + (w4 = ReadBE32(chunk + 16)));
  110|   296k|        Round(d, e, f, g, h, a, b, c, 0x59f111f1 + (w5 = ReadBE32(chunk + 20)));
  111|   296k|        Round(c, d, e, f, g, h, a, b, 0x923f82a4 + (w6 = ReadBE32(chunk + 24)));
  112|   296k|        Round(b, c, d, e, f, g, h, a, 0xab1c5ed5 + (w7 = ReadBE32(chunk + 28)));
  113|   296k|        Round(a, b, c, d, e, f, g, h, 0xd807aa98 + (w8 = ReadBE32(chunk + 32)));
  114|   296k|        Round(h, a, b, c, d, e, f, g, 0x12835b01 + (w9 = ReadBE32(chunk + 36)));
  115|   296k|        Round(g, h, a, b, c, d, e, f, 0x243185be + (w10 = ReadBE32(chunk + 40)));
  116|   296k|        Round(f, g, h, a, b, c, d, e, 0x550c7dc3 + (w11 = ReadBE32(chunk + 44)));
  117|   296k|        Round(e, f, g, h, a, b, c, d, 0x72be5d74 + (w12 = ReadBE32(chunk + 48)));
  118|   296k|        Round(d, e, f, g, h, a, b, c, 0x80deb1fe + (w13 = ReadBE32(chunk + 52)));
  119|   296k|        Round(c, d, e, f, g, h, a, b, 0x9bdc06a7 + (w14 = ReadBE32(chunk + 56)));
  120|   296k|        Round(b, c, d, e, f, g, h, a, 0xc19bf174 + (w15 = ReadBE32(chunk + 60)));
  121|       |
  122|   296k|        Round(a, b, c, d, e, f, g, h, 0xe49b69c1 + (w0 += sigma1(w14) + w9 + sigma0(w1)));
  123|   296k|        Round(h, a, b, c, d, e, f, g, 0xefbe4786 + (w1 += sigma1(w15) + w10 + sigma0(w2)));
  124|   296k|        Round(g, h, a, b, c, d, e, f, 0x0fc19dc6 + (w2 += sigma1(w0) + w11 + sigma0(w3)));
  125|   296k|        Round(f, g, h, a, b, c, d, e, 0x240ca1cc + (w3 += sigma1(w1) + w12 + sigma0(w4)));
  126|   296k|        Round(e, f, g, h, a, b, c, d, 0x2de92c6f + (w4 += sigma1(w2) + w13 + sigma0(w5)));
  127|   296k|        Round(d, e, f, g, h, a, b, c, 0x4a7484aa + (w5 += sigma1(w3) + w14 + sigma0(w6)));
  128|   296k|        Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc + (w6 += sigma1(w4) + w15 + sigma0(w7)));
  129|   296k|        Round(b, c, d, e, f, g, h, a, 0x76f988da + (w7 += sigma1(w5) + w0 + sigma0(w8)));
  130|   296k|        Round(a, b, c, d, e, f, g, h, 0x983e5152 + (w8 += sigma1(w6) + w1 + sigma0(w9)));
  131|   296k|        Round(h, a, b, c, d, e, f, g, 0xa831c66d + (w9 += sigma1(w7) + w2 + sigma0(w10)));
  132|   296k|        Round(g, h, a, b, c, d, e, f, 0xb00327c8 + (w10 += sigma1(w8) + w3 + sigma0(w11)));
  133|   296k|        Round(f, g, h, a, b, c, d, e, 0xbf597fc7 + (w11 += sigma1(w9) + w4 + sigma0(w12)));
  134|   296k|        Round(e, f, g, h, a, b, c, d, 0xc6e00bf3 + (w12 += sigma1(w10) + w5 + sigma0(w13)));
  135|   296k|        Round(d, e, f, g, h, a, b, c, 0xd5a79147 + (w13 += sigma1(w11) + w6 + sigma0(w14)));
  136|   296k|        Round(c, d, e, f, g, h, a, b, 0x06ca6351 + (w14 += sigma1(w12) + w7 + sigma0(w15)));
  137|   296k|        Round(b, c, d, e, f, g, h, a, 0x14292967 + (w15 += sigma1(w13) + w8 + sigma0(w0)));
  138|       |
  139|   296k|        Round(a, b, c, d, e, f, g, h, 0x27b70a85 + (w0 += sigma1(w14) + w9 + sigma0(w1)));
  140|   296k|        Round(h, a, b, c, d, e, f, g, 0x2e1b2138 + (w1 += sigma1(w15) + w10 + sigma0(w2)));
  141|   296k|        Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc + (w2 += sigma1(w0) + w11 + sigma0(w3)));
  142|   296k|        Round(f, g, h, a, b, c, d, e, 0x53380d13 + (w3 += sigma1(w1) + w12 + sigma0(w4)));
  143|   296k|        Round(e, f, g, h, a, b, c, d, 0x650a7354 + (w4 += sigma1(w2) + w13 + sigma0(w5)));
  144|   296k|        Round(d, e, f, g, h, a, b, c, 0x766a0abb + (w5 += sigma1(w3) + w14 + sigma0(w6)));
  145|   296k|        Round(c, d, e, f, g, h, a, b, 0x81c2c92e + (w6 += sigma1(w4) + w15 + sigma0(w7)));
  146|   296k|        Round(b, c, d, e, f, g, h, a, 0x92722c85 + (w7 += sigma1(w5) + w0 + sigma0(w8)));
  147|   296k|        Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1 + (w8 += sigma1(w6) + w1 + sigma0(w9)));
  148|   296k|        Round(h, a, b, c, d, e, f, g, 0xa81a664b + (w9 += sigma1(w7) + w2 + sigma0(w10)));
  149|   296k|        Round(g, h, a, b, c, d, e, f, 0xc24b8b70 + (w10 += sigma1(w8) + w3 + sigma0(w11)));
  150|   296k|        Round(f, g, h, a, b, c, d, e, 0xc76c51a3 + (w11 += sigma1(w9) + w4 + sigma0(w12)));
  151|   296k|        Round(e, f, g, h, a, b, c, d, 0xd192e819 + (w12 += sigma1(w10) + w5 + sigma0(w13)));
  152|   296k|        Round(d, e, f, g, h, a, b, c, 0xd6990624 + (w13 += sigma1(w11) + w6 + sigma0(w14)));
  153|   296k|        Round(c, d, e, f, g, h, a, b, 0xf40e3585 + (w14 += sigma1(w12) + w7 + sigma0(w15)));
  154|   296k|        Round(b, c, d, e, f, g, h, a, 0x106aa070 + (w15 += sigma1(w13) + w8 + sigma0(w0)));
  155|       |
  156|   296k|        Round(a, b, c, d, e, f, g, h, 0x19a4c116 + (w0 += sigma1(w14) + w9 + sigma0(w1)));
  157|   296k|        Round(h, a, b, c, d, e, f, g, 0x1e376c08 + (w1 += sigma1(w15) + w10 + sigma0(w2)));
  158|   296k|        Round(g, h, a, b, c, d, e, f, 0x2748774c + (w2 += sigma1(w0) + w11 + sigma0(w3)));
  159|   296k|        Round(f, g, h, a, b, c, d, e, 0x34b0bcb5 + (w3 += sigma1(w1) + w12 + sigma0(w4)));
  160|   296k|        Round(e, f, g, h, a, b, c, d, 0x391c0cb3 + (w4 += sigma1(w2) + w13 + sigma0(w5)));
  161|   296k|        Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a + (w5 += sigma1(w3) + w14 + sigma0(w6)));
  162|   296k|        Round(c, d, e, f, g, h, a, b, 0x5b9cca4f + (w6 += sigma1(w4) + w15 + sigma0(w7)));
  163|   296k|        Round(b, c, d, e, f, g, h, a, 0x682e6ff3 + (w7 += sigma1(w5) + w0 + sigma0(w8)));
  164|   296k|        Round(a, b, c, d, e, f, g, h, 0x748f82ee + (w8 += sigma1(w6) + w1 + sigma0(w9)));
  165|   296k|        Round(h, a, b, c, d, e, f, g, 0x78a5636f + (w9 += sigma1(w7) + w2 + sigma0(w10)));
  166|   296k|        Round(g, h, a, b, c, d, e, f, 0x84c87814 + (w10 += sigma1(w8) + w3 + sigma0(w11)));
  167|   296k|        Round(f, g, h, a, b, c, d, e, 0x8cc70208 + (w11 += sigma1(w9) + w4 + sigma0(w12)));
  168|   296k|        Round(e, f, g, h, a, b, c, d, 0x90befffa + (w12 += sigma1(w10) + w5 + sigma0(w13)));
  169|   296k|        Round(d, e, f, g, h, a, b, c, 0xa4506ceb + (w13 += sigma1(w11) + w6 + sigma0(w14)));
  170|   296k|        Round(c, d, e, f, g, h, a, b, 0xbef9a3f7 + (w14 + sigma1(w12) + w7 + sigma0(w15)));
  171|   296k|        Round(b, c, d, e, f, g, h, a, 0xc67178f2 + (w15 + sigma1(w13) + w8 + sigma0(w0)));
  172|       |
  173|   296k|        s[0] += a;
  174|   296k|        s[1] += b;
  175|   296k|        s[2] += c;
  176|   296k|        s[3] += d;
  177|   296k|        s[4] += e;
  178|   296k|        s[5] += f;
  179|   296k|        s[6] += g;
  180|   296k|        s[7] += h;
  181|   296k|        chunk += 64;
  182|   296k|    }
  183|   296k|}
sha256.cpp:_ZN12_GLOBAL__N_16sha2565RoundEjjjRjjjjS1_j:
   78|  18.9M|{
   79|  18.9M|    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k;
   80|  18.9M|    uint32_t t2 = Sigma0(a) + Maj(a, b, c);
   81|  18.9M|    d += t1;
   82|  18.9M|    h = t1 + t2;
   83|  18.9M|}
sha256.cpp:_ZN12_GLOBAL__N_16sha2566Sigma1Ej:
   72|  18.9M|uint32_t inline Sigma1(uint32_t x) { return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); }
sha256.cpp:_ZN12_GLOBAL__N_16sha2562ChEjjj:
   69|  18.9M|uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x & (y ^ z)); }
sha256.cpp:_ZN12_GLOBAL__N_16sha2566Sigma0Ej:
   71|  18.9M|uint32_t inline Sigma0(uint32_t x) { return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); }
sha256.cpp:_ZN12_GLOBAL__N_16sha2563MajEjjj:
   70|  18.9M|uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (z & (x | y)); }
sha256.cpp:_ZN12_GLOBAL__N_16sha2566sigma1Ej:
   74|  14.2M|uint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }
sha256.cpp:_ZN12_GLOBAL__N_16sha2566sigma0Ej:
   73|  14.2M|uint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); }
sha256.cpp:_ZN12_GLOBAL__N_16sha25610InitializeEPj:
   87|   175k|{
   88|   175k|    s[0] = 0x6a09e667ul;
   89|   175k|    s[1] = 0xbb67ae85ul;
   90|   175k|    s[2] = 0x3c6ef372ul;
   91|   175k|    s[3] = 0xa54ff53aul;
   92|   175k|    s[4] = 0x510e527ful;
   93|   175k|    s[5] = 0x9b05688cul;
   94|   175k|    s[6] = 0x1f83d9abul;
   95|   175k|    s[7] = 0x5be0cd19ul;
   96|   175k|}

_ZN7CSHA512C2Ev:
  155|  67.2k|{
  156|  67.2k|    sha512::Initialize(s);
  157|  67.2k|}
_ZN7CSHA5125WriteEPKhm:
  160|   356k|{
  161|   356k|    const unsigned char* end = data + len;
  162|   356k|    size_t bufsize = bytes % 128;
  163|   356k|    if (bufsize && bufsize + len >= 128) {
  ------------------
  |  Branch (163:9): [True: 235k, False: 120k]
  |  Branch (163:20): [True: 67.2k, False: 168k]
  ------------------
  164|       |        // Fill the buffer, and process it.
  165|  67.2k|        memcpy(buf + bufsize, data, 128 - bufsize);
  166|  67.2k|        bytes += 128 - bufsize;
  167|  67.2k|        data += 128 - bufsize;
  168|  67.2k|        sha512::Transform(s, buf);
  169|  67.2k|        bufsize = 0;
  170|  67.2k|    }
  171|   409k|    while (end - data >= 128) {
  ------------------
  |  Branch (171:12): [True: 53.7k, False: 356k]
  ------------------
  172|       |        // Process full chunks directly from the source.
  173|  53.7k|        sha512::Transform(s, data);
  174|  53.7k|        data += 128;
  175|  53.7k|        bytes += 128;
  176|  53.7k|    }
  177|   356k|    if (end > data) {
  ------------------
  |  Branch (177:9): [True: 235k, False: 120k]
  ------------------
  178|       |        // Fill the buffer with what remains.
  179|   235k|        memcpy(buf + bufsize, data, end - data);
  180|   235k|        bytes += end - data;
  181|   235k|    }
  182|   356k|    return *this;
  183|   356k|}
_ZN7CSHA5128FinalizeEPh:
  186|  67.2k|{
  187|  67.2k|    static const unsigned char pad[128] = {0x80};
  188|  67.2k|    unsigned char sizedesc[16] = {0x00};
  189|  67.2k|    WriteBE64(sizedesc + 8, bytes << 3);
  190|  67.2k|    Write(pad, 1 + ((239 - (bytes % 128)) % 128));
  191|  67.2k|    Write(sizedesc, 16);
  192|  67.2k|    WriteBE64(hash, s[0]);
  193|  67.2k|    WriteBE64(hash + 8, s[1]);
  194|  67.2k|    WriteBE64(hash + 16, s[2]);
  195|  67.2k|    WriteBE64(hash + 24, s[3]);
  196|  67.2k|    WriteBE64(hash + 32, s[4]);
  197|  67.2k|    WriteBE64(hash + 40, s[5]);
  198|  67.2k|    WriteBE64(hash + 48, s[6]);
  199|  67.2k|    WriteBE64(hash + 56, s[7]);
  200|  67.2k|}
_ZN7CSHA5125ResetEv:
  203|  13.4k|{
  204|  13.4k|    bytes = 0;
  205|  13.4k|    sha512::Initialize(s);
  206|  13.4k|    return *this;
  207|  13.4k|}
sha512.cpp:_ZN12_GLOBAL__N_16sha51210InitializeEPm:
   35|  80.6k|{
   36|  80.6k|    s[0] = 0x6a09e667f3bcc908ull;
   37|  80.6k|    s[1] = 0xbb67ae8584caa73bull;
   38|  80.6k|    s[2] = 0x3c6ef372fe94f82bull;
   39|  80.6k|    s[3] = 0xa54ff53a5f1d36f1ull;
   40|  80.6k|    s[4] = 0x510e527fade682d1ull;
   41|  80.6k|    s[5] = 0x9b05688c2b3e6c1full;
   42|  80.6k|    s[6] = 0x1f83d9abfb41bd6bull;
   43|  80.6k|    s[7] = 0x5be0cd19137e2179ull;
   44|  80.6k|}
sha512.cpp:_ZN12_GLOBAL__N_16sha5129TransformEPmPKh:
   48|   120k|{
   49|   120k|    uint64_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];
   50|   120k|    uint64_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
   51|       |
   52|   120k|    Round(a, b, c, d, e, f, g, h, 0x428a2f98d728ae22ull, w0 = ReadBE64(chunk + 0));
   53|   120k|    Round(h, a, b, c, d, e, f, g, 0x7137449123ef65cdull, w1 = ReadBE64(chunk + 8));
   54|   120k|    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcfec4d3b2full, w2 = ReadBE64(chunk + 16));
   55|   120k|    Round(f, g, h, a, b, c, d, e, 0xe9b5dba58189dbbcull, w3 = ReadBE64(chunk + 24));
   56|   120k|    Round(e, f, g, h, a, b, c, d, 0x3956c25bf348b538ull, w4 = ReadBE64(chunk + 32));
   57|   120k|    Round(d, e, f, g, h, a, b, c, 0x59f111f1b605d019ull, w5 = ReadBE64(chunk + 40));
   58|   120k|    Round(c, d, e, f, g, h, a, b, 0x923f82a4af194f9bull, w6 = ReadBE64(chunk + 48));
   59|   120k|    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5da6d8118ull, w7 = ReadBE64(chunk + 56));
   60|   120k|    Round(a, b, c, d, e, f, g, h, 0xd807aa98a3030242ull, w8 = ReadBE64(chunk + 64));
   61|   120k|    Round(h, a, b, c, d, e, f, g, 0x12835b0145706fbeull, w9 = ReadBE64(chunk + 72));
   62|   120k|    Round(g, h, a, b, c, d, e, f, 0x243185be4ee4b28cull, w10 = ReadBE64(chunk + 80));
   63|   120k|    Round(f, g, h, a, b, c, d, e, 0x550c7dc3d5ffb4e2ull, w11 = ReadBE64(chunk + 88));
   64|   120k|    Round(e, f, g, h, a, b, c, d, 0x72be5d74f27b896full, w12 = ReadBE64(chunk + 96));
   65|   120k|    Round(d, e, f, g, h, a, b, c, 0x80deb1fe3b1696b1ull, w13 = ReadBE64(chunk + 104));
   66|   120k|    Round(c, d, e, f, g, h, a, b, 0x9bdc06a725c71235ull, w14 = ReadBE64(chunk + 112));
   67|   120k|    Round(b, c, d, e, f, g, h, a, 0xc19bf174cf692694ull, w15 = ReadBE64(chunk + 120));
   68|       |
   69|   120k|    Round(a, b, c, d, e, f, g, h, 0xe49b69c19ef14ad2ull, w0 += sigma1(w14) + w9 + sigma0(w1));
   70|   120k|    Round(h, a, b, c, d, e, f, g, 0xefbe4786384f25e3ull, w1 += sigma1(w15) + w10 + sigma0(w2));
   71|   120k|    Round(g, h, a, b, c, d, e, f, 0x0fc19dc68b8cd5b5ull, w2 += sigma1(w0) + w11 + sigma0(w3));
   72|   120k|    Round(f, g, h, a, b, c, d, e, 0x240ca1cc77ac9c65ull, w3 += sigma1(w1) + w12 + sigma0(w4));
   73|   120k|    Round(e, f, g, h, a, b, c, d, 0x2de92c6f592b0275ull, w4 += sigma1(w2) + w13 + sigma0(w5));
   74|   120k|    Round(d, e, f, g, h, a, b, c, 0x4a7484aa6ea6e483ull, w5 += sigma1(w3) + w14 + sigma0(w6));
   75|   120k|    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dcbd41fbd4ull, w6 += sigma1(w4) + w15 + sigma0(w7));
   76|   120k|    Round(b, c, d, e, f, g, h, a, 0x76f988da831153b5ull, w7 += sigma1(w5) + w0 + sigma0(w8));
   77|   120k|    Round(a, b, c, d, e, f, g, h, 0x983e5152ee66dfabull, w8 += sigma1(w6) + w1 + sigma0(w9));
   78|   120k|    Round(h, a, b, c, d, e, f, g, 0xa831c66d2db43210ull, w9 += sigma1(w7) + w2 + sigma0(w10));
   79|   120k|    Round(g, h, a, b, c, d, e, f, 0xb00327c898fb213full, w10 += sigma1(w8) + w3 + sigma0(w11));
   80|   120k|    Round(f, g, h, a, b, c, d, e, 0xbf597fc7beef0ee4ull, w11 += sigma1(w9) + w4 + sigma0(w12));
   81|   120k|    Round(e, f, g, h, a, b, c, d, 0xc6e00bf33da88fc2ull, w12 += sigma1(w10) + w5 + sigma0(w13));
   82|   120k|    Round(d, e, f, g, h, a, b, c, 0xd5a79147930aa725ull, w13 += sigma1(w11) + w6 + sigma0(w14));
   83|   120k|    Round(c, d, e, f, g, h, a, b, 0x06ca6351e003826full, w14 += sigma1(w12) + w7 + sigma0(w15));
   84|   120k|    Round(b, c, d, e, f, g, h, a, 0x142929670a0e6e70ull, w15 += sigma1(w13) + w8 + sigma0(w0));
   85|       |
   86|   120k|    Round(a, b, c, d, e, f, g, h, 0x27b70a8546d22ffcull, w0 += sigma1(w14) + w9 + sigma0(w1));
   87|   120k|    Round(h, a, b, c, d, e, f, g, 0x2e1b21385c26c926ull, w1 += sigma1(w15) + w10 + sigma0(w2));
   88|   120k|    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc5ac42aedull, w2 += sigma1(w0) + w11 + sigma0(w3));
   89|   120k|    Round(f, g, h, a, b, c, d, e, 0x53380d139d95b3dfull, w3 += sigma1(w1) + w12 + sigma0(w4));
   90|   120k|    Round(e, f, g, h, a, b, c, d, 0x650a73548baf63deull, w4 += sigma1(w2) + w13 + sigma0(w5));
   91|   120k|    Round(d, e, f, g, h, a, b, c, 0x766a0abb3c77b2a8ull, w5 += sigma1(w3) + w14 + sigma0(w6));
   92|   120k|    Round(c, d, e, f, g, h, a, b, 0x81c2c92e47edaee6ull, w6 += sigma1(w4) + w15 + sigma0(w7));
   93|   120k|    Round(b, c, d, e, f, g, h, a, 0x92722c851482353bull, w7 += sigma1(w5) + w0 + sigma0(w8));
   94|   120k|    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a14cf10364ull, w8 += sigma1(w6) + w1 + sigma0(w9));
   95|   120k|    Round(h, a, b, c, d, e, f, g, 0xa81a664bbc423001ull, w9 += sigma1(w7) + w2 + sigma0(w10));
   96|   120k|    Round(g, h, a, b, c, d, e, f, 0xc24b8b70d0f89791ull, w10 += sigma1(w8) + w3 + sigma0(w11));
   97|   120k|    Round(f, g, h, a, b, c, d, e, 0xc76c51a30654be30ull, w11 += sigma1(w9) + w4 + sigma0(w12));
   98|   120k|    Round(e, f, g, h, a, b, c, d, 0xd192e819d6ef5218ull, w12 += sigma1(w10) + w5 + sigma0(w13));
   99|   120k|    Round(d, e, f, g, h, a, b, c, 0xd69906245565a910ull, w13 += sigma1(w11) + w6 + sigma0(w14));
  100|   120k|    Round(c, d, e, f, g, h, a, b, 0xf40e35855771202aull, w14 += sigma1(w12) + w7 + sigma0(w15));
  101|   120k|    Round(b, c, d, e, f, g, h, a, 0x106aa07032bbd1b8ull, w15 += sigma1(w13) + w8 + sigma0(w0));
  102|       |
  103|   120k|    Round(a, b, c, d, e, f, g, h, 0x19a4c116b8d2d0c8ull, w0 += sigma1(w14) + w9 + sigma0(w1));
  104|   120k|    Round(h, a, b, c, d, e, f, g, 0x1e376c085141ab53ull, w1 += sigma1(w15) + w10 + sigma0(w2));
  105|   120k|    Round(g, h, a, b, c, d, e, f, 0x2748774cdf8eeb99ull, w2 += sigma1(w0) + w11 + sigma0(w3));
  106|   120k|    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5e19b48a8ull, w3 += sigma1(w1) + w12 + sigma0(w4));
  107|   120k|    Round(e, f, g, h, a, b, c, d, 0x391c0cb3c5c95a63ull, w4 += sigma1(w2) + w13 + sigma0(w5));
  108|   120k|    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4ae3418acbull, w5 += sigma1(w3) + w14 + sigma0(w6));
  109|   120k|    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f7763e373ull, w6 += sigma1(w4) + w15 + sigma0(w7));
  110|   120k|    Round(b, c, d, e, f, g, h, a, 0x682e6ff3d6b2b8a3ull, w7 += sigma1(w5) + w0 + sigma0(w8));
  111|   120k|    Round(a, b, c, d, e, f, g, h, 0x748f82ee5defb2fcull, w8 += sigma1(w6) + w1 + sigma0(w9));
  112|   120k|    Round(h, a, b, c, d, e, f, g, 0x78a5636f43172f60ull, w9 += sigma1(w7) + w2 + sigma0(w10));
  113|   120k|    Round(g, h, a, b, c, d, e, f, 0x84c87814a1f0ab72ull, w10 += sigma1(w8) + w3 + sigma0(w11));
  114|   120k|    Round(f, g, h, a, b, c, d, e, 0x8cc702081a6439ecull, w11 += sigma1(w9) + w4 + sigma0(w12));
  115|   120k|    Round(e, f, g, h, a, b, c, d, 0x90befffa23631e28ull, w12 += sigma1(w10) + w5 + sigma0(w13));
  116|   120k|    Round(d, e, f, g, h, a, b, c, 0xa4506cebde82bde9ull, w13 += sigma1(w11) + w6 + sigma0(w14));
  117|   120k|    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7b2c67915ull, w14 += sigma1(w12) + w7 + sigma0(w15));
  118|   120k|    Round(b, c, d, e, f, g, h, a, 0xc67178f2e372532bull, w15 += sigma1(w13) + w8 + sigma0(w0));
  119|       |
  120|   120k|    Round(a, b, c, d, e, f, g, h, 0xca273eceea26619cull, w0 += sigma1(w14) + w9 + sigma0(w1));
  121|   120k|    Round(h, a, b, c, d, e, f, g, 0xd186b8c721c0c207ull, w1 += sigma1(w15) + w10 + sigma0(w2));
  122|   120k|    Round(g, h, a, b, c, d, e, f, 0xeada7dd6cde0eb1eull, w2 += sigma1(w0) + w11 + sigma0(w3));
  123|   120k|    Round(f, g, h, a, b, c, d, e, 0xf57d4f7fee6ed178ull, w3 += sigma1(w1) + w12 + sigma0(w4));
  124|   120k|    Round(e, f, g, h, a, b, c, d, 0x06f067aa72176fbaull, w4 += sigma1(w2) + w13 + sigma0(w5));
  125|   120k|    Round(d, e, f, g, h, a, b, c, 0x0a637dc5a2c898a6ull, w5 += sigma1(w3) + w14 + sigma0(w6));
  126|   120k|    Round(c, d, e, f, g, h, a, b, 0x113f9804bef90daeull, w6 += sigma1(w4) + w15 + sigma0(w7));
  127|   120k|    Round(b, c, d, e, f, g, h, a, 0x1b710b35131c471bull, w7 += sigma1(w5) + w0 + sigma0(w8));
  128|   120k|    Round(a, b, c, d, e, f, g, h, 0x28db77f523047d84ull, w8 += sigma1(w6) + w1 + sigma0(w9));
  129|   120k|    Round(h, a, b, c, d, e, f, g, 0x32caab7b40c72493ull, w9 += sigma1(w7) + w2 + sigma0(w10));
  130|   120k|    Round(g, h, a, b, c, d, e, f, 0x3c9ebe0a15c9bebcull, w10 += sigma1(w8) + w3 + sigma0(w11));
  131|   120k|    Round(f, g, h, a, b, c, d, e, 0x431d67c49c100d4cull, w11 += sigma1(w9) + w4 + sigma0(w12));
  132|   120k|    Round(e, f, g, h, a, b, c, d, 0x4cc5d4becb3e42b6ull, w12 += sigma1(w10) + w5 + sigma0(w13));
  133|   120k|    Round(d, e, f, g, h, a, b, c, 0x597f299cfc657e2aull, w13 += sigma1(w11) + w6 + sigma0(w14));
  134|   120k|    Round(c, d, e, f, g, h, a, b, 0x5fcb6fab3ad6faecull, w14 + sigma1(w12) + w7 + sigma0(w15));
  135|   120k|    Round(b, c, d, e, f, g, h, a, 0x6c44198c4a475817ull, w15 + sigma1(w13) + w8 + sigma0(w0));
  136|       |
  137|   120k|    s[0] += a;
  138|   120k|    s[1] += b;
  139|   120k|    s[2] += c;
  140|   120k|    s[3] += d;
  141|   120k|    s[4] += e;
  142|   120k|    s[5] += f;
  143|   120k|    s[6] += g;
  144|   120k|    s[7] += h;
  145|   120k|}
sha512.cpp:_ZN12_GLOBAL__N_16sha5125RoundEmmmRmmmmS1_mm:
   26|  9.67M|{
   27|  9.67M|    uint64_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;
   28|  9.67M|    uint64_t t2 = Sigma0(a) + Maj(a, b, c);
   29|  9.67M|    d += t1;
   30|  9.67M|    h = t1 + t2;
   31|  9.67M|}
sha512.cpp:_ZN12_GLOBAL__N_16sha5126Sigma1Em:
   20|  9.67M|uint64_t inline Sigma1(uint64_t x) { return (x >> 14 | x << 50) ^ (x >> 18 | x << 46) ^ (x >> 41 | x << 23); }
sha512.cpp:_ZN12_GLOBAL__N_16sha5122ChEmmm:
   17|  9.67M|uint64_t inline Ch(uint64_t x, uint64_t y, uint64_t z) { return z ^ (x & (y ^ z)); }
sha512.cpp:_ZN12_GLOBAL__N_16sha5126Sigma0Em:
   19|  9.67M|uint64_t inline Sigma0(uint64_t x) { return (x >> 28 | x << 36) ^ (x >> 34 | x << 30) ^ (x >> 39 | x << 25); }
sha512.cpp:_ZN12_GLOBAL__N_16sha5123MajEmmm:
   18|  9.67M|uint64_t inline Maj(uint64_t x, uint64_t y, uint64_t z) { return (x & y) | (z & (x | y)); }
sha512.cpp:_ZN12_GLOBAL__N_16sha5126sigma1Em:
   22|  7.74M|uint64_t inline sigma1(uint64_t x) { return (x >> 19 | x << 45) ^ (x >> 61 | x << 3) ^ (x >> 6); }
sha512.cpp:_ZN12_GLOBAL__N_16sha5126sigma0Em:
   21|  7.74M|uint64_t inline sigma0(uint64_t x) { return (x >> 1 | x << 63) ^ (x >> 8 | x << 56) ^ (x >> 7); }

_Z9BIP32HashRK7uint256jhPKhPh:
   72|  23.5k|{
   73|  23.5k|    unsigned char num[4];
   74|  23.5k|    WriteBE32(num, nChild);
   75|  23.5k|    CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);
   76|  23.5k|}

_ZN10HashWriterlsINSt3__14spanIKSt4byteLm18446744073709551615EEEEERS_RKT_:
  144|  32.0k|    {
  145|  32.0k|        ::Serialize(*this, obj);
  146|  32.0k|        return *this;
  147|  32.0k|    }
_Z7Hash160INSt3__14spanIKhLm18446744073709551615EEEE7uint160RKT_:
   95|  23.5k|{
   96|  23.5k|    uint160 result;
   97|  23.5k|    CHash160().Write(MakeUCharSpan(in1)).Finalize(result);
   98|  23.5k|    return result;
   99|  23.5k|}
_ZN8CHash1605WriteENSt3__14spanIKhLm18446744073709551615EEE:
   64|  23.5k|    CHash160& Write(std::span<const unsigned char> input) {
   65|  23.5k|        sha.Write(input.data(), input.size());
   66|  23.5k|        return *this;
   67|  23.5k|    }
_ZN8CHash1608FinalizeENSt3__14spanIhLm18446744073709551615EEE:
   55|  23.5k|    void Finalize(std::span<unsigned char> output) {
   56|  23.5k|        assert(output.size() == OUTPUT_SIZE);
  ------------------
  |  Branch (56:9): [True: 23.5k, False: 0]
  ------------------
   57|  23.5k|        unsigned char buf[CSHA256::OUTPUT_SIZE];
   58|  23.5k|        sha.Finalize(buf);
   59|  23.5k|        unsigned char second[CSHA256::OUTPUT_SIZE];
   60|  23.5k|        CSHA256().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(second);
   61|  23.5k|        std::copy(second, second + OUTPUT_SIZE, output.begin());
   62|  23.5k|    }
_ZN10HashWriter9GetSHA256Ev:
  128|  32.0k|    uint256 GetSHA256() {
  129|  32.0k|        uint256 result;
  130|  32.0k|        ctx.Finalize(result.begin());
  131|  32.0k|        return result;
  132|  32.0k|    }
_ZN10HashWriterlsI7uint256EERS_RKT_:
  144|  32.0k|    {
  145|  32.0k|        ::Serialize(*this, obj);
  146|  32.0k|        return *this;
  147|  32.0k|    }
_ZN10HashWriterlsINSt3__14spanIKhLm32EEEEERS_RKT_:
  144|  32.0k|    {
  145|  32.0k|        ::Serialize(*this, obj);
  146|  32.0k|        return *this;
  147|  32.0k|    }
_ZN10HashWriter5writeENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  109|  64.0k|    {
  110|  64.0k|        ctx.Write(UCharCast(src.data()), src.size());
  111|  64.0k|    }

_ZN4CKey5CheckEPKh:
  157|  26.8k|bool CKey::Check(const unsigned char *vch) {
  158|  26.8k|    return secp256k1_ec_seckey_verify(secp256k1_context_sign, vch);
  159|  26.8k|}
_ZNK4CKey9GetPubKeyEv:
  182|  59.0k|CPubKey CKey::GetPubKey() const {
  183|  59.0k|    assert(keydata);
  ------------------
  |  Branch (183:5): [True: 59.0k, False: 0]
  ------------------
  184|  59.0k|    secp256k1_pubkey pubkey;
  185|  59.0k|    size_t clen = CPubKey::SIZE;
  186|  59.0k|    CPubKey result;
  187|  59.0k|    int ret = secp256k1_ec_pubkey_create(secp256k1_context_sign, &pubkey, UCharCast(begin()));
  188|  59.0k|    assert(ret);
  ------------------
  |  Branch (188:5): [True: 59.0k, False: 0]
  ------------------
  189|  59.0k|    secp256k1_ec_pubkey_serialize(secp256k1_context_sign, (unsigned char*)result.begin(), &clen, &pubkey, fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);
  ------------------
  |  |  224|  59.0k|#define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)
  |  |  ------------------
  |  |  |  |  205|  59.0k|#define SECP256K1_FLAGS_TYPE_COMPRESSION (1 << 1)
  |  |  ------------------
  |  |               #define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)
  |  |  ------------------
  |  |  |  |  210|  59.0k|#define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)
  |  |  ------------------
  ------------------
                  secp256k1_ec_pubkey_serialize(secp256k1_context_sign, (unsigned char*)result.begin(), &clen, &pubkey, fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);
  ------------------
  |  |  225|  59.0k|#define SECP256K1_EC_UNCOMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION)
  |  |  ------------------
  |  |  |  |  205|      0|#define SECP256K1_FLAGS_TYPE_COMPRESSION (1 << 1)
  |  |  ------------------
  ------------------
  |  Branch (189:107): [True: 59.0k, False: 0]
  ------------------
  190|  59.0k|    assert(result.size() == clen);
  ------------------
  |  Branch (190:5): [True: 59.0k, False: 0]
  ------------------
  191|  59.0k|    assert(result.IsValid());
  ------------------
  |  Branch (191:5): [True: 59.0k, False: 0]
  ------------------
  192|  59.0k|    return result;
  193|  59.0k|}
_ZNK4CKey11SignSchnorrERK7uint256NSt3__14spanIhLm18446744073709551615EEEPS1_S2_:
  273|  3.36k|{
  274|  3.36k|    KeyPair kp = ComputeKeyPair(merkle_root);
  275|  3.36k|    return kp.SignSchnorr(hash, sig, aux);
  276|  3.36k|}
_ZNK4CKey6DeriveERS_R7uint256jRKS1_:
  292|  23.5k|bool CKey::Derive(CKey& keyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const {
  293|  23.5k|    assert(IsValid());
  ------------------
  |  Branch (293:5): [True: 23.5k, False: 0]
  ------------------
  294|  23.5k|    assert(IsCompressed());
  ------------------
  |  Branch (294:5): [True: 23.5k, False: 0]
  ------------------
  295|  23.5k|    std::vector<unsigned char, secure_allocator<unsigned char>> vout(64);
  296|  23.5k|    if ((nChild >> 31) == 0) {
  ------------------
  |  Branch (296:9): [True: 23.5k, False: 0]
  ------------------
  297|  23.5k|        CPubKey pubkey = GetPubKey();
  298|  23.5k|        assert(pubkey.size() == CPubKey::COMPRESSED_SIZE);
  ------------------
  |  Branch (298:9): [True: 23.5k, False: 0]
  ------------------
  299|  23.5k|        BIP32Hash(cc, nChild, *pubkey.begin(), pubkey.begin()+1, vout.data());
  300|  23.5k|    } else {
  301|      0|        assert(size() == 32);
  ------------------
  |  Branch (301:9): [True: 0, False: 0]
  ------------------
  302|      0|        BIP32Hash(cc, nChild, 0, UCharCast(begin()), vout.data());
  303|      0|    }
  304|  23.5k|    memcpy(ccChild.begin(), vout.data()+32, 32);
  305|  23.5k|    keyChild.Set(begin(), begin() + 32, true);
  306|  23.5k|    bool ret = secp256k1_ec_seckey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), vout.data());
  307|  23.5k|    if (!ret) keyChild.ClearKeyData();
  ------------------
  |  Branch (307:9): [True: 0, False: 23.5k]
  ------------------
  308|  23.5k|    return ret;
  309|  23.5k|}
_ZNK4CKey14EllSwiftCreateENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  312|  13.4k|{
  313|  13.4k|    assert(keydata);
  ------------------
  |  Branch (313:5): [True: 13.4k, False: 0]
  ------------------
  314|  13.4k|    assert(ent32.size() == 32);
  ------------------
  |  Branch (314:5): [True: 13.4k, False: 0]
  ------------------
  315|  13.4k|    std::array<std::byte, EllSwiftPubKey::size()> encoded_pubkey;
  316|       |
  317|  13.4k|    auto success = secp256k1_ellswift_create(secp256k1_context_sign,
  318|  13.4k|                                             UCharCast(encoded_pubkey.data()),
  319|  13.4k|                                             keydata->data(),
  320|  13.4k|                                             UCharCast(ent32.data()));
  321|       |
  322|       |    // Should always succeed for valid keys (asserted above).
  323|  13.4k|    assert(success);
  ------------------
  |  Branch (323:5): [True: 13.4k, False: 0]
  ------------------
  324|  13.4k|    return {encoded_pubkey};
  325|  13.4k|}
_ZNK4CKey23ComputeBIP324ECDHSecretERK14EllSwiftPubKeyS2_b:
  328|  12.6k|{
  329|  12.6k|    assert(keydata);
  ------------------
  |  Branch (329:5): [True: 12.6k, False: 0]
  ------------------
  330|       |
  331|  12.6k|    ECDHSecret output;
  332|       |    // BIP324 uses the initiator as party A, and the responder as party B. Remap the inputs
  333|       |    // accordingly:
  334|  12.6k|    bool success = secp256k1_ellswift_xdh(secp256k1_context_sign,
  335|  12.6k|                                          UCharCast(output.data()),
  336|  12.6k|                                          UCharCast(initiating ? our_ellswift.data() : their_ellswift.data()),
  ------------------
  |  Branch (336:53): [True: 5.96k, False: 6.72k]
  ------------------
  337|  12.6k|                                          UCharCast(initiating ? their_ellswift.data() : our_ellswift.data()),
  ------------------
  |  Branch (337:53): [True: 5.96k, False: 6.72k]
  ------------------
  338|  12.6k|                                          keydata->data(),
  339|  12.6k|                                          initiating ? 0 : 1,
  ------------------
  |  Branch (339:43): [True: 5.96k, False: 6.72k]
  ------------------
  340|  12.6k|                                          secp256k1_ellswift_xdh_hash_function_bip324,
  341|  12.6k|                                          nullptr);
  342|       |    // Should always succeed for valid keys (assert above).
  343|  12.6k|    assert(success);
  ------------------
  |  Branch (343:5): [True: 12.6k, False: 0]
  ------------------
  344|  12.6k|    return output;
  345|  12.6k|}
_ZNK4CKey14ComputeKeyPairEPK7uint256:
  348|  3.36k|{
  349|  3.36k|    return KeyPair(*this, merkle_root);
  350|  3.36k|}
_ZNK7CExtKey6DeriveERS_j:
  359|  23.5k|bool CExtKey::Derive(CExtKey &out, unsigned int _nChild) const {
  360|  23.5k|    if (nDepth == std::numeric_limits<unsigned char>::max()) return false;
  ------------------
  |  Branch (360:9): [True: 0, False: 23.5k]
  ------------------
  361|  23.5k|    out.nDepth = nDepth + 1;
  362|  23.5k|    CKeyID id = key.GetPubKey().GetID();
  363|  23.5k|    memcpy(out.vchFingerprint, &id, 4);
  364|  23.5k|    out.nChild = _nChild;
  365|  23.5k|    return key.Derive(out.key, out.chaincode, _nChild, chaincode);
  366|  23.5k|}
_ZN7CExtKey7SetSeedENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  369|  3.36k|{
  370|  3.36k|    static const unsigned char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};
  371|  3.36k|    std::vector<unsigned char, secure_allocator<unsigned char>> vout(64);
  372|  3.36k|    CHMAC_SHA512{hashkey, sizeof(hashkey)}.Write(UCharCast(seed.data()), seed.size()).Finalize(vout.data());
  373|  3.36k|    key.Set(vout.data(), vout.data() + 32, true);
  374|  3.36k|    memcpy(chaincode.begin(), vout.data() + 32, 32);
  375|  3.36k|    nDepth = 0;
  376|  3.36k|    nChild = 0;
  377|  3.36k|    memset(vchFingerprint, 0, sizeof(vchFingerprint));
  378|  3.36k|}
_ZN7KeyPairC2ERK4CKeyPK7uint256:
  410|  3.36k|{
  411|  3.36k|    static_assert(std::tuple_size<KeyType>() == sizeof(secp256k1_keypair));
  412|  3.36k|    MakeKeyPairData();
  413|  3.36k|    auto keypair = reinterpret_cast<secp256k1_keypair*>(m_keypair->data());
  414|  3.36k|    bool success = secp256k1_keypair_create(secp256k1_context_sign, keypair, UCharCast(key.data()));
  415|  3.36k|    if (success && merkle_root) {
  ------------------
  |  Branch (415:9): [True: 3.36k, False: 0]
  |  Branch (415:20): [True: 0, False: 3.36k]
  ------------------
  416|      0|        secp256k1_xonly_pubkey pubkey;
  417|      0|        unsigned char pubkey_bytes[32];
  418|      0|        assert(secp256k1_keypair_xonly_pub(secp256k1_context_sign, &pubkey, nullptr, keypair));
  ------------------
  |  Branch (418:9): [True: 0, False: 0]
  ------------------
  419|      0|        assert(secp256k1_xonly_pubkey_serialize(secp256k1_context_sign, pubkey_bytes, &pubkey));
  ------------------
  |  Branch (419:9): [True: 0, False: 0]
  ------------------
  420|      0|        uint256 tweak = XOnlyPubKey(pubkey_bytes).ComputeTapTweakHash(merkle_root->IsNull() ? nullptr : merkle_root);
  ------------------
  |  Branch (420:71): [True: 0, False: 0]
  ------------------
  421|      0|        success = secp256k1_keypair_xonly_tweak_add(secp256k1_context_static, keypair, tweak.data());
  422|      0|    }
  423|  3.36k|    if (!success) ClearKeyPairData();
  ------------------
  |  Branch (423:9): [True: 0, False: 3.36k]
  ------------------
  424|  3.36k|}
_ZNK7KeyPair11SignSchnorrERK7uint256NSt3__14spanIhLm18446744073709551615EEES2_:
  427|  3.36k|{
  428|  3.36k|    assert(sig.size() == 64);
  ------------------
  |  Branch (428:5): [True: 3.36k, False: 0]
  ------------------
  429|  3.36k|    if (!IsValid()) return false;
  ------------------
  |  Branch (429:9): [True: 0, False: 3.36k]
  ------------------
  430|  3.36k|    auto keypair = reinterpret_cast<const secp256k1_keypair*>(m_keypair->data());
  431|  3.36k|    bool ret = secp256k1_schnorrsig_sign32(secp256k1_context_sign, sig.data(), hash.data(), keypair, aux.data());
  432|  3.36k|    if (ret) {
  ------------------
  |  Branch (432:9): [True: 3.36k, False: 0]
  ------------------
  433|       |        // Additional verification step to prevent using a potentially corrupted signature
  434|  3.36k|        secp256k1_xonly_pubkey pubkey_verify;
  435|  3.36k|        ret = secp256k1_keypair_xonly_pub(secp256k1_context_static, &pubkey_verify, nullptr, keypair);
  436|  3.36k|        ret &= secp256k1_schnorrsig_verify(secp256k1_context_static, sig.data(), hash.begin(), 32, &pubkey_verify);
  437|  3.36k|    }
  438|  3.36k|    if (!ret) memory_cleanse(sig.data(), sig.size());
  ------------------
  |  Branch (438:9): [True: 0, False: 3.36k]
  ------------------
  439|  3.36k|    return ret;
  440|  3.36k|}
_ZN11ECC_ContextD2Ev:
  482|      2|{
  483|      2|    ECC_Stop();
  484|      2|}
key.cpp:_ZL8ECC_Stopv:
  467|      2|static void ECC_Stop() {
  468|      2|    secp256k1_context *ctx = secp256k1_context_sign;
  469|      2|    secp256k1_context_sign = nullptr;
  470|       |
  471|      2|    if (ctx) {
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        secp256k1_context_destroy(ctx);
  473|      2|    }
  474|      2|}

_ZN7CExtKeyC2Ev:
  269|  6.72k|    CExtKey() = default;
_ZN4CKey11MakeKeyDataEv:
   64|  63.8k|    {
   65|  63.8k|        if (!keydata) keydata = make_secure_unique<KeyType>();
  ------------------
  |  Branch (65:13): [True: 43.6k, False: 20.1k]
  ------------------
   66|  63.8k|    }
_ZNK4CKey7IsValidEv:
  123|  30.2k|    bool IsValid() const { return !!keydata; }
_ZN4CKeyaSERKS_:
   79|  36.9k|    {
   80|  36.9k|        if (this != &other) {
  ------------------
  |  Branch (80:13): [True: 36.9k, False: 0]
  ------------------
   81|  36.9k|            if (other.keydata) {
  ------------------
  |  Branch (81:17): [True: 36.9k, False: 0]
  ------------------
   82|  36.9k|                MakeKeyData();
   83|  36.9k|                *keydata = *other.keydata;
   84|  36.9k|            } else {
   85|      0|                ClearKeyData();
   86|      0|            }
   87|  36.9k|            fCompressed = other.fCompressed;
   88|  36.9k|        }
   89|  36.9k|        return *this;
   90|  36.9k|    }
_ZN4CKeyC2ERKS_:
   92|  30.2k|    CKey(const CKey& other) { *this = other; }
_ZNK4CKey4dataEv:
  118|   132k|    const std::byte* data() const { return keydata ? reinterpret_cast<const std::byte*>(keydata->data()) : nullptr; }
  ------------------
  |  Branch (118:44): [True: 132k, False: 0]
  ------------------
_ZNK4CKey5beginEv:
  119|   129k|    const std::byte* begin() const { return data(); }
_ZNK4CKey12IsCompressedEv:
  126|  23.5k|    bool IsCompressed() const { return fCompressed; }
_ZNK7KeyPair7IsValidEv:
  318|  3.36k|    bool IsValid() const { return !!m_keypair; }
_ZN7KeyPair15MakeKeyPairDataEv:
  327|  3.36k|    {
  328|  3.36k|        if (!m_keypair) m_keypair = make_secure_unique<KeyType>();
  ------------------
  |  Branch (328:13): [True: 3.36k, False: 0]
  ------------------
  329|  3.36k|    }
_ZN4CKeyC2Ev:
   74|  13.4k|    CKey() noexcept = default;
_ZN4CKey3SetIPKSt4byteEEvT_S4_b:
  104|  23.5k|    {
  105|  23.5k|        if (size_t(pend - pbegin) != std::tuple_size_v<KeyType>) {
  ------------------
  |  Branch (105:13): [True: 0, False: 23.5k]
  ------------------
  106|      0|            ClearKeyData();
  107|  23.5k|        } else if (Check(UCharCast(&pbegin[0]))) {
  ------------------
  |  Branch (107:20): [True: 23.5k, False: 0]
  ------------------
  108|  23.5k|            MakeKeyData();
  109|  23.5k|            memcpy(keydata->data(), (unsigned char*)&pbegin[0], keydata->size());
  110|  23.5k|            fCompressed = fCompressedIn;
  111|  23.5k|        } else {
  112|      0|            ClearKeyData();
  113|      0|        }
  114|  23.5k|    }
_ZN4CKey3SetIPhEEvT_S2_b:
  104|  3.36k|    {
  105|  3.36k|        if (size_t(pend - pbegin) != std::tuple_size_v<KeyType>) {
  ------------------
  |  Branch (105:13): [True: 0, False: 3.36k]
  ------------------
  106|      0|            ClearKeyData();
  107|  3.36k|        } else if (Check(UCharCast(&pbegin[0]))) {
  ------------------
  |  Branch (107:20): [True: 3.36k, False: 0]
  ------------------
  108|  3.36k|            MakeKeyData();
  109|  3.36k|            memcpy(keydata->data(), (unsigned char*)&pbegin[0], keydata->size());
  110|  3.36k|            fCompressed = fCompressedIn;
  111|  3.36k|        } else {
  112|      0|            ClearKeyData();
  113|      0|        }
  114|  3.36k|    }

_Z11LogInstancev:
   27|   131k|{
   28|       |/**
   29|       | * NOTE: the logger instances is leaked on exit. This is ugly, but will be
   30|       | * cleaned up by the OS/libc. Defining a logger as a global object doesn't work
   31|       | * since the order of destruction of static/global objects is undefined.
   32|       | * Consider if the logger gets destroyed, and then some later destructor calls
   33|       | * LogPrintf, maybe indirectly, and you get a core dump at shutdown trying to
   34|       | * access the logger. When the shutdown sequence is fully audited and tested,
   35|       | * explicit destruction of these objects can be implemented by changing this
   36|       | * from a raw pointer to a std::unique_ptr.
   37|       | * Since the ~Logger() destructor is never called, the Logger class and all
   38|       | * its subclasses must have implicitly-defined destructors.
   39|       | *
   40|       | * This method of initialization was originally introduced in
   41|       | * ee3374234c60aba2cc4c5cd5cac1c0aefc2d817c.
   42|       | */
   43|   131k|    static BCLog::Logger* g_logger{new BCLog::Logger()};
   44|   131k|    return *g_logger;
   45|   131k|}
_ZNK5BCLog6Logger15WillLogCategoryENS_8LogFlagsE:
  150|   121k|{
  151|   121k|    return (m_categories.load(std::memory_order_relaxed) & category) != 0;
  152|   121k|}
_ZNK5BCLog6Logger20WillLogCategoryLevelENS_8LogFlagsENS_5LevelE:
  155|   121k|{
  156|       |    // Log messages at Info, Warning and Error level unconditionally, so that
  157|       |    // important troubleshooting information doesn't get lost.
  158|   121k|    if (level >= BCLog::Level::Info) return true;
  ------------------
  |  Branch (158:9): [True: 0, False: 121k]
  ------------------
  159|       |
  160|   121k|    if (!WillLogCategory(category)) return false;
  ------------------
  |  Branch (160:9): [True: 121k, False: 0]
  ------------------
  161|       |
  162|      0|    StdLockGuard scoped_lock(m_cs);
  163|      0|    const auto it{m_category_log_levels.find(category)};
  164|      0|    return level >= (it == m_category_log_levels.end() ? LogLevel() : it->second);
  ------------------
  |  Branch (164:22): [True: 0, False: 0]
  ------------------
  165|   121k|}
_ZN5BCLog16LogEscapeMessageENSt3__117basic_string_viewIcNS0_11char_traitsIcEEEE:
  304|  4.84k|    std::string LogEscapeMessage(std::string_view str) {
  305|  4.84k|        std::string ret;
  306|   661k|        for (char ch_in : str) {
  ------------------
  |  Branch (306:25): [True: 661k, False: 4.84k]
  ------------------
  307|   661k|            uint8_t ch = (uint8_t)ch_in;
  308|   661k|            if ((ch >= 32 || ch == '\n') && ch != '\x7f') {
  ------------------
  |  Branch (308:18): [True: 656k, False: 4.84k]
  |  Branch (308:30): [True: 4.84k, False: 0]
  |  Branch (308:45): [True: 661k, False: 0]
  ------------------
  309|   661k|                ret += ch_in;
  310|   661k|            } else {
  311|      0|                ret += strprintf("\\x%02x", ch);
  ------------------
  |  | 1172|      0|#define strprintf tfm::format
  ------------------
  312|      0|            }
  313|   661k|        }
  314|  4.84k|        return ret;
  315|  4.84k|    }
_ZN5BCLog6Logger11LogPrintStrENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEEONS1_15source_locationENS_8LogFlagsENS_5LevelE:
  369|  4.84k|{
  370|  4.84k|    StdLockGuard scoped_lock(m_cs);
  371|  4.84k|    return LogPrintStr_(str, std::move(source_loc), category, level);
  372|  4.84k|}
_ZN5BCLog6Logger12LogPrintStr_ENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEEONS1_15source_locationENS_8LogFlagsENS_5LevelE:
  376|  4.84k|{
  377|  4.84k|    std::string str_prefixed = LogEscapeMessage(str);
  378|       |
  379|  4.84k|    if (m_buffering) {
  ------------------
  |  Branch (379:9): [True: 4.84k, False: 0]
  ------------------
  380|  4.84k|        {
  381|  4.84k|            BufferedLog buf{
  382|  4.84k|                .now = SystemClock::now(),
  383|  4.84k|                .mocktime = GetMockTime(),
  384|  4.84k|                .str = str_prefixed,
  385|  4.84k|                .threadname = util::ThreadGetInternalName(),
  386|  4.84k|                .source_loc = std::move(source_loc),
  387|  4.84k|                .category = category,
  388|  4.84k|                .level = level,
  389|  4.84k|            };
  390|  4.84k|            m_cur_buffer_memusage += MemUsage(buf);
  391|  4.84k|            m_msgs_before_open.push_back(std::move(buf));
  392|  4.84k|        }
  393|       |
  394|  6.15k|        while (m_cur_buffer_memusage > m_max_buffer_memusage) {
  ------------------
  |  Branch (394:16): [True: 1.31k, False: 4.84k]
  ------------------
  395|  1.31k|            if (m_msgs_before_open.empty()) {
  ------------------
  |  Branch (395:17): [True: 0, False: 1.31k]
  ------------------
  396|      0|                m_cur_buffer_memusage = 0;
  397|      0|                break;
  398|      0|            }
  399|  1.31k|            m_cur_buffer_memusage -= MemUsage(m_msgs_before_open.front());
  400|  1.31k|            m_msgs_before_open.pop_front();
  401|  1.31k|            ++m_buffer_lines_discarded;
  402|  1.31k|        }
  403|       |
  404|  4.84k|        return;
  405|  4.84k|    }
  406|       |
  407|      0|    FormatLogStrInPlace(str_prefixed, category, level, source_loc, util::ThreadGetInternalName(), SystemClock::now(), GetMockTime());
  408|      0|    if (m_print_to_console) {
  ------------------
  |  Branch (408:9): [True: 0, False: 0]
  ------------------
  409|       |        // print to console
  410|      0|        fwrite(str_prefixed.data(), 1, str_prefixed.size(), stdout);
  411|      0|        fflush(stdout);
  412|      0|    }
  413|      0|    for (const auto& cb : m_print_callbacks) {
  ------------------
  |  Branch (413:25): [True: 0, False: 0]
  ------------------
  414|      0|        cb(str_prefixed);
  415|      0|    }
  416|      0|    if (m_print_to_file) {
  ------------------
  |  Branch (416:9): [True: 0, False: 0]
  ------------------
  417|      0|        assert(m_fileout != nullptr);
  ------------------
  |  Branch (417:9): [True: 0, False: 0]
  ------------------
  418|       |
  419|       |        // reopen the log file, if requested
  420|      0|        if (m_reopen_file) {
  ------------------
  |  Branch (420:13): [True: 0, False: 0]
  ------------------
  421|      0|            m_reopen_file = false;
  422|      0|            FILE* new_fileout = fsbridge::fopen(m_file_path, "a");
  423|      0|            if (new_fileout) {
  ------------------
  |  Branch (423:17): [True: 0, False: 0]
  ------------------
  424|      0|                setbuf(new_fileout, nullptr); // unbuffered
  425|      0|                fclose(m_fileout);
  426|      0|                m_fileout = new_fileout;
  427|      0|            }
  428|      0|        }
  429|      0|        FileWriteStr(str_prefixed, m_fileout);
  430|      0|    }
  431|      0|}
logging.cpp:_ZL8MemUsageRKN5BCLog6Logger11BufferedLogE:
  345|  6.15k|{
  346|  6.15k|    return memusage::DynamicUsage(buflog.str) +
  347|  6.15k|           memusage::DynamicUsage(buflog.threadname) +
  348|  6.15k|           memusage::MallocUsage(sizeof(memusage::list_node<BCLog::Logger::BufferedLog>));
  349|  6.15k|}

sv2_noise.cpp:_ZL17LogAcceptCategoryN5BCLog8LogFlagsENS_5LevelE:
  214|  5.02k|{
  215|  5.02k|    return LogInstance().WillLogCategoryLevel(category, level);
  216|  5.02k|}
_ZNK5BCLog6Logger7EnabledEv:
  130|  4.84k|        {
  131|  4.84k|            StdLockGuard scoped_lock(m_cs);
  132|  4.84k|            return m_buffering || m_print_to_console || m_print_to_file || !m_print_callbacks.empty();
  ------------------
  |  Branch (132:20): [True: 4.84k, False: 0]
  |  Branch (132:35): [True: 0, False: 0]
  |  Branch (132:57): [True: 0, False: 0]
  |  Branch (132:76): [True: 0, False: 0]
  ------------------
  133|  4.84k|        }
_Z22LogPrintFormatInternalIJNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEEEvONS0_15source_locationEN5BCLog8LogFlagsENS9_5LevelEN4util21ConstevalFormatStringIXsZT_EEEDpRKT_:
  223|  1.48k|{
  224|  1.48k|    if (LogInstance().Enabled()) {
  ------------------
  |  Branch (224:9): [True: 1.48k, False: 0]
  ------------------
  225|  1.48k|        std::string log_msg;
  226|  1.48k|        try {
  227|  1.48k|            log_msg = tfm::format(fmt, args...);
  228|  1.48k|        } catch (tinyformat::format_error& fmterr) {
  229|      0|            log_msg = "Error \"" + std::string{fmterr.what()} + "\" while formatting log message: " + fmt.fmt;
  230|      0|        }
  231|  1.48k|        LogInstance().LogPrintStr(log_msg, std::move(source_loc), flag, level);
  232|  1.48k|    }
  233|  1.48k|}
noise.cpp:_ZL17LogAcceptCategoryN5BCLog8LogFlagsENS_5LevelE:
  214|   116k|{
  215|   116k|    return LogInstance().WillLogCategoryLevel(category, level);
  216|   116k|}
_Z22LogPrintFormatInternalIJPKcNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEEvONS2_15source_locationEN5BCLog8LogFlagsENSB_5LevelEN4util21ConstevalFormatStringIXsZT_EEEDpRKT_:
  223|  3.36k|{
  224|  3.36k|    if (LogInstance().Enabled()) {
  ------------------
  |  Branch (224:9): [True: 3.36k, False: 0]
  ------------------
  225|  3.36k|        std::string log_msg;
  226|  3.36k|        try {
  227|  3.36k|            log_msg = tfm::format(fmt, args...);
  228|  3.36k|        } catch (tinyformat::format_error& fmterr) {
  229|      0|            log_msg = "Error \"" + std::string{fmterr.what()} + "\" while formatting log message: " + fmt.fmt;
  230|      0|        }
  231|  3.36k|        LogInstance().LogPrintStr(log_msg, std::move(source_loc), flag, level);
  232|  3.36k|    }
  233|  3.36k|}

logging.cpp:_ZN8memusageL12DynamicUsageERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE:
   95|  12.3k|{
   96|  12.3k|    const char* s_ptr = reinterpret_cast<const char*>(&s);
   97|       |    // Don't count the dynamic memory used for string, if it resides in the
   98|       |    // "small string" optimization area (which stores data inside the object itself, up to some
   99|       |    // size; 15 bytes in modern libstdc++).
  100|  12.3k|    if (!std::less{}(s.data(), s_ptr) && !std::greater{}(s.data() + s.size(), s_ptr + sizeof(s))) {
  ------------------
  |  Branch (100:9): [True: 7.46k, False: 4.84k]
  |  Branch (100:9): [True: 6.15k, False: 6.15k]
  |  Branch (100:42): [True: 6.15k, False: 1.31k]
  ------------------
  101|  6.15k|        return 0;
  102|  6.15k|    }
  103|  6.15k|    return MallocUsage(s.capacity());
  104|  12.3k|}
logging.cpp:_ZN8memusageL11MallocUsageEm:
   53|  12.3k|{
   54|       |    // Measured on libc6 2.19 on Linux.
   55|  12.3k|    if (alloc == 0) {
  ------------------
  |  Branch (55:9): [True: 0, False: 12.3k]
  ------------------
   56|      0|        return 0;
   57|  12.3k|    } else if (sizeof(void*) == 8) {
  ------------------
  |  Branch (57:16): [True: 12.3k, Folded]
  ------------------
   58|  12.3k|        return ((alloc + 31) >> 4) << 4;
   59|  12.3k|    } else if (sizeof(void*) == 4) {
  ------------------
  |  Branch (59:16): [Folded, False: 0]
  ------------------
   60|      0|        return ((alloc + 15) >> 3) << 3;
   61|      0|    } else {
   62|       |        assert(0);
  ------------------
  |  Branch (62:9): [Folded, False: 0]
  ------------------
   63|      0|    }
   64|  12.3k|}

_ZNK11XOnlyPubKey13VerifySchnorrERK7uint256NSt3__14spanIKhLm18446744073709551615EEE:
  237|  4.34k|{
  238|  4.34k|    assert(sigbytes.size() == 64);
  ------------------
  |  Branch (238:5): [True: 4.34k, False: 0]
  ------------------
  239|  4.34k|    secp256k1_xonly_pubkey pubkey;
  240|  4.34k|    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_static, &pubkey, m_keydata.data())) return false;
  ------------------
  |  Branch (240:9): [True: 0, False: 4.34k]
  ------------------
  241|  4.34k|    return secp256k1_schnorrsig_verify(secp256k1_context_static, sigbytes.data(), msg.begin(), 32, &pubkey);
  242|  4.34k|}
_ZN14EllSwiftPubKeyC2ENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  363|  22.7k|{
  364|  22.7k|    assert(ellswift.size() == SIZE);
  ------------------
  |  Branch (364:5): [True: 22.7k, False: 0]
  ------------------
  365|  22.7k|    std::copy(ellswift.begin(), ellswift.end(), m_pubkey.begin());
  366|  22.7k|}
_ZNK14EllSwiftPubKey6DecodeEv:
  369|  2.56k|{
  370|  2.56k|    secp256k1_pubkey pubkey;
  371|  2.56k|    secp256k1_ellswift_decode(secp256k1_context_static, &pubkey, UCharCast(m_pubkey.data()));
  372|       |
  373|  2.56k|    size_t sz = CPubKey::COMPRESSED_SIZE;
  374|  2.56k|    std::array<uint8_t, CPubKey::COMPRESSED_SIZE> vch_bytes;
  375|       |
  376|  2.56k|    secp256k1_ec_pubkey_serialize(secp256k1_context_static, vch_bytes.data(), &sz, &pubkey, SECP256K1_EC_COMPRESSED);
  ------------------
  |  |  224|  2.56k|#define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)
  |  |  ------------------
  |  |  |  |  205|  2.56k|#define SECP256K1_FLAGS_TYPE_COMPRESSION (1 << 1)
  |  |  ------------------
  |  |               #define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)
  |  |  ------------------
  |  |  |  |  210|  2.56k|#define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)
  |  |  ------------------
  ------------------
  377|  2.56k|    assert(sz == vch_bytes.size());
  ------------------
  |  Branch (377:5): [True: 2.56k, False: 0]
  ------------------
  378|       |
  379|  2.56k|    return CPubKey{vch_bytes.begin(), vch_bytes.end()};
  380|  2.56k|}

_ZN7CPubKey6GetLenEh:
   61|   182k|    {
   62|   182k|        if (chHeader == 2 || chHeader == 3)
  ------------------
  |  Branch (62:13): [True: 88.4k, False: 93.6k]
  |  Branch (62:30): [True: 93.6k, False: 0]
  ------------------
   63|   182k|            return COMPRESSED_SIZE;
   64|      0|        if (chHeader == 4 || chHeader == 6 || chHeader == 7)
  ------------------
  |  Branch (64:13): [True: 0, False: 0]
  |  Branch (64:30): [True: 0, False: 0]
  |  Branch (64:47): [True: 0, False: 0]
  ------------------
   65|      0|            return SIZE;
   66|      0|        return 0;
   67|      0|    }
_ZNK7CPubKey4sizeEv:
  112|   179k|    unsigned int size() const { return GetLen(vch[0]); }
_ZNK14EllSwiftPubKey5beginEv:
  332|  6.72k|    auto begin() const { return m_pubkey.cbegin(); }
_ZNK14EllSwiftPubKey3endEv:
  333|  6.72k|    auto end() const { return m_pubkey.cend(); }
_ZN14EllSwiftPubKey4sizeEv:
  331|  6.72k|    static constexpr size_t size() { return SIZE; }
_ZN11XOnlyPubKeyC2ERK7CPubKey:
  260|  14.5k|    explicit XOnlyPubKey(const CPubKey& pubkey) : XOnlyPubKey(std::span{pubkey}.subspan(1, 32)) {}
_ZNK7CPubKey4dataEv:
  113|  14.5k|    const unsigned char* data() const { return vch; }
_ZN11XOnlyPubKey16SerializationOpsI10DataStreamKS_15ActionSerializeEEvRT0_RT_T1_:
  309|  7.70k|    SERIALIZE_METHODS(XOnlyPubKey, obj) { READWRITE(obj.m_keydata); }
  ------------------
  |  |  145|  7.70k|#define READWRITE(...) (ser_action.SerReadWriteMany(s, __VA_ARGS__))
  ------------------
_ZN6CKeyIDC2ERK7uint160:
   27|  23.5k|    explicit CKeyID(const uint160& in) : uint160(in) {}
_ZN7CPubKey10InvalidateEv:
   71|  59.0k|    {
   72|  59.0k|        vch[0] = 0xFF;
   73|  59.0k|    }
_ZN7CPubKeyC2Ev:
   83|  59.0k|    {
   84|  59.0k|        Invalidate();
   85|  59.0k|    }
_ZNK7CPubKey5beginEv:
  114|   106k|    const unsigned char* begin() const { return vch; }
_ZNK7CPubKey5GetIDEv:
  165|  23.5k|    {
  166|  23.5k|        return CKeyID(Hash160(std::span{vch}.first(size())));
  167|  23.5k|    }
_ZNK7CPubKey7IsValidEv:
  190|  59.0k|    {
  191|  59.0k|        return size() > 0;
  192|  59.0k|    }
_ZNK14EllSwiftPubKey4dataEv:
  330|  32.0k|    const std::byte* data() const { return m_pubkey.data(); }
_ZN11XOnlyPubKeyC2ENSt3__14spanIKhLm18446744073709551615EEE:
  257|  14.5k|    constexpr explicit XOnlyPubKey(std::span<const unsigned char> bytes) : m_keydata{bytes} {}
_ZN11XOnlyPubKeyC2Ev:
  242|  5.92k|    XOnlyPubKey() = default;
_ZN7CPubKey3SetIPhEEvT_S2_:
   90|  2.56k|    {
   91|  2.56k|        int len = pend == pbegin ? 0 : GetLen(pbegin[0]);
  ------------------
  |  Branch (91:19): [True: 0, False: 2.56k]
  ------------------
   92|  2.56k|        if (len && len == (pend - pbegin))
  ------------------
  |  Branch (92:13): [True: 2.56k, False: 0]
  |  Branch (92:20): [True: 2.56k, False: 0]
  ------------------
   93|  2.56k|            memcpy(vch, (unsigned char*)&pbegin[0], len);
   94|      0|        else
   95|      0|            Invalidate();
   96|  2.56k|    }
_ZN7CPubKeyC2IPhEET_S2_:
  101|  2.56k|    {
  102|  2.56k|        Set(pbegin, pend);
  103|  2.56k|    }

_Z30MakeRandDeterministicDANGEROUSRK7uint256:
  596|  3.36k|{
  597|  3.36k|    GetRNGState().MakeDeterministic(seed);
  598|  3.36k|}
_Z12GetRandBytesNSt3__14spanIhLm18446744073709551615EEE:
  602|  13.4k|{
  603|  13.4k|    g_used_g_prng = true;
  604|  13.4k|    ProcRand(bytes.data(), bytes.size(), RNGLevel::FAST, /*always_use_real_rng=*/false);
  605|  13.4k|}
random.cpp:_ZN12_GLOBAL__N_111GetRNGStateEv:
  451|  16.8k|{
  452|       |    // This idiom relies on the guarantee that static variable are initialized
  453|       |    // on first call, even when multiple parallel calls are permitted.
  454|  16.8k|    static std::vector<RNGState, secure_allocator<RNGState>> g_rng(1);
  455|  16.8k|    return g_rng[0];
  456|  16.8k|}
random.cpp:_ZN12_GLOBAL__N_18RNGStateD2Ev:
  367|      2|    ~RNGState() = default;
random.cpp:_ZN12_GLOBAL__N_18RNGState17MakeDeterministicERK7uint256:
  400|  3.36k|    {
  401|  3.36k|        LOCK(m_mutex);
  ------------------
  |  |  259|  3.36k|#define LOCK(cs) UniqueLock UNIQUE_NAME(criticalblock)(MaybeCheckNotHeld(cs), #cs, __FILE__, __LINE__)
  |  |  ------------------
  |  |  |  |   11|  3.36k|#define UNIQUE_NAME(name) PASTE2(name, __COUNTER__)
  |  |  |  |  ------------------
  |  |  |  |  |  |    9|  3.36k|#define PASTE2(x, y) PASTE(x, y)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |    8|  3.36k|#define PASTE(x, y) x ## y
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  402|  3.36k|        m_deterministic_prng.emplace(MakeByteSpan(seed));
  403|  3.36k|    }
random.cpp:_ZN12_GLOBAL__N_18ProcRandEPhiNS_8RNGLevelEb:
  563|  13.4k|{
  564|       |    // Make sure the RNG is initialized first (as all Seed* function possibly need hwrand to be available).
  565|  13.4k|    RNGState& rng = GetRNGState();
  566|       |
  567|  13.4k|    assert(num <= 32);
  ------------------
  |  Branch (567:5): [True: 13.4k, False: 0]
  ------------------
  568|       |
  569|  13.4k|    CSHA512 hasher;
  570|  13.4k|    switch (level) {
  ------------------
  |  Branch (570:13): [True: 13.4k, False: 0]
  ------------------
  571|  13.4k|    case RNGLevel::FAST:
  ------------------
  |  Branch (571:5): [True: 13.4k, False: 0]
  ------------------
  572|  13.4k|        SeedFast(hasher);
  573|  13.4k|        break;
  574|      0|    case RNGLevel::SLOW:
  ------------------
  |  Branch (574:5): [True: 0, False: 13.4k]
  ------------------
  575|      0|        SeedSlow(hasher, rng);
  576|      0|        break;
  577|      0|    case RNGLevel::PERIODIC:
  ------------------
  |  Branch (577:5): [True: 0, False: 13.4k]
  ------------------
  578|      0|        SeedPeriodic(hasher, rng);
  579|      0|        break;
  580|  13.4k|    }
  581|       |
  582|       |    // Combine with and update state
  583|  13.4k|    if (!rng.MixExtract(out, num, std::move(hasher), false, always_use_real_rng)) {
  ------------------
  |  Branch (583:9): [True: 0, False: 13.4k]
  ------------------
  584|       |        // On the first invocation, also seed with SeedStartup().
  585|      0|        CSHA512 startup_hasher;
  586|      0|        SeedStartup(startup_hasher, rng);
  587|      0|        rng.MixExtract(out, num, std::move(startup_hasher), true, always_use_real_rng);
  588|      0|    }
  589|  13.4k|}
random.cpp:_ZN12_GLOBAL__N_18SeedFastER7CSHA512:
  470|  13.4k|{
  471|  13.4k|    unsigned char buffer[32];
  472|       |
  473|       |    // Stack pointer to indirectly commit to thread/callstack
  474|  13.4k|    const unsigned char* ptr = buffer;
  475|  13.4k|    hasher.Write((const unsigned char*)&ptr, sizeof(ptr));
  476|       |
  477|       |    // Hardware randomness is very fast when available; use it always.
  478|  13.4k|    SeedHardwareFast(hasher);
  479|       |
  480|       |    // High-precision timestamp
  481|  13.4k|    SeedTimestamp(hasher);
  482|  13.4k|}
random.cpp:_ZN12_GLOBAL__N_116SeedHardwareFastER7CSHA512:
  199|  13.4k|void SeedHardwareFast(CSHA512& hasher) noexcept {
  200|  13.4k|#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)
  201|  13.4k|    if (g_rdrand_supported) {
  ------------------
  |  Branch (201:9): [True: 13.4k, False: 0]
  ------------------
  202|  13.4k|        uint64_t out = GetRdRand();
  203|  13.4k|        hasher.Write((const unsigned char*)&out, sizeof(out));
  204|  13.4k|        return;
  205|  13.4k|    }
  206|  13.4k|#endif
  207|  13.4k|}
random.cpp:_ZN12_GLOBAL__N_19GetRdRandEv:
  122|  13.4k|{
  123|       |    // RdRand may very rarely fail. Invoke it up to 10 times in a loop to reduce this risk.
  124|       |#ifdef __i386__
  125|       |    uint8_t ok = 0;
  126|       |    // Initialize to 0 to silence a compiler warning that r1 or r2 may be used
  127|       |    // uninitialized. Even if rdrand fails (!ok) it will set the output to 0,
  128|       |    // but there is no way that the compiler could know that.
  129|       |    uint32_t r1 = 0, r2 = 0;
  130|       |    for (int i = 0; i < 10; ++i) {
  131|       |        __asm__ volatile (".byte 0x0f, 0xc7, 0xf0; setc %1" : "=a"(r1), "=q"(ok) :: "cc"); // rdrand %eax
  132|       |        if (ok) break;
  133|       |    }
  134|       |    for (int i = 0; i < 10; ++i) {
  135|       |        __asm__ volatile (".byte 0x0f, 0xc7, 0xf0; setc %1" : "=a"(r2), "=q"(ok) :: "cc"); // rdrand %eax
  136|       |        if (ok) break;
  137|       |    }
  138|       |    return (((uint64_t)r2) << 32) | r1;
  139|       |#elif defined(__x86_64__) || defined(__amd64__)
  140|       |    uint8_t ok = 0;
  141|  13.4k|    uint64_t r1 = 0; // See above why we initialize to 0.
  142|  13.4k|    for (int i = 0; i < 10; ++i) {
  ------------------
  |  Branch (142:21): [True: 13.4k, False: 0]
  ------------------
  143|  13.4k|        __asm__ volatile (".byte 0x48, 0x0f, 0xc7, 0xf0; setc %1" : "=a"(r1), "=q"(ok) :: "cc"); // rdrand %rax
  144|  13.4k|        if (ok) break;
  ------------------
  |  Branch (144:13): [True: 13.4k, False: 0]
  ------------------
  145|  13.4k|    }
  146|  13.4k|    return r1;
  147|       |#else
  148|       |#error "RdRand is only supported on x86 and x86_64"
  149|       |#endif
  150|  13.4k|}
random.cpp:_ZN12_GLOBAL__N_113SeedTimestampER7CSHA512:
  464|  13.4k|{
  465|  13.4k|    int64_t perfcounter = GetPerformanceCounter();
  466|  13.4k|    hasher.Write((const unsigned char*)&perfcounter, sizeof(perfcounter));
  467|  13.4k|}
random.cpp:_ZN12_GLOBAL__N_121GetPerformanceCounterEv:
   61|  13.4k|{
   62|       |    // Read the hardware time stamp counter when available.
   63|       |    // See https://en.wikipedia.org/wiki/Time_Stamp_Counter for more information.
   64|       |#if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))
   65|       |    return __rdtsc();
   66|       |#elif !defined(_MSC_VER) && defined(__i386__)
   67|       |    uint64_t r = 0;
   68|       |    __asm__ volatile ("rdtsc" : "=A"(r)); // Constrain the r variable to the eax:edx pair.
   69|       |    return r;
   70|       |#elif !defined(_MSC_VER) && (defined(__x86_64__) || defined(__amd64__))
   71|       |    uint64_t r1 = 0, r2 = 0;
   72|  13.4k|    __asm__ volatile ("rdtsc" : "=a"(r1), "=d"(r2)); // Constrain r1 to rax and r2 to rdx.
   73|  13.4k|    return (r2 << 32) | r1;
   74|       |#else
   75|       |    // Fall back to using standard library clock (usually microsecond or nanosecond precision)
   76|       |    return std::chrono::high_resolution_clock::now().time_since_epoch().count();
   77|       |#endif
   78|  13.4k|}
random.cpp:_ZN12_GLOBAL__N_18RNGState10MixExtractEPhmO7CSHA512bb:
  413|  13.4k|    {
  414|  13.4k|        assert(num <= 32);
  ------------------
  |  Branch (414:9): [True: 13.4k, False: 0]
  ------------------
  415|  13.4k|        unsigned char buf[64];
  416|  13.4k|        static_assert(sizeof(buf) == CSHA512::OUTPUT_SIZE, "Buffer needs to have hasher's output size");
  417|  13.4k|        bool ret;
  418|  13.4k|        {
  419|  13.4k|            LOCK(m_mutex);
  ------------------
  |  |  259|  13.4k|#define LOCK(cs) UniqueLock UNIQUE_NAME(criticalblock)(MaybeCheckNotHeld(cs), #cs, __FILE__, __LINE__)
  |  |  ------------------
  |  |  |  |   11|  13.4k|#define UNIQUE_NAME(name) PASTE2(name, __COUNTER__)
  |  |  |  |  ------------------
  |  |  |  |  |  |    9|  13.4k|#define PASTE2(x, y) PASTE(x, y)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |    8|  13.4k|#define PASTE(x, y) x ## y
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  420|  13.4k|            ret = (m_strongly_seeded |= strong_seed);
  421|       |            // Write the current state of the RNG into the hasher
  422|  13.4k|            hasher.Write(m_state, 32);
  423|       |            // Write a new counter number into the state
  424|  13.4k|            hasher.Write((const unsigned char*)&m_counter, sizeof(m_counter));
  425|  13.4k|            ++m_counter;
  426|       |            // Finalize the hasher
  427|  13.4k|            hasher.Finalize(buf);
  428|       |            // Store the last 32 bytes of the hash output as new RNG state.
  429|  13.4k|            memcpy(m_state, buf + 32, 32);
  430|       |            // Handle requests for deterministic randomness.
  431|  13.4k|            if (!always_use_real_rng && m_deterministic_prng.has_value()) [[unlikely]] {
  ------------------
  |  Branch (431:17): [True: 13.4k, False: 0]
  |  Branch (431:41): [True: 13.4k, False: 0]
  ------------------
  432|       |                // Overwrite the beginning of buf, which will be used for output.
  433|  13.4k|                m_deterministic_prng->Keystream(std::as_writable_bytes(std::span{buf, num}));
  434|       |                // Do not require strong seeding for deterministic output.
  435|  13.4k|                ret = true;
  436|  13.4k|            }
  437|  13.4k|        }
  438|       |        // If desired, copy (up to) the first 32 bytes of the hash output as output.
  439|  13.4k|        if (num) {
  ------------------
  |  Branch (439:13): [True: 13.4k, False: 0]
  ------------------
  440|  13.4k|            assert(out != nullptr);
  ------------------
  |  Branch (440:13): [True: 13.4k, False: 0]
  ------------------
  441|  13.4k|            memcpy(out, buf, num);
  442|  13.4k|        }
  443|       |        // Best effort cleanup of internal state
  444|  13.4k|        hasher.Reset();
  445|  13.4k|        memory_cleanse(buf, 64);
  446|  13.4k|        return ret;
  447|  13.4k|    }

_ZN21InsecureRandomContextC2Em:
  439|  1.07k|        : m_s0(SplitMix64(seedval)), m_s1(SplitMix64(seedval)) {}
_ZN11RandomMixinI21InsecureRandomContextEC2Ev:
  195|  1.07k|    constexpr RandomMixin() noexcept = default;
_ZN21InsecureRandomContext10SplitMix64ERm:
  430|  2.15k|    {
  431|  2.15k|        uint64_t z = (seedval += 0x9e3779b97f4a7c15);
  432|  2.15k|        z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
  433|  2.15k|        z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
  434|  2.15k|        return z ^ (z >> 31);
  435|  2.15k|    }
_ZN11RandomMixinI21InsecureRandomContextEclEv:
  376|   643M|    inline uint64_t operator()() noexcept { return Impl().rand64(); }
_ZN11RandomMixinI21InsecureRandomContextE4ImplEv:
  185|   643M|    RandomNumberGenerator auto& Impl() noexcept { return static_cast<T&>(*this); }
_ZN21InsecureRandomContext6rand64Ev:
  449|   643M|    {
  450|   643M|        uint64_t s0 = m_s0, s1 = m_s1;
  451|   643M|        const uint64_t result = std::rotl(s0 + s1, 17) + s0;
  452|   643M|        s1 ^= s0;
  453|   643M|        m_s0 = std::rotl(s0, 49) ^ s1 ^ (s1 << 21);
  454|   643M|        m_s1 = std::rotl(s1, 28);
  455|   643M|        return result;
  456|   643M|    }
_Z11GetRandHashv:
  464|  13.4k|{
  465|  13.4k|    uint256 hash;
  466|  13.4k|    GetRandBytes(hash);
  467|  13.4k|    return hash;
  468|  13.4k|}

secp256k1.c:secp256k1_eckey_pubkey_serialize:
   38|  61.5k|static int secp256k1_eckey_pubkey_serialize(secp256k1_ge *elem, unsigned char *pub, size_t *size, int compressed) {
   39|  61.5k|    VERIFY_CHECK(compressed == 0 || compressed == 1);
   40|       |
   41|  61.5k|    if (secp256k1_ge_is_infinity(elem)) {
  ------------------
  |  Branch (41:9): [True: 0, False: 61.5k]
  ------------------
   42|      0|        return 0;
   43|      0|    }
   44|  61.5k|    secp256k1_fe_normalize_var(&elem->x);
  ------------------
  |  |   80|  61.5k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
   45|  61.5k|    secp256k1_fe_normalize_var(&elem->y);
  ------------------
  |  |   80|  61.5k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
   46|  61.5k|    secp256k1_fe_get_b32(&pub[1], &elem->x);
  ------------------
  |  |   89|  61.5k|#  define secp256k1_fe_get_b32 secp256k1_fe_impl_get_b32
  ------------------
   47|  61.5k|    if (compressed) {
  ------------------
  |  Branch (47:9): [True: 61.5k, False: 0]
  ------------------
   48|  61.5k|        *size = 33;
   49|  61.5k|        pub[0] = secp256k1_fe_is_odd(&elem->y) ? SECP256K1_TAG_PUBKEY_ODD : SECP256K1_TAG_PUBKEY_EVEN;
  ------------------
  |  |   85|  61.5k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
                      pub[0] = secp256k1_fe_is_odd(&elem->y) ? SECP256K1_TAG_PUBKEY_ODD : SECP256K1_TAG_PUBKEY_EVEN;
  ------------------
  |  |  229|  31.6k|#define SECP256K1_TAG_PUBKEY_ODD 0x03
  ------------------
                      pub[0] = secp256k1_fe_is_odd(&elem->y) ? SECP256K1_TAG_PUBKEY_ODD : SECP256K1_TAG_PUBKEY_EVEN;
  ------------------
  |  |  228|  91.5k|#define SECP256K1_TAG_PUBKEY_EVEN 0x02
  ------------------
  |  Branch (49:18): [True: 31.6k, False: 29.9k]
  ------------------
   50|  61.5k|    } else {
   51|      0|        *size = 65;
   52|      0|        pub[0] = SECP256K1_TAG_PUBKEY_UNCOMPRESSED;
  ------------------
  |  |  230|      0|#define SECP256K1_TAG_PUBKEY_UNCOMPRESSED 0x04
  ------------------
   53|      0|        secp256k1_fe_get_b32(&pub[33], &elem->y);
  ------------------
  |  |   89|      0|#  define secp256k1_fe_get_b32 secp256k1_fe_impl_get_b32
  ------------------
   54|      0|    }
   55|  61.5k|    return 1;
   56|  61.5k|}
secp256k1.c:secp256k1_eckey_privkey_tweak_add:
   58|  23.5k|static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp256k1_scalar *tweak) {
   59|  23.5k|    secp256k1_scalar_add(key, key, tweak);
   60|  23.5k|    return !secp256k1_scalar_is_zero(key);
   61|  23.5k|}

secp256k1.c:secp256k1_ecmult_const_xonly:
  270|  12.6k|static int secp256k1_ecmult_const_xonly(secp256k1_fe* r, const secp256k1_fe *n, const secp256k1_fe *d, const secp256k1_scalar *q, int known_on_curve) {
  271|       |
  272|       |    /* This algorithm is a generalization of Peter Dettman's technique for
  273|       |     * avoiding the square root in a random-basepoint x-only multiplication
  274|       |     * on a Weierstrass curve:
  275|       |     * https://mailarchive.ietf.org/arch/msg/cfrg/7DyYY6gg32wDgHAhgSb6XxMDlJA/
  276|       |     *
  277|       |     *
  278|       |     * === Background: the effective affine technique ===
  279|       |     *
  280|       |     * Let phi_u be the isomorphism that maps (x, y) on secp256k1 curve y^2 = x^3 + 7 to
  281|       |     * x' = u^2*x, y' = u^3*y on curve y'^2 = x'^3 + u^6*7. This new curve has the same order as
  282|       |     * the original (it is isomorphic), but moreover, has the same addition/doubling formulas, as
  283|       |     * the curve b=7 coefficient does not appear in those formulas (or at least does not appear in
  284|       |     * the formulas implemented in this codebase, both affine and Jacobian). See also Example 9.5.2
  285|       |     * in https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch9.pdf.
  286|       |     *
  287|       |     * This means any linear combination of secp256k1 points can be computed by applying phi_u
  288|       |     * (with non-zero u) on all input points (including the generator, if used), computing the
  289|       |     * linear combination on the isomorphic curve (using the same group laws), and then applying
  290|       |     * phi_u^{-1} to get back to secp256k1.
  291|       |     *
  292|       |     * Switching to Jacobian coordinates, note that phi_u applied to (X, Y, Z) is simply
  293|       |     * (X, Y, Z/u). Thus, if we want to compute (X1, Y1, Z) + (X2, Y2, Z), with identical Z
  294|       |     * coordinates, we can use phi_Z to transform it to (X1, Y1, 1) + (X2, Y2, 1) on an isomorphic
  295|       |     * curve where the affine addition formula can be used instead.
  296|       |     * If (X3, Y3, Z3) = (X1, Y1) + (X2, Y2) on that curve, then our answer on secp256k1 is
  297|       |     * (X3, Y3, Z3*Z).
  298|       |     *
  299|       |     * This is the effective affine technique: if we have a linear combination of group elements
  300|       |     * to compute, and all those group elements have the same Z coordinate, we can simply pretend
  301|       |     * that all those Z coordinates are 1, perform the computation that way, and then multiply the
  302|       |     * original Z coordinate back in.
  303|       |     *
  304|       |     * The technique works on any a=0 short Weierstrass curve. It is possible to generalize it to
  305|       |     * other curves too, but there the isomorphic curves will have different 'a' coefficients,
  306|       |     * which typically does affect the group laws.
  307|       |     *
  308|       |     *
  309|       |     * === Avoiding the square root for x-only point multiplication ===
  310|       |     *
  311|       |     * In this function, we want to compute the X coordinate of q*(n/d, y), for
  312|       |     * y = sqrt((n/d)^3 + 7). Its negation would also be a valid Y coordinate, but by convention
  313|       |     * we pick whatever sqrt returns (which we assume to be a deterministic function).
  314|       |     *
  315|       |     * Let g = y^2*d^3 = n^3 + 7*d^3. This also means y = sqrt(g/d^3).
  316|       |     * Further let v = sqrt(d*g), which must exist as d*g = y^2*d^4 = (y*d^2)^2.
  317|       |     *
  318|       |     * The input point (n/d, y) also has Jacobian coordinates:
  319|       |     *
  320|       |     *     (n/d, y, 1)
  321|       |     *   = (n/d * v^2, y * v^3, v)
  322|       |     *   = (n/d * d*g, y * sqrt(d^3*g^3), v)
  323|       |     *   = (n/d * d*g, sqrt(y^2 * d^3*g^3), v)
  324|       |     *   = (n*g, sqrt(g/d^3 * d^3*g^3), v)
  325|       |     *   = (n*g, sqrt(g^4), v)
  326|       |     *   = (n*g, g^2, v)
  327|       |     *
  328|       |     * It is easy to verify that both (n*g, g^2, v) and its negation (n*g, -g^2, v) have affine X
  329|       |     * coordinate n/d, and this holds even when the square root function doesn't have a
  330|       |     * deterministic sign. We choose the (n*g, g^2, v) version.
  331|       |     *
  332|       |     * Now switch to the effective affine curve using phi_v, where the input point has coordinates
  333|       |     * (n*g, g^2). Compute (X, Y, Z) = q * (n*g, g^2) there.
  334|       |     *
  335|       |     * Back on secp256k1, that means q * (n*g, g^2, v) = (X, Y, v*Z). This last point has affine X
  336|       |     * coordinate X / (v^2*Z^2) = X / (d*g*Z^2). Determining the affine Y coordinate would involve
  337|       |     * a square root, but as long as we only care about the resulting X coordinate, no square root
  338|       |     * is needed anywhere in this computation.
  339|       |     */
  340|       |
  341|  12.6k|    secp256k1_fe g, i;
  342|  12.6k|    secp256k1_ge p;
  343|  12.6k|    secp256k1_gej rj;
  344|       |
  345|       |    /* Compute g = (n^3 + B*d^3). */
  346|  12.6k|    secp256k1_fe_sqr(&g, n);
  ------------------
  |  |   94|  12.6k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  347|  12.6k|    secp256k1_fe_mul(&g, &g, n);
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  348|  12.6k|    if (d) {
  ------------------
  |  Branch (348:9): [True: 12.6k, False: 0]
  ------------------
  349|  12.6k|        secp256k1_fe b;
  350|  12.6k|        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero(d));
  351|  12.6k|        secp256k1_fe_sqr(&b, d);
  ------------------
  |  |   94|  12.6k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  352|  12.6k|        VERIFY_CHECK(SECP256K1_B <= 8); /* magnitude of b will be <= 8 after the next call */
  353|  12.6k|        secp256k1_fe_mul_int(&b, SECP256K1_B);
  ------------------
  |  |  233|  12.6k|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  12.6k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  12.6k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  12.6k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 12.6k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  12.6k|    } \
  |  |  |  |   84|  12.6k|    stmt; \
  |  |  |  |   85|  12.6k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  354|  12.6k|        secp256k1_fe_mul(&b, &b, d);
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  355|  12.6k|        secp256k1_fe_add(&g, &b);
  ------------------
  |  |   92|  12.6k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  356|  12.6k|        if (!known_on_curve) {
  ------------------
  |  Branch (356:13): [True: 0, False: 12.6k]
  ------------------
  357|       |            /* We need to determine whether (n/d)^3 + 7 is square.
  358|       |             *
  359|       |             *     is_square((n/d)^3 + 7)
  360|       |             * <=> is_square(((n/d)^3 + 7) * d^4)
  361|       |             * <=> is_square((n^3 + 7*d^3) * d)
  362|       |             * <=> is_square(g * d)
  363|       |             */
  364|      0|            secp256k1_fe c;
  365|      0|            secp256k1_fe_mul(&c, &g, d);
  ------------------
  |  |   93|      0|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  366|      0|            if (!secp256k1_fe_is_square_var(&c)) return 0;
  ------------------
  |  |  103|      0|#  define secp256k1_fe_is_square_var secp256k1_fe_impl_is_square_var
  ------------------
  |  Branch (366:17): [True: 0, False: 0]
  ------------------
  367|      0|        }
  368|  12.6k|    } else {
  369|      0|        secp256k1_fe_add_int(&g, SECP256K1_B);
  ------------------
  |  |  102|      0|#  define secp256k1_fe_add_int secp256k1_fe_impl_add_int
  ------------------
                      secp256k1_fe_add_int(&g, SECP256K1_B);
  ------------------
  |  |   73|      0|#define SECP256K1_B 7
  ------------------
  370|      0|        if (!known_on_curve) {
  ------------------
  |  Branch (370:13): [True: 0, False: 0]
  ------------------
  371|       |            /* g at this point equals x^3 + 7. Test if it is square. */
  372|      0|            if (!secp256k1_fe_is_square_var(&g)) return 0;
  ------------------
  |  |  103|      0|#  define secp256k1_fe_is_square_var secp256k1_fe_impl_is_square_var
  ------------------
  |  Branch (372:17): [True: 0, False: 0]
  ------------------
  373|      0|        }
  374|      0|    }
  375|       |
  376|  12.6k|    SECP256K1_FE_VERIFY_MAGNITUDE(&g, 2);
  ------------------
  |  |  348|  12.6k|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
  377|       |
  378|       |    /* Compute base point P = (n*g, g^2), the effective affine version of (n*g, g^2, v), which has
  379|       |     * corresponding affine X coordinate n/d. */
  380|  12.6k|    secp256k1_fe_mul(&p.x, &g, n);
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  381|  12.6k|    secp256k1_fe_sqr(&p.y, &g);
  ------------------
  |  |   94|  12.6k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  382|  12.6k|    p.infinity = 0;
  383|       |
  384|       |    /* Perform x-only EC multiplication of P with q. */
  385|  12.6k|    VERIFY_CHECK(!secp256k1_scalar_is_zero(q));
  386|  12.6k|    secp256k1_ecmult_const(&rj, &p, q);
  387|  12.6k|    VERIFY_CHECK(!secp256k1_gej_is_infinity(&rj));
  388|       |
  389|       |    /* The resulting (X, Y, Z) point on the effective-affine isomorphic curve corresponds to
  390|       |     * (X, Y, Z*v) on the secp256k1 curve. The affine version of that has X coordinate
  391|       |     * (X / (Z^2*d*g)). */
  392|  12.6k|    secp256k1_fe_sqr(&i, &rj.z);
  ------------------
  |  |   94|  12.6k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  393|  12.6k|    secp256k1_fe_mul(&i, &i, &g);
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  394|  12.6k|    if (d) secp256k1_fe_mul(&i, &i, d);
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  |  Branch (394:9): [True: 12.6k, False: 0]
  ------------------
  395|  12.6k|    secp256k1_fe_inv(&i, &i);
  ------------------
  |  |   98|  12.6k|#  define secp256k1_fe_inv secp256k1_fe_impl_inv
  ------------------
  396|  12.6k|    secp256k1_fe_mul(r, &rj.x, &i);
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  397|       |
  398|  12.6k|    return 1;
  399|  12.6k|}
secp256k1.c:secp256k1_ecmult_const:
  124|  12.6k|static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {
  125|       |    /* The approach below combines the signed-digit logic from Mike Hamburg's
  126|       |     * "Fast and compact elliptic-curve cryptography" (https://eprint.iacr.org/2012/309)
  127|       |     * Section 3.3, with the GLV endomorphism.
  128|       |     *
  129|       |     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a
  130|       |     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),
  131|       |     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:
  132|       |     *
  133|       |     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)
  134|       |     *
  135|       |     * Then it holds that C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)
  136|       |     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A
  137|       |     *                              = (2*v + 1 - 2^l) * A
  138|       |     *
  139|       |     * Thus, one can compute q*A as C_256((q + 2^256 - 1) / 2, A). This is the basis for the
  140|       |     * paper's signed-digit multi-comb algorithm for multiplication using a precomputed table.
  141|       |     *
  142|       |     * It is appealing to try to combine this with the GLV optimization: the idea that a scalar
  143|       |     * s can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that
  144|       |     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the
  145|       |     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1
  146|       |     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:
  147|       |     *
  148|       |     *   To compute q*A:
  149|       |     *   - Let s1, s2 = split_lambda(q)
  150|       |     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)
  151|       |     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)
  152|       |     *   - Return R1 + R2
  153|       |     *
  154|       |     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 (mod n)
  155|       |     * and (s2 + 2^256 - 1) / 2 (mod n) are not, undoing the benefit of the splitting.
  156|       |     *
  157|       |     * To make it work, we want to modify the input scalar q first, before splitting, and then only
  158|       |     * add a 2^128 offset of the split results (so that they end up in the single 129-bit range
  159|       |     * [0,2^129]). A slightly smaller offset would work due to the bounds on the split, but we pick
  160|       |     * 2^128 for simplicity. Let s be the scalar fed to split_lambda, and f(q) the function to
  161|       |     * compute it from q:
  162|       |     *
  163|       |     *   To compute q*A:
  164|       |     *   - Compute s = f(q)
  165|       |     *   - Let s1, s2 = split_lambda(s)
  166|       |     *   - Let v1 = s1 + 2^128 (mod n)
  167|       |     *   - Let v2 = s2 + 2^128 (mod n)
  168|       |     *   - Let R1 = C_l(v1, A)
  169|       |     *   - Let R2 = C_l(v2, lambda*A)
  170|       |     *   - Return R1 + R2
  171|       |     *
  172|       |     * l will thus need to be at least 129, but we may overshoot by a few bits (see
  173|       |     * further), so keep it as a variable.
  174|       |     *
  175|       |     * To solve for s, we reason:
  176|       |     *     q*A  = R1 + R2
  177|       |     * <=> q*A  = C_l(s1 + 2^128, A) + C_l(s2 + 2^128, lambda*A)
  178|       |     * <=> q*A  = (2*(s1 + 2^128) + 1 - 2^l) * A + (2*(s2 + 2^128) + 1 - 2^l) * lambda*A
  179|       |     * <=> q*A  = (2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda)) * A
  180|       |     * <=> q    = 2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)
  181|       |     * <=> q    = 2*s + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)
  182|       |     * <=> s    = (q + (2^l - 2^129 - 1) * (1 + lambda)) / 2 (mod n)
  183|       |     * <=> f(q) = (q + K) / 2 (mod n)
  184|       |     *            where K = (2^l - 2^129 - 1)*(1 + lambda) (mod n)
  185|       |     *
  186|       |     * We will process the computation of C_l(v1, A) and C_l(v2, lambda*A) in groups of
  187|       |     * ECMULT_CONST_GROUP_SIZE, so we set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE
  188|       |     * that is not less than 129; this equals ECMULT_CONST_BITS.
  189|       |     */
  190|       |
  191|       |    /* The offset to add to s1 and s2 to make them non-negative. Equal to 2^128. */
  192|  12.6k|    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 1, 0, 0, 0, 0);
  ------------------
  |  |   17|  12.6k|#define SECP256K1_SCALAR_CONST(d7, d6, d5, d4, d3, d2, d1, d0) {{((uint64_t)(d1)) << 32 | (d0), ((uint64_t)(d3)) << 32 | (d2), ((uint64_t)(d5)) << 32 | (d4), ((uint64_t)(d7)) << 32 | (d6)}}
  ------------------
  193|  12.6k|    secp256k1_scalar s, v1, v2;
  194|  12.6k|    secp256k1_ge pre_a[ECMULT_CONST_TABLE_SIZE];
  195|  12.6k|    secp256k1_ge pre_a_lam[ECMULT_CONST_TABLE_SIZE];
  196|  12.6k|    secp256k1_fe global_z;
  197|  12.6k|    int group, i;
  198|       |
  199|       |    /* We're allowed to be non-constant time in the point, and the code below (in particular,
  200|       |     * secp256k1_ecmult_const_odd_multiples_table_globalz) cannot deal with infinity in a
  201|       |     * constant-time manner anyway. */
  202|  12.6k|    if (secp256k1_ge_is_infinity(a)) {
  ------------------
  |  Branch (202:9): [True: 0, False: 12.6k]
  ------------------
  203|      0|        secp256k1_gej_set_infinity(r);
  204|      0|        return;
  205|      0|    }
  206|       |
  207|       |    /* Compute v1 and v2. */
  208|  12.6k|    secp256k1_scalar_add(&s, q, &secp256k1_ecmult_const_K);
  209|  12.6k|    secp256k1_scalar_half(&s, &s);
  210|  12.6k|    secp256k1_scalar_split_lambda(&v1, &v2, &s);
  211|  12.6k|    secp256k1_scalar_add(&v1, &v1, &S_OFFSET);
  212|  12.6k|    secp256k1_scalar_add(&v2, &v2, &S_OFFSET);
  213|       |
  214|       |#ifdef VERIFY
  215|       |    /* Verify that v1 and v2 are in range [0, 2^129-1]. */
  216|       |    for (i = 129; i < 256; ++i) {
  217|       |        VERIFY_CHECK(secp256k1_scalar_get_bits_limb32(&v1, i, 1) == 0);
  218|       |        VERIFY_CHECK(secp256k1_scalar_get_bits_limb32(&v2, i, 1) == 0);
  219|       |    }
  220|       |#endif
  221|       |
  222|       |    /* Calculate odd multiples of A and A*lambda.
  223|       |     * All multiples are brought to the same Z 'denominator', which is stored
  224|       |     * in global_z. Due to secp256k1' isomorphism we can do all operations pretending
  225|       |     * that the Z coordinate was 1, use affine addition formulae, and correct
  226|       |     * the Z coordinate of the result once at the end.
  227|       |     */
  228|  12.6k|    secp256k1_gej_set_ge(r, a);
  229|  12.6k|    secp256k1_ecmult_const_odd_multiples_table_globalz(pre_a, &global_z, r);
  230|   215k|    for (i = 0; i < ECMULT_CONST_TABLE_SIZE; i++) {
  ------------------
  |  |   33|   215k|#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))
  |  |  ------------------
  |  |  |  |   30|   215k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  ------------------
  |  Branch (230:17): [True: 202k, False: 12.6k]
  ------------------
  231|   202k|        secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);
  232|   202k|    }
  233|       |
  234|       |    /* Next, we compute r = C_l(v1, A) + C_l(v2, lambda*A).
  235|       |     *
  236|       |     * We proceed in groups of ECMULT_CONST_GROUP_SIZE bits, operating on that many bits
  237|       |     * at a time, from high in v1, v2 to low. Call these bits1 (from v1) and bits2 (from v2).
  238|       |     *
  239|       |     * Now note that ECMULT_CONST_TABLE_GET_GE(&t, pre_a, bits1) loads into t a point equal
  240|       |     * to C_{ECMULT_CONST_GROUP_SIZE}(bits1, A), and analogously for pre_lam_a / bits2.
  241|       |     * This means that all we need to do is add these looked up values together, multiplied
  242|       |     * by 2^(ECMULT_GROUP_SIZE * group).
  243|       |     */
  244|   342k|    for (group = ECMULT_CONST_GROUPS - 1; group >= 0; --group) {
  ------------------
  |  |   34|  12.6k|#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)
  |  |  ------------------
  |  |  |  |   30|  12.6k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  |  |               #define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)
  |  |  ------------------
  |  |  |  |   30|  12.6k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  ------------------
  |  Branch (244:43): [True: 329k, False: 12.6k]
  ------------------
  245|       |        /* Using the _var get_bits function is ok here, since it's only variable in offset and count, not in the scalar. */
  246|   329k|        unsigned int bits1 = secp256k1_scalar_get_bits_var(&v1, group * ECMULT_CONST_GROUP_SIZE, ECMULT_CONST_GROUP_SIZE);
  ------------------
  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  ------------------
                      unsigned int bits1 = secp256k1_scalar_get_bits_var(&v1, group * ECMULT_CONST_GROUP_SIZE, ECMULT_CONST_GROUP_SIZE);
  ------------------
  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  ------------------
  247|   329k|        unsigned int bits2 = secp256k1_scalar_get_bits_var(&v2, group * ECMULT_CONST_GROUP_SIZE, ECMULT_CONST_GROUP_SIZE);
  ------------------
  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  ------------------
                      unsigned int bits2 = secp256k1_scalar_get_bits_var(&v2, group * ECMULT_CONST_GROUP_SIZE, ECMULT_CONST_GROUP_SIZE);
  ------------------
  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  ------------------
  248|   329k|        secp256k1_ge t;
  249|   329k|        int j;
  250|       |
  251|   329k|        ECMULT_CONST_TABLE_GET_GE(&t, pre_a, bits1);
  ------------------
  |  |   61|   329k|#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \
  |  |   62|   329k|    unsigned int m = 0; \
  |  |   63|   329k|    /* If the top bit of n is 0, we want the negation. */ \
  |  |   64|   329k|    volatile unsigned int negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \
  |  |  ------------------
  |  |  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  |  |   65|   329k|    /* Let n[i] be the i-th bit of n, then the index is
  |  |   66|   329k|     *     sum(cnot(n[i]) * 2^i, i=0..l-2)
  |  |   67|   329k|     * where cnot(b) = b if n[l-1] = 1 and 1 - b otherwise.
  |  |   68|   329k|     * For example, if n = 4, in binary 0100, the index is 3, in binary 011.
  |  |   69|   329k|     *
  |  |   70|   329k|     * Proof:
  |  |   71|   329k|     *     Let
  |  |   72|   329k|     *         x = sum((2*n[i] - 1)*2^i, i=0..l-1)
  |  |   73|   329k|     *           = 2*sum(n[i] * 2^i, i=0..l-1) - 2^l + 1
  |  |   74|   329k|     *     be the value represented by n.
  |  |   75|   329k|     *     The index is (x - 1)/2 if x > 0 and -(x + 1)/2 otherwise.
  |  |   76|   329k|     *     Case x > 0:
  |  |   77|   329k|     *         n[l-1] = 1
  |  |   78|   329k|     *         index = sum(n[i] * 2^i, i=0..l-1) - 2^(l-1)
  |  |   79|   329k|     *               = sum(n[i] * 2^i, i=0..l-2)
  |  |   80|   329k|     *     Case x <= 0:
  |  |   81|   329k|     *         n[l-1] = 0
  |  |   82|   329k|     *          index = -(2*sum(n[i] * 2^i, i=0..l-1) - 2^l + 2)/2
  |  |   83|   329k|     *                = 2^(l-1) - 1 - sum(n[i] * 2^i, i=0..l-1)
  |  |   84|   329k|     *                = sum((1 - n[i]) * 2^i, i=0..l-2)
  |  |   85|   329k|     */ \
  |  |   86|   329k|    unsigned int index = ((unsigned int)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \
  |  |  ------------------
  |  |  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  |  |   87|   329k|    secp256k1_fe neg_y; \
  |  |   88|   329k|    VERIFY_CHECK((n) < (1U << ECMULT_CONST_GROUP_SIZE)); \
  |  |   89|   329k|    VERIFY_CHECK(index < (1U << (ECMULT_CONST_GROUP_SIZE - 1))); \
  |  |   90|   329k|    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one
  |  |   91|   329k|     * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \
  |  |   92|   329k|    (r)->x = (pre)[m].x; \
  |  |   93|   329k|    (r)->y = (pre)[m].y; \
  |  |   94|  5.27M|    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \
  |  |  ------------------
  |  |  |  |   33|  5.27M|#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|  5.27M|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (94:17): [True: 4.94M, False: 329k]
  |  |  ------------------
  |  |   95|  4.94M|        /* This loop is used to avoid secret data in array indices. See
  |  |   96|  4.94M|         * the comment in ecmult_gen_impl.h for rationale. */ \
  |  |   97|  4.94M|        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \
  |  |  ------------------
  |  |  |  |   95|  4.94M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  |  |  ------------------
  |  |   98|  4.94M|        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \
  |  |  ------------------
  |  |  |  |   95|  4.94M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  |  |  ------------------
  |  |   99|  4.94M|    } \
  |  |  100|   329k|    (r)->infinity = 0; \
  |  |  101|   329k|    secp256k1_fe_negate(&neg_y, &(r)->y, 1); \
  |  |  ------------------
  |  |  |  |  211|   329k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  |  |  ------------------
  |  |  |  |  |  |   77|   329k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |  |  |   78|   329k|    switch(42) { \
  |  |  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:9): [True: 0, False: 329k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   81|      0|            break; \
  |  |  |  |  |  |   82|   329k|        default: ; \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (82:9): [True: 329k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   83|   329k|    } \
  |  |  |  |  |  |   84|   329k|    stmt; \
  |  |  |  |  |  |   85|   329k|} while(0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (85:9): [Folded, False: 329k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  102|   329k|    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \
  |  |  ------------------
  |  |  |  |   95|   329k|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  |  |  ------------------
  |  |  103|   329k|} while(0)
  |  |  ------------------
  |  |  |  Branch (103:9): [Folded, False: 329k]
  |  |  ------------------
  ------------------
  252|   329k|        if (group == ECMULT_CONST_GROUPS - 1) {
  ------------------
  |  |   34|   329k|#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)
  |  |  ------------------
  |  |  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  |  |               #define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)
  |  |  ------------------
  |  |  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  ------------------
  |  Branch (252:13): [True: 12.6k, False: 317k]
  ------------------
  253|       |            /* Directly set r in the first iteration. */
  254|  12.6k|            secp256k1_gej_set_ge(r, &t);
  255|   317k|        } else {
  256|       |            /* Shift the result so far up. */
  257|  1.90M|            for (j = 0; j < ECMULT_CONST_GROUP_SIZE; ++j) {
  ------------------
  |  |   30|  1.90M|#  define ECMULT_CONST_GROUP_SIZE 5
  ------------------
  |  Branch (257:25): [True: 1.58M, False: 317k]
  ------------------
  258|  1.58M|                secp256k1_gej_double(r, r);
  259|  1.58M|            }
  260|   317k|            secp256k1_gej_add_ge(r, r, &t);
  261|   317k|        }
  262|   329k|        ECMULT_CONST_TABLE_GET_GE(&t, pre_a_lam, bits2);
  ------------------
  |  |   61|   329k|#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \
  |  |   62|   329k|    unsigned int m = 0; \
  |  |   63|   329k|    /* If the top bit of n is 0, we want the negation. */ \
  |  |   64|   329k|    volatile unsigned int negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \
  |  |  ------------------
  |  |  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  |  |   65|   329k|    /* Let n[i] be the i-th bit of n, then the index is
  |  |   66|   329k|     *     sum(cnot(n[i]) * 2^i, i=0..l-2)
  |  |   67|   329k|     * where cnot(b) = b if n[l-1] = 1 and 1 - b otherwise.
  |  |   68|   329k|     * For example, if n = 4, in binary 0100, the index is 3, in binary 011.
  |  |   69|   329k|     *
  |  |   70|   329k|     * Proof:
  |  |   71|   329k|     *     Let
  |  |   72|   329k|     *         x = sum((2*n[i] - 1)*2^i, i=0..l-1)
  |  |   73|   329k|     *           = 2*sum(n[i] * 2^i, i=0..l-1) - 2^l + 1
  |  |   74|   329k|     *     be the value represented by n.
  |  |   75|   329k|     *     The index is (x - 1)/2 if x > 0 and -(x + 1)/2 otherwise.
  |  |   76|   329k|     *     Case x > 0:
  |  |   77|   329k|     *         n[l-1] = 1
  |  |   78|   329k|     *         index = sum(n[i] * 2^i, i=0..l-1) - 2^(l-1)
  |  |   79|   329k|     *               = sum(n[i] * 2^i, i=0..l-2)
  |  |   80|   329k|     *     Case x <= 0:
  |  |   81|   329k|     *         n[l-1] = 0
  |  |   82|   329k|     *          index = -(2*sum(n[i] * 2^i, i=0..l-1) - 2^l + 2)/2
  |  |   83|   329k|     *                = 2^(l-1) - 1 - sum(n[i] * 2^i, i=0..l-1)
  |  |   84|   329k|     *                = sum((1 - n[i]) * 2^i, i=0..l-2)
  |  |   85|   329k|     */ \
  |  |   86|   329k|    unsigned int index = ((unsigned int)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \
  |  |  ------------------
  |  |  |  |   30|   329k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  |  |   87|   329k|    secp256k1_fe neg_y; \
  |  |   88|   329k|    VERIFY_CHECK((n) < (1U << ECMULT_CONST_GROUP_SIZE)); \
  |  |   89|   329k|    VERIFY_CHECK(index < (1U << (ECMULT_CONST_GROUP_SIZE - 1))); \
  |  |   90|   329k|    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one
  |  |   91|   329k|     * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \
  |  |   92|   329k|    (r)->x = (pre)[m].x; \
  |  |   93|   329k|    (r)->y = (pre)[m].y; \
  |  |   94|  5.27M|    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \
  |  |  ------------------
  |  |  |  |   33|  5.27M|#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))
  |  |  |  |  ------------------
  |  |  |  |  |  |   30|  5.27M|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (94:17): [True: 4.94M, False: 329k]
  |  |  ------------------
  |  |   95|  4.94M|        /* This loop is used to avoid secret data in array indices. See
  |  |   96|  4.94M|         * the comment in ecmult_gen_impl.h for rationale. */ \
  |  |   97|  4.94M|        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \
  |  |  ------------------
  |  |  |  |   95|  4.94M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  |  |  ------------------
  |  |   98|  4.94M|        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \
  |  |  ------------------
  |  |  |  |   95|  4.94M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  |  |  ------------------
  |  |   99|  4.94M|    } \
  |  |  100|   329k|    (r)->infinity = 0; \
  |  |  101|   329k|    secp256k1_fe_negate(&neg_y, &(r)->y, 1); \
  |  |  ------------------
  |  |  |  |  211|   329k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  |  |  ------------------
  |  |  |  |  |  |   77|   329k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |  |  |   78|   329k|    switch(42) { \
  |  |  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (80:9): [True: 0, False: 329k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   81|      0|            break; \
  |  |  |  |  |  |   82|   329k|        default: ; \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (82:9): [True: 329k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   83|   329k|    } \
  |  |  |  |  |  |   84|   329k|    stmt; \
  |  |  |  |  |  |   85|   329k|} while(0)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (85:9): [Folded, False: 329k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  102|   329k|    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \
  |  |  ------------------
  |  |  |  |   95|   329k|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  |  |  ------------------
  |  |  103|   329k|} while(0)
  |  |  ------------------
  |  |  |  Branch (103:9): [Folded, False: 329k]
  |  |  ------------------
  ------------------
  263|   329k|        secp256k1_gej_add_ge(r, r, &t);
  264|   329k|    }
  265|       |
  266|       |    /* Map the result back to the secp256k1 curve from the isomorphic curve. */
  267|  12.6k|    secp256k1_fe_mul(&r->z, &r->z, &global_z);
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  268|  12.6k|}
secp256k1.c:secp256k1_ecmult_const_odd_multiples_table_globalz:
   44|  12.6k|static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {
   45|  12.6k|    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];
   46|       |
   47|  12.6k|    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);
  ------------------
  |  |   33|  12.6k|#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))
  |  |  ------------------
  |  |  |  |   30|  12.6k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  ------------------
   48|  12.6k|    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);
  ------------------
  |  |   33|  12.6k|#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))
  |  |  ------------------
  |  |  |  |   30|  12.6k|#  define ECMULT_CONST_GROUP_SIZE 5
  |  |  ------------------
  ------------------
   49|  12.6k|}

secp256k1.c:secp256k1_ecmult_gen_context_clear:
   26|      2|static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context *ctx) {
   27|      2|    ctx->built = 0;
   28|      2|    secp256k1_scalar_clear(&ctx->scalar_offset);
   29|      2|    secp256k1_ge_clear(&ctx->ge_offset);
   30|      2|    secp256k1_fe_clear(&ctx->proj_blind);
   31|      2|}
secp256k1.c:secp256k1_ecmult_gen_context_is_built:
   22|  79.1k|static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context* ctx) {
   23|  79.1k|    return ctx->built;
   24|  79.1k|}
secp256k1.c:secp256k1_ecmult_gen:
   54|  79.1k|static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context *ctx, secp256k1_gej *r, const secp256k1_scalar *gn) {
   55|  79.1k|    uint32_t comb_off;
   56|  79.1k|    secp256k1_ge add;
   57|  79.1k|    secp256k1_fe neg;
   58|  79.1k|    secp256k1_ge_storage adds;
   59|  79.1k|    secp256k1_scalar d;
   60|       |    /* Array of uint32_t values large enough to store COMB_BITS bits. Only the bottom
   61|       |     * 8 are ever nonzero, but having the zero padding at the end if COMB_BITS>256
   62|       |     * avoids the need to deal with out-of-bounds reads from a scalar. */
   63|  79.1k|    uint32_t recoded[(COMB_BITS + 31) >> 5] = {0};
   64|  79.1k|    int first = 1, i;
   65|       |
   66|  79.1k|    memset(&adds, 0, sizeof(adds));
   67|       |
   68|       |    /* We want to compute R = gn*G.
   69|       |     *
   70|       |     * To blind the scalar used in the computation, we rewrite this to be
   71|       |     * R = (gn - b)*G + b*G, with a blinding value b determined by the context.
   72|       |     *
   73|       |     * The multiplication (gn-b)*G will be performed using a signed-digit multi-comb (see Section
   74|       |     * 3.3 of "Fast and compact elliptic-curve cryptography" by Mike Hamburg,
   75|       |     * https://eprint.iacr.org/2012/309).
   76|       |     *
   77|       |     * Let comb(s, P) = sum((2*s[i]-1)*2^i*P for i=0..COMB_BITS-1), where s[i] is the i'th bit of
   78|       |     * the binary representation of scalar s. So the s[i] values determine whether -2^i*P (s[i]=0)
   79|       |     * or +2^i*P (s[i]=1) are added together. COMB_BITS is at least 256, so all bits of s are
   80|       |     * covered. By manipulating:
   81|       |     *
   82|       |     *     comb(s, P) = sum((2*s[i]-1)*2^i*P for i=0..COMB_BITS-1)
   83|       |     * <=> comb(s, P) = sum((2*s[i]-1)*2^i for i=0..COMB_BITS-1) * P
   84|       |     * <=> comb(s, P) = (2*sum(s[i]*2^i for i=0..COMB_BITS-1) - sum(2^i for i=0..COMB_BITS-1)) * P
   85|       |     * <=> comb(s, P) = (2*s - (2^COMB_BITS - 1)) * P
   86|       |     *
   87|       |     * If we wanted to compute (gn-b)*G as comb(s, G), it would need to hold that
   88|       |     *
   89|       |     *     (gn - b) * G = (2*s - (2^COMB_BITS - 1)) * G
   90|       |     * <=> s = (gn - b + (2^COMB_BITS - 1))/2 (mod order)
   91|       |     *
   92|       |     * We use an alternative here that avoids the modular division by two: instead we compute
   93|       |     * (gn-b)*G as comb(d, G/2). For that to hold it must be the case that
   94|       |     *
   95|       |     *     (gn - b) * G = (2*d - (2^COMB_BITS - 1)) * (G/2)
   96|       |     * <=> d = gn - b + (2^COMB_BITS - 1)/2 (mod order)
   97|       |     *
   98|       |     * Adding precomputation, our final equations become:
   99|       |     *
  100|       |     *     ctx->scalar_offset = (2^COMB_BITS - 1)/2 - b (mod order)
  101|       |     *     ctx->ge_offset = b*G
  102|       |     *     d = gn + ctx->scalar_offset (mod order)
  103|       |     *     R = comb(d, G/2) + ctx->ge_offset
  104|       |     *
  105|       |     * comb(d, G/2) function is then computed by summing + or - 2^(i-1)*G, for i=0..COMB_BITS-1,
  106|       |     * depending on the value of the bits d[i] of the binary representation of scalar d.
  107|       |     */
  108|       |
  109|       |    /* Compute the scalar d = (gn + ctx->scalar_offset). */
  110|  79.1k|    secp256k1_scalar_add(&d, &ctx->scalar_offset, gn);
  111|       |    /* Convert to recoded array. */
  112|   712k|    for (i = 0; i < 8 && i < ((COMB_BITS + 31) >> 5); ++i) {
  ------------------
  |  |   84|   633k|#define COMB_BITS (COMB_BLOCKS * COMB_TEETH * COMB_SPACING)
  |  |  ------------------
  |  |  |  |   78|   633k|#define COMB_SPACING CEIL_DIV(COMB_RANGE, COMB_BLOCKS * COMB_TEETH)
  |  |  |  |  ------------------
  |  |  |  |  |  |  180|   633k|#define CEIL_DIV(x, y) (1 + ((x) - 1) / (y))
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (112:17): [True: 633k, False: 79.1k]
  |  Branch (112:26): [True: 633k, False: 0]
  ------------------
  113|   633k|        recoded[i] = secp256k1_scalar_get_bits_limb32(&d, 32 * i, 32);
  114|   633k|    }
  115|  79.1k|    secp256k1_scalar_clear(&d);
  116|       |
  117|       |    /* In secp256k1_ecmult_gen_prec_table we have precomputed sums of the
  118|       |     * (2*d[i]-1) * 2^(i-1) * G points, for various combinations of i positions.
  119|       |     * We rewrite our equation in terms of these table entries.
  120|       |     *
  121|       |     * Let mask(b) = sum(2^((b*COMB_TEETH + t)*COMB_SPACING) for t=0..COMB_TEETH-1),
  122|       |     * with b ranging from 0 to COMB_BLOCKS-1. So for example with COMB_BLOCKS=11,
  123|       |     * COMB_TEETH=6, COMB_SPACING=4, we would have:
  124|       |     *   mask(0)  = 2^0   + 2^4   + 2^8   + 2^12  + 2^16  + 2^20,
  125|       |     *   mask(1)  = 2^24  + 2^28  + 2^32  + 2^36  + 2^40  + 2^44,
  126|       |     *   mask(2)  = 2^48  + 2^52  + 2^56  + 2^60  + 2^64  + 2^68,
  127|       |     *   ...
  128|       |     *   mask(10) = 2^240 + 2^244 + 2^248 + 2^252 + 2^256 + 2^260
  129|       |     *
  130|       |     * We will split up the bits d[i] using these masks. Specifically, each mask is
  131|       |     * used COMB_SPACING times, with different shifts:
  132|       |     *
  133|       |     * d = (d & mask(0)<<0) + (d & mask(1)<<0) + ... + (d & mask(COMB_BLOCKS-1)<<0) +
  134|       |     *     (d & mask(0)<<1) + (d & mask(1)<<1) + ... + (d & mask(COMB_BLOCKS-1)<<1) +
  135|       |     *     ...
  136|       |     *     (d & mask(0)<<(COMB_SPACING-1)) + ...
  137|       |     *
  138|       |     * Now define table(b, m) = (m - mask(b)/2) * G, and we will precompute these values for
  139|       |     * b=0..COMB_BLOCKS-1, and for all values m which (d & mask(b)) can take (so m can take on
  140|       |     * 2^COMB_TEETH distinct values).
  141|       |     *
  142|       |     * If m=(d & mask(b)), then table(b, m) is the sum of 2^i * (2*d[i]-1) * G/2, with i
  143|       |     * iterating over the set bits in mask(b). In our example, table(2, 2^48 + 2^56 + 2^68)
  144|       |     * would equal (2^48 - 2^52 + 2^56 - 2^60 - 2^64 + 2^68) * G/2.
  145|       |     *
  146|       |     * With that, we can rewrite comb(d, G/2) as:
  147|       |     *
  148|       |     *     2^0 * (table(0, d>>0 & mask(0)) + ... + table(COMB_BLOCKS-1, d>>0 & mask(COMP_BLOCKS-1)))
  149|       |     *   + 2^1 * (table(0, d>>1 & mask(0)) + ... + table(COMB_BLOCKS-1, d>>1 & mask(COMP_BLOCKS-1)))
  150|       |     *   + 2^2 * (table(0, d>>2 & mask(0)) + ... + table(COMB_BLOCKS-1, d>>2 & mask(COMP_BLOCKS-1)))
  151|       |     *   + ...
  152|       |     *   + 2^(COMB_SPACING-1) * (table(0, d>>(COMB_SPACING-1) & mask(0)) + ...)
  153|       |     *
  154|       |     * Or more generically as
  155|       |     *
  156|       |     *   sum(2^i * sum(table(b, d>>i & mask(b)), b=0..COMB_BLOCKS-1), i=0..COMB_SPACING-1)
  157|       |     *
  158|       |     * This is implemented using an outer loop that runs in reverse order over the lines of this
  159|       |     * equation, which in each iteration runs an inner loop that adds the terms of that line and
  160|       |     * then doubles the result before proceeding to the next line.
  161|       |     *
  162|       |     * In pseudocode:
  163|       |     *   c = infinity
  164|       |     *   for comb_off in range(COMB_SPACING - 1, -1, -1):
  165|       |     *     for block in range(COMB_BLOCKS):
  166|       |     *       c += table(block, (d >> comb_off) & mask(block))
  167|       |     *     if comb_off > 0:
  168|       |     *       c = 2*c
  169|       |     *   return c
  170|       |     *
  171|       |     * This computes c = comb(d, G/2), and thus finally R = c + ctx->ge_offset. Note that it would
  172|       |     * be possible to apply an initial offset instead of a final offset (moving ge_offset to take
  173|       |     * the place of infinity above), but the chosen approach allows using (in a future improvement)
  174|       |     * an incomplete addition formula for most of the multiplication.
  175|       |     *
  176|       |     * The last question is how to implement the table(b, m) function. For any value of b,
  177|       |     * m=(d & mask(b)) can only take on at most 2^COMB_TEETH possible values (the last one may have
  178|       |     * fewer as there mask(b) may exceed the curve order). So we could create COMB_BLOCK tables
  179|       |     * which contain a value for each such m value.
  180|       |     *
  181|       |     * Now note that if m=(d & mask(b)), then flipping the relevant bits of m results in negating
  182|       |     * the result of table(b, m). This is because table(b,m XOR mask(b)) = table(b, mask(b) - m) =
  183|       |     * (mask(b) - m - mask(b)/2)*G = (-m + mask(b)/2)*G = -(m - mask(b)/2)*G = -table(b, m).
  184|       |     * Because of this it suffices to only store the first half of the m values for every b. If an
  185|       |     * entry from the second half is needed, we look up its bit-flipped version instead, and negate
  186|       |     * it.
  187|       |     *
  188|       |     * secp256k1_ecmult_gen_prec_table[b][index] stores the table(b, m) entries. Index
  189|       |     * is the relevant mask(b) bits of m packed together without gaps. */
  190|       |
  191|       |    /* Outer loop: iterate over comb_off from COMB_SPACING - 1 down to 0. */
  192|  79.1k|    comb_off = COMB_SPACING - 1;
  ------------------
  |  |   78|  79.1k|#define COMB_SPACING CEIL_DIV(COMB_RANGE, COMB_BLOCKS * COMB_TEETH)
  |  |  ------------------
  |  |  |  |  180|  79.1k|#define CEIL_DIV(x, y) (1 + ((x) - 1) / (y))
  |  |  ------------------
  ------------------
  193|  79.1k|    while (1) {
  ------------------
  |  Branch (193:12): [True: 79.1k, Folded]
  ------------------
  194|  79.1k|        uint32_t block;
  195|  79.1k|        uint32_t bit_pos = comb_off;
  196|       |        /* Inner loop: for each block, add table entries to the result. */
  197|  3.48M|        for (block = 0; block < COMB_BLOCKS; ++block) {
  ------------------
  |  Branch (197:25): [True: 3.40M, False: 79.1k]
  ------------------
  198|       |            /* Gather the mask(block)-selected bits of d into bits. They're packed:
  199|       |             * bits[tooth] = d[(block*COMB_TEETH + tooth)*COMB_SPACING + comb_off]. */
  200|  3.40M|            uint32_t bits = 0, sign, abs, index, tooth;
  201|       |            /* Instead of reading individual bits here to construct the bits variable,
  202|       |             * build up the result by xoring rotated reads together. In every iteration,
  203|       |             * one additional bit is made correct, starting at the bottom. The bits
  204|       |             * above that contain junk. This reduces leakage by avoiding computations
  205|       |             * on variables that can have only a low number of possible values (e.g.,
  206|       |             * just two values when reading a single bit into a variable.) See:
  207|       |             * https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-alam.pdf
  208|       |             */
  209|  23.8M|            for (tooth = 0; tooth < COMB_TEETH; ++tooth) {
  ------------------
  |  Branch (209:29): [True: 20.4M, False: 3.40M]
  ------------------
  210|       |                /* Construct bitdata s.t. the bottom bit is the bit we'd like to read.
  211|       |                 *
  212|       |                 * We could just set bitdata = recoded[bit_pos >> 5] >> (bit_pos & 0x1f)
  213|       |                 * but this would simply discard the bits that fall off at the bottom,
  214|       |                 * and thus, for example, bitdata could still have only two values if we
  215|       |                 * happen to shift by exactly 31 positions. We use a rotation instead,
  216|       |                 * which ensures that bitdata doesn't loose entropy. This relies on the
  217|       |                 * rotation being atomic, i.e., the compiler emitting an actual rot
  218|       |                 * instruction. */
  219|  20.4M|                uint32_t bitdata = secp256k1_rotr32(recoded[bit_pos >> 5], bit_pos & 0x1f);
  220|       |
  221|       |                /* Clear the bit at position tooth, but sssh, don't tell clang. */
  222|  20.4M|                uint32_t volatile vmask = ~(1 << tooth);
  223|  20.4M|                bits &= vmask;
  224|       |
  225|       |                /* Write the bit into position tooth (and junk into higher bits). */
  226|  20.4M|                bits ^= bitdata << tooth;
  227|  20.4M|                bit_pos += COMB_SPACING;
  ------------------
  |  |   78|  20.4M|#define COMB_SPACING CEIL_DIV(COMB_RANGE, COMB_BLOCKS * COMB_TEETH)
  |  |  ------------------
  |  |  |  |  180|  20.4M|#define CEIL_DIV(x, y) (1 + ((x) - 1) / (y))
  |  |  ------------------
  ------------------
  228|  20.4M|            }
  229|       |
  230|       |            /* If the top bit of bits is 1, flip them all (corresponding to looking up
  231|       |             * the negated table value), and remember to negate the result in sign. */
  232|  3.40M|            sign = (bits >> (COMB_TEETH - 1)) & 1;
  233|  3.40M|            abs = (bits ^ -sign) & (COMB_POINTS - 1);
  ------------------
  |  |   86|  3.40M|#define COMB_POINTS (1 << (COMB_TEETH - 1))
  ------------------
  234|  3.40M|            VERIFY_CHECK(sign == 0 || sign == 1);
  235|  3.40M|            VERIFY_CHECK(abs < COMB_POINTS);
  236|       |
  237|       |            /** This uses a conditional move to avoid any secret data in array indexes.
  238|       |             *   _Any_ use of secret indexes has been demonstrated to result in timing
  239|       |             *   sidechannels, even when the cache-line access patterns are uniform.
  240|       |             *  See also:
  241|       |             *   "A word of warning", CHES 2013 Rump Session, by Daniel J. Bernstein and Peter Schwabe
  242|       |             *    (https://cryptojedi.org/peter/data/chesrump-20130822.pdf) and
  243|       |             *   "Cache Attacks and Countermeasures: the Case of AES", RSA 2006,
  244|       |             *    by Dag Arne Osvik, Adi Shamir, and Eran Tromer
  245|       |             *    (https://www.tau.ac.il/~tromer/papers/cache.pdf)
  246|       |             */
  247|   112M|            for (index = 0; index < COMB_POINTS; ++index) {
  ------------------
  |  |   86|   112M|#define COMB_POINTS (1 << (COMB_TEETH - 1))
  ------------------
  |  Branch (247:29): [True: 108M, False: 3.40M]
  ------------------
  248|   108M|                secp256k1_ge_storage_cmov(&adds, &secp256k1_ecmult_gen_prec_table[block][index], index == abs);
  249|   108M|            }
  250|       |
  251|       |            /* Set add=adds or add=-adds, in constant time, based on sign. */
  252|  3.40M|            secp256k1_ge_from_storage(&add, &adds);
  253|  3.40M|            secp256k1_fe_negate(&neg, &add.y, 1);
  ------------------
  |  |  211|  3.40M|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  3.40M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  3.40M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 3.40M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  3.40M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 3.40M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  3.40M|    } \
  |  |  |  |   84|  3.40M|    stmt; \
  |  |  |  |   85|  3.40M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 3.40M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  254|  3.40M|            secp256k1_fe_cmov(&add.y, &neg, sign);
  ------------------
  |  |   95|  3.40M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  ------------------
  255|       |
  256|       |            /* Add the looked up and conditionally negated value to r. */
  257|  3.40M|            if (EXPECT(first, 0)) {
  ------------------
  |  |  136|  3.40M|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 79.1k, False: 3.32M]
  |  |  ------------------
  ------------------
  258|       |                /* If this is the first table lookup, we can skip addition. */
  259|  79.1k|                secp256k1_gej_set_ge(r, &add);
  260|       |                /* Give the entry a random Z coordinate to blind intermediary results. */
  261|  79.1k|                secp256k1_gej_rescale(r, &ctx->proj_blind);
  262|  79.1k|                first = 0;
  263|  3.32M|            } else {
  264|  3.32M|                secp256k1_gej_add_ge(r, r, &add);
  265|  3.32M|            }
  266|  3.40M|        }
  267|       |
  268|       |        /* Double the result, except in the last iteration. */
  269|  79.1k|        if (comb_off-- == 0) break;
  ------------------
  |  Branch (269:13): [True: 79.1k, False: 0]
  ------------------
  270|      0|        secp256k1_gej_double(r, r);
  271|      0|    }
  272|       |
  273|       |    /* Correct for the scalar_offset added at the start (ge_offset = b*G, while b was
  274|       |     * subtracted from the input scalar gn). */
  275|  79.1k|    secp256k1_gej_add_ge(r, r, &ctx->ge_offset);
  276|       |
  277|       |    /* Cleanup. */
  278|  79.1k|    secp256k1_fe_clear(&neg);
  279|  79.1k|    secp256k1_ge_clear(&add);
  280|  79.1k|    secp256k1_memclear(&adds, sizeof(adds));
  281|  79.1k|    secp256k1_memclear(&recoded, sizeof(recoded));
  282|  79.1k|}

secp256k1.c:secp256k1_ecmult:
  349|  7.70k|static void secp256k1_ecmult(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {
  350|  7.70k|    secp256k1_fe aux[ECMULT_TABLE_SIZE(WINDOW_A)];
  351|  7.70k|    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];
  352|  7.70k|    struct secp256k1_strauss_point_state ps[1];
  353|  7.70k|    struct secp256k1_strauss_state state;
  354|       |
  355|  7.70k|    state.aux = aux;
  356|  7.70k|    state.pre_a = pre_a;
  357|  7.70k|    state.ps = ps;
  358|  7.70k|    secp256k1_ecmult_strauss_wnaf(&state, r, 1, a, na, ng);
  359|  7.70k|}
secp256k1.c:secp256k1_ecmult_strauss_wnaf:
  237|  7.70k|static void secp256k1_ecmult_strauss_wnaf(const struct secp256k1_strauss_state *state, secp256k1_gej *r, size_t num, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {
  238|  7.70k|    secp256k1_ge tmpa;
  239|  7.70k|    secp256k1_fe Z;
  240|       |    /* Split G factors. */
  241|  7.70k|    secp256k1_scalar ng_1, ng_128;
  242|  7.70k|    int wnaf_ng_1[129];
  243|  7.70k|    int bits_ng_1 = 0;
  244|  7.70k|    int wnaf_ng_128[129];
  245|  7.70k|    int bits_ng_128 = 0;
  246|  7.70k|    int i;
  247|  7.70k|    int bits = 0;
  248|  7.70k|    size_t np;
  249|  7.70k|    size_t no = 0;
  250|       |
  251|  7.70k|    secp256k1_fe_set_int(&Z, 1);
  ------------------
  |  |   83|  7.70k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  252|  15.4k|    for (np = 0; np < num; ++np) {
  ------------------
  |  Branch (252:18): [True: 7.70k, False: 7.70k]
  ------------------
  253|  7.70k|        secp256k1_gej tmp;
  254|  7.70k|        secp256k1_scalar na_1, na_lam;
  255|  7.70k|        if (secp256k1_scalar_is_zero(&na[np]) || secp256k1_gej_is_infinity(&a[np])) {
  ------------------
  |  Branch (255:13): [True: 0, False: 7.70k]
  |  Branch (255:50): [True: 0, False: 7.70k]
  ------------------
  256|      0|            continue;
  257|      0|        }
  258|       |        /* split na into na_1 and na_lam (where na = na_1 + na_lam*lambda, and na_1 and na_lam are ~128 bit) */
  259|  7.70k|        secp256k1_scalar_split_lambda(&na_1, &na_lam, &na[np]);
  260|       |
  261|       |        /* build wnaf representation for na_1 and na_lam. */
  262|  7.70k|        state->ps[no].bits_na_1   = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_1,   129, &na_1,   WINDOW_A);
  ------------------
  |  |   32|  7.70k|#  define WINDOW_A 5
  ------------------
  263|  7.70k|        state->ps[no].bits_na_lam = secp256k1_ecmult_wnaf(state->ps[no].wnaf_na_lam, 129, &na_lam, WINDOW_A);
  ------------------
  |  |   32|  7.70k|#  define WINDOW_A 5
  ------------------
  264|  7.70k|        VERIFY_CHECK(state->ps[no].bits_na_1 <= 129);
  265|  7.70k|        VERIFY_CHECK(state->ps[no].bits_na_lam <= 129);
  266|  7.70k|        if (state->ps[no].bits_na_1 > bits) {
  ------------------
  |  Branch (266:13): [True: 7.70k, False: 0]
  ------------------
  267|  7.70k|            bits = state->ps[no].bits_na_1;
  268|  7.70k|        }
  269|  7.70k|        if (state->ps[no].bits_na_lam > bits) {
  ------------------
  |  Branch (269:13): [True: 3.10k, False: 4.60k]
  ------------------
  270|  3.10k|            bits = state->ps[no].bits_na_lam;
  271|  3.10k|        }
  272|       |
  273|       |        /* Calculate odd multiples of a.
  274|       |         * All multiples are brought to the same Z 'denominator', which is stored
  275|       |         * in Z. Due to secp256k1' isomorphism we can do all operations pretending
  276|       |         * that the Z coordinate was 1, use affine addition formulae, and correct
  277|       |         * the Z coordinate of the result once at the end.
  278|       |         * The exception is the precomputed G table points, which are actually
  279|       |         * affine. Compared to the base used for other points, they have a Z ratio
  280|       |         * of 1/Z, so we can use secp256k1_gej_add_zinv_var, which uses the same
  281|       |         * isomorphism to efficiently add with a known Z inverse.
  282|       |         */
  283|  7.70k|        tmp = a[np];
  284|  7.70k|        if (no) {
  ------------------
  |  Branch (284:13): [True: 0, False: 7.70k]
  ------------------
  285|      0|            secp256k1_gej_rescale(&tmp, &Z);
  286|      0|        }
  287|  7.70k|        secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), state->pre_a + no * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), &Z, &tmp);
  ------------------
  |  |   41|  7.70k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
                      secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), state->pre_a + no * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), &Z, &tmp);
  ------------------
  |  |   41|  7.70k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
                      secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), state->pre_a + no * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), &Z, &tmp);
  ------------------
  |  |   41|  7.70k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
  288|  7.70k|        if (no) secp256k1_fe_mul(state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), &(a[np].z));
  ------------------
  |  |   93|      0|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
                      if (no) secp256k1_fe_mul(state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), &(a[np].z));
  ------------------
  |  |   41|      0|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
                      if (no) secp256k1_fe_mul(state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + no * ECMULT_TABLE_SIZE(WINDOW_A), &(a[np].z));
  ------------------
  |  |   41|      0|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
  |  Branch (288:13): [True: 0, False: 7.70k]
  ------------------
  289|       |
  290|  7.70k|        ++no;
  291|  7.70k|    }
  292|       |
  293|       |    /* Bring them to the same Z denominator. */
  294|  7.70k|    if (no) {
  ------------------
  |  Branch (294:9): [True: 7.70k, False: 0]
  ------------------
  295|  7.70k|        secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A) * no, state->pre_a, state->aux);
  ------------------
  |  |   41|  7.70k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
  296|  7.70k|    }
  297|       |
  298|  15.4k|    for (np = 0; np < no; ++np) {
  ------------------
  |  Branch (298:18): [True: 7.70k, False: 7.70k]
  ------------------
  299|  69.3k|        for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {
  ------------------
  |  |   41|  69.3k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
  |  Branch (299:21): [True: 61.6k, False: 7.70k]
  ------------------
  300|  61.6k|            secp256k1_fe_mul(&state->aux[np * ECMULT_TABLE_SIZE(WINDOW_A) + i], &state->pre_a[np * ECMULT_TABLE_SIZE(WINDOW_A) + i].x, &secp256k1_const_beta);
  ------------------
  |  |   93|  61.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
                          secp256k1_fe_mul(&state->aux[np * ECMULT_TABLE_SIZE(WINDOW_A) + i], &state->pre_a[np * ECMULT_TABLE_SIZE(WINDOW_A) + i].x, &secp256k1_const_beta);
  ------------------
  |  |   41|  61.6k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
                          secp256k1_fe_mul(&state->aux[np * ECMULT_TABLE_SIZE(WINDOW_A) + i], &state->pre_a[np * ECMULT_TABLE_SIZE(WINDOW_A) + i].x, &secp256k1_const_beta);
  ------------------
  |  |   41|  61.6k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
  301|  61.6k|        }
  302|  7.70k|    }
  303|       |
  304|  7.70k|    if (ng) {
  ------------------
  |  Branch (304:9): [True: 7.70k, False: 0]
  ------------------
  305|       |        /* split ng into ng_1 and ng_128 (where gn = gn_1 + gn_128*2^128, and gn_1 and gn_128 are ~128 bit) */
  306|  7.70k|        secp256k1_scalar_split_128(&ng_1, &ng_128, ng);
  307|       |
  308|       |        /* Build wnaf representation for ng_1 and ng_128 */
  309|  7.70k|        bits_ng_1   = secp256k1_ecmult_wnaf(wnaf_ng_1,   129, &ng_1,   WINDOW_G);
  ------------------
  |  |   31|  7.70k|#    define WINDOW_G ECMULT_WINDOW_SIZE
  ------------------
  310|  7.70k|        bits_ng_128 = secp256k1_ecmult_wnaf(wnaf_ng_128, 129, &ng_128, WINDOW_G);
  ------------------
  |  |   31|  7.70k|#    define WINDOW_G ECMULT_WINDOW_SIZE
  ------------------
  311|  7.70k|        if (bits_ng_1 > bits) {
  ------------------
  |  Branch (311:13): [True: 1.86k, False: 5.84k]
  ------------------
  312|  1.86k|            bits = bits_ng_1;
  313|  1.86k|        }
  314|  7.70k|        if (bits_ng_128 > bits) {
  ------------------
  |  Branch (314:13): [True: 1.54k, False: 6.16k]
  ------------------
  315|  1.54k|            bits = bits_ng_128;
  316|  1.54k|        }
  317|  7.70k|    }
  318|       |
  319|  7.70k|    secp256k1_gej_set_infinity(r);
  320|       |
  321|   990k|    for (i = bits - 1; i >= 0; i--) {
  ------------------
  |  Branch (321:24): [True: 982k, False: 7.70k]
  ------------------
  322|   982k|        int n;
  323|   982k|        secp256k1_gej_double_var(r, r, NULL);
  324|  1.96M|        for (np = 0; np < no; ++np) {
  ------------------
  |  Branch (324:22): [True: 982k, False: 982k]
  ------------------
  325|   982k|            if (i < state->ps[np].bits_na_1 && (n = state->ps[np].wnaf_na_1[i])) {
  ------------------
  |  Branch (325:17): [True: 967k, False: 15.0k]
  |  Branch (325:48): [True: 166k, False: 800k]
  ------------------
  326|   166k|                secp256k1_ecmult_table_get_ge(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);
  ------------------
  |  |   41|   166k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
                              secp256k1_ecmult_table_get_ge(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);
  ------------------
  |  |   32|   166k|#  define WINDOW_A 5
  ------------------
  327|   166k|                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);
  328|   166k|            }
  329|   982k|            if (i < state->ps[np].bits_na_lam && (n = state->ps[np].wnaf_na_lam[i])) {
  ------------------
  |  Branch (329:17): [True: 965k, False: 17.1k]
  |  Branch (329:50): [True: 166k, False: 798k]
  ------------------
  330|   166k|                secp256k1_ecmult_table_get_ge_lambda(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);
  ------------------
  |  |   41|   166k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
                              secp256k1_ecmult_table_get_ge_lambda(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);
  ------------------
  |  |   41|   166k|#define ECMULT_TABLE_SIZE(w) (1L << ((w)-2))
  ------------------
                              secp256k1_ecmult_table_get_ge_lambda(&tmpa, state->pre_a + np * ECMULT_TABLE_SIZE(WINDOW_A), state->aux + np * ECMULT_TABLE_SIZE(WINDOW_A), n, WINDOW_A);
  ------------------
  |  |   32|   166k|#  define WINDOW_A 5
  ------------------
  331|   166k|                secp256k1_gej_add_ge_var(r, r, &tmpa, NULL);
  332|   166k|            }
  333|   982k|        }
  334|   982k|        if (i < bits_ng_1 && (n = wnaf_ng_1[i])) {
  ------------------
  |  Branch (334:13): [True: 939k, False: 43.1k]
  |  Branch (334:30): [True: 65.6k, False: 873k]
  ------------------
  335|  65.6k|            secp256k1_ecmult_table_get_ge_storage(&tmpa, secp256k1_pre_g, n, WINDOW_G);
  ------------------
  |  |   31|  65.6k|#    define WINDOW_G ECMULT_WINDOW_SIZE
  ------------------
  336|  65.6k|            secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);
  337|  65.6k|        }
  338|   982k|        if (i < bits_ng_128 && (n = wnaf_ng_128[i])) {
  ------------------
  |  Branch (338:13): [True: 940k, False: 42.3k]
  |  Branch (338:32): [True: 65.6k, False: 874k]
  ------------------
  339|  65.6k|            secp256k1_ecmult_table_get_ge_storage(&tmpa, secp256k1_pre_g_128, n, WINDOW_G);
  ------------------
  |  |   31|  65.6k|#    define WINDOW_G ECMULT_WINDOW_SIZE
  ------------------
  340|  65.6k|            secp256k1_gej_add_zinv_var(r, r, &tmpa, &Z);
  341|  65.6k|        }
  342|   982k|    }
  343|       |
  344|  7.70k|    if (!r->infinity) {
  ------------------
  |  Branch (344:9): [True: 7.70k, False: 0]
  ------------------
  345|  7.70k|        secp256k1_fe_mul(&r->z, &r->z, &Z);
  ------------------
  |  |   93|  7.70k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  346|  7.70k|    }
  347|  7.70k|}
secp256k1.c:secp256k1_ecmult_wnaf:
  162|  30.8k|static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {
  163|  30.8k|    secp256k1_scalar s;
  164|  30.8k|    int last_set_bit = -1;
  165|  30.8k|    int bit = 0;
  166|  30.8k|    int sign = 1;
  167|  30.8k|    int carry = 0;
  168|       |
  169|  30.8k|    VERIFY_CHECK(wnaf != NULL);
  170|  30.8k|    VERIFY_CHECK(0 <= len && len <= 256);
  171|  30.8k|    VERIFY_CHECK(a != NULL);
  172|  30.8k|    VERIFY_CHECK(2 <= w && w <= 31);
  173|       |
  174|  4.00M|    for (bit = 0; bit < len; bit++) {
  ------------------
  |  Branch (174:19): [True: 3.97M, False: 30.8k]
  ------------------
  175|  3.97M|        wnaf[bit] = 0;
  176|  3.97M|    }
  177|       |
  178|  30.8k|    s = *a;
  179|  30.8k|    if (secp256k1_scalar_get_bits_limb32(&s, 255, 1)) {
  ------------------
  |  Branch (179:9): [True: 7.78k, False: 23.0k]
  ------------------
  180|  7.78k|        secp256k1_scalar_negate(&s, &s);
  181|  7.78k|        sign = -1;
  182|  7.78k|    }
  183|       |
  184|  30.8k|    bit = 0;
  185|   963k|    while (bit < len) {
  ------------------
  |  Branch (185:12): [True: 932k, False: 30.8k]
  ------------------
  186|   932k|        int now;
  187|   932k|        int word;
  188|   932k|        if (secp256k1_scalar_get_bits_limb32(&s, bit, 1) == (unsigned int)carry) {
  ------------------
  |  Branch (188:13): [True: 467k, False: 464k]
  ------------------
  189|   467k|            bit++;
  190|   467k|            continue;
  191|   467k|        }
  192|       |
  193|   464k|        now = w;
  194|   464k|        if (now > len - bit) {
  ------------------
  |  Branch (194:13): [True: 20.4k, False: 444k]
  ------------------
  195|  20.4k|            now = len - bit;
  196|  20.4k|        }
  197|       |
  198|   464k|        word = secp256k1_scalar_get_bits_var(&s, bit, now) + carry;
  199|       |
  200|   464k|        carry = (word >> (w-1)) & 1;
  201|   464k|        word -= carry << w;
  202|       |
  203|   464k|        wnaf[bit] = sign * word;
  204|   464k|        last_set_bit = bit;
  205|       |
  206|   464k|        bit += now;
  207|   464k|    }
  208|       |#ifdef VERIFY
  209|       |    {
  210|       |        int verify_bit = bit;
  211|       |
  212|       |        VERIFY_CHECK(carry == 0);
  213|       |
  214|       |        while (verify_bit < 256) {
  215|       |            VERIFY_CHECK(secp256k1_scalar_get_bits_limb32(&s, verify_bit, 1) == 0);
  216|       |            verify_bit++;
  217|       |        }
  218|       |    }
  219|       |#endif
  220|  30.8k|    return last_set_bit + 1;
  221|  30.8k|}
secp256k1.c:secp256k1_ecmult_odd_multiples_table:
   73|  20.3k|static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_ge *pre_a, secp256k1_fe *zr, secp256k1_fe *z, const secp256k1_gej *a) {
   74|  20.3k|    secp256k1_gej d, ai;
   75|  20.3k|    secp256k1_ge d_ge;
   76|  20.3k|    int i;
   77|       |
   78|  20.3k|    VERIFY_CHECK(!a->infinity);
   79|       |
   80|  20.3k|    secp256k1_gej_double_var(&d, a, NULL);
   81|       |
   82|       |    /*
   83|       |     * Perform the additions using an isomorphic curve Y^2 = X^3 + 7*C^6 where C := d.z.
   84|       |     * The isomorphism, phi, maps a secp256k1 point (x, y) to the point (x*C^2, y*C^3) on the other curve.
   85|       |     * In Jacobian coordinates phi maps (x, y, z) to (x*C^2, y*C^3, z) or, equivalently to (x, y, z/C).
   86|       |     *
   87|       |     *     phi(x, y, z) = (x*C^2, y*C^3, z) = (x, y, z/C)
   88|       |     *   d_ge := phi(d) = (d.x, d.y, 1)
   89|       |     *     ai := phi(a) = (a.x*C^2, a.y*C^3, a.z)
   90|       |     *
   91|       |     * The group addition functions work correctly on these isomorphic curves.
   92|       |     * In particular phi(d) is easy to represent in affine coordinates under this isomorphism.
   93|       |     * This lets us use the faster secp256k1_gej_add_ge_var group addition function that we wouldn't be able to use otherwise.
   94|       |     */
   95|  20.3k|    secp256k1_ge_set_xy(&d_ge, &d.x, &d.y);
   96|  20.3k|    secp256k1_ge_set_gej_zinv(&pre_a[0], a, &d.z);
   97|  20.3k|    secp256k1_gej_set_ge(&ai, &pre_a[0]);
   98|  20.3k|    ai.z = a->z;
   99|       |
  100|       |    /* pre_a[0] is the point (a.x*C^2, a.y*C^3, a.z*C) which is equivalent to a.
  101|       |     * Set zr[0] to C, which is the ratio between the omitted z(pre_a[0]) value and a.z.
  102|       |     */
  103|  20.3k|    zr[0] = d.z;
  104|       |
  105|   264k|    for (i = 1; i < n; i++) {
  ------------------
  |  Branch (105:17): [True: 244k, False: 20.3k]
  ------------------
  106|   244k|        secp256k1_gej_add_ge_var(&ai, &ai, &d_ge, &zr[i]);
  107|   244k|        secp256k1_ge_set_xy(&pre_a[i], &ai.x, &ai.y);
  108|   244k|    }
  109|       |
  110|       |    /* Multiply the last z-coordinate by C to undo the isomorphism.
  111|       |     * Since the z-coordinates of the pre_a values are implied by the zr array of z-coordinate ratios,
  112|       |     * undoing the isomorphism here undoes the isomorphism for all pre_a values.
  113|       |     */
  114|  20.3k|    secp256k1_fe_mul(z, &ai.z, &d.z);
  ------------------
  |  |   93|  20.3k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  115|  20.3k|}
secp256k1.c:secp256k1_ecmult_table_get_ge:
  125|   166k|SECP256K1_INLINE static void secp256k1_ecmult_table_get_ge(secp256k1_ge *r, const secp256k1_ge *pre, int n, int w) {
  126|   166k|    secp256k1_ecmult_table_verify(n,w);
  127|   166k|    if (n > 0) {
  ------------------
  |  Branch (127:9): [True: 83.4k, False: 83.3k]
  ------------------
  128|  83.4k|        *r = pre[(n-1)/2];
  129|  83.4k|    } else {
  130|  83.3k|        *r = pre[(-n-1)/2];
  131|  83.3k|        secp256k1_fe_negate(&(r->y), &(r->y), 1);
  ------------------
  |  |  211|  83.3k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  83.3k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  83.3k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 83.3k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  83.3k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 83.3k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  83.3k|    } \
  |  |  |  |   84|  83.3k|    stmt; \
  |  |  |  |   85|  83.3k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 83.3k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  132|  83.3k|    }
  133|   166k|}
secp256k1.c:secp256k1_ecmult_table_verify:
  117|   464k|SECP256K1_INLINE static void secp256k1_ecmult_table_verify(int n, int w) {
  118|   464k|    (void)n;
  119|   464k|    (void)w;
  120|   464k|    VERIFY_CHECK(((n) & 1) == 1);
  121|   464k|    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1));
  122|   464k|    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1));
  123|   464k|}
secp256k1.c:secp256k1_ecmult_table_get_ge_lambda:
  135|   166k|SECP256K1_INLINE static void secp256k1_ecmult_table_get_ge_lambda(secp256k1_ge *r, const secp256k1_ge *pre, const secp256k1_fe *x, int n, int w) {
  136|   166k|    secp256k1_ecmult_table_verify(n,w);
  137|   166k|    if (n > 0) {
  ------------------
  |  Branch (137:9): [True: 83.6k, False: 82.7k]
  ------------------
  138|  83.6k|        secp256k1_ge_set_xy(r, &x[(n-1)/2], &pre[(n-1)/2].y);
  139|  83.6k|    } else {
  140|  82.7k|        secp256k1_ge_set_xy(r, &x[(-n-1)/2], &pre[(-n-1)/2].y);
  141|  82.7k|        secp256k1_fe_negate(&(r->y), &(r->y), 1);
  ------------------
  |  |  211|  82.7k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  82.7k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  82.7k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 82.7k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  82.7k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 82.7k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  82.7k|    } \
  |  |  |  |   84|  82.7k|    stmt; \
  |  |  |  |   85|  82.7k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 82.7k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  142|  82.7k|    }
  143|   166k|}
secp256k1.c:secp256k1_ecmult_table_get_ge_storage:
  145|   131k|SECP256K1_INLINE static void secp256k1_ecmult_table_get_ge_storage(secp256k1_ge *r, const secp256k1_ge_storage *pre, int n, int w) {
  146|   131k|    secp256k1_ecmult_table_verify(n,w);
  147|   131k|    if (n > 0) {
  ------------------
  |  Branch (147:9): [True: 71.9k, False: 59.3k]
  ------------------
  148|  71.9k|        secp256k1_ge_from_storage(r, &pre[(n-1)/2]);
  149|  71.9k|    } else {
  150|  59.3k|        secp256k1_ge_from_storage(r, &pre[(-n-1)/2]);
  151|  59.3k|        secp256k1_fe_negate(&(r->y), &(r->y), 1);
  ------------------
  |  |  211|  59.3k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  59.3k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  59.3k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 59.3k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  59.3k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 59.3k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  59.3k|    } \
  |  |  |  |   84|  59.3k|    stmt; \
  |  |  |  |   85|  59.3k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 59.3k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  152|  59.3k|    }
  153|   131k|}

secp256k1.c:secp256k1_fe_impl_sqr:
  345|  40.2M|SECP256K1_INLINE static void secp256k1_fe_impl_sqr(secp256k1_fe *r, const secp256k1_fe *a) {
  346|  40.2M|    secp256k1_fe_sqr_inner(r->n, a->n);
  347|  40.2M|}
secp256k1.c:secp256k1_fe_impl_mul:
  341|  44.4M|SECP256K1_INLINE static void secp256k1_fe_impl_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp256k1_fe * SECP256K1_RESTRICT b) {
  342|  44.4M|    secp256k1_fe_mul_inner(r->n, a->n, b->n);
  343|  44.4M|}
secp256k1.c:secp256k1_fe_impl_add_int:
  329|  70.8k|SECP256K1_INLINE static void secp256k1_fe_impl_add_int(secp256k1_fe *r, int a) {
  330|  70.8k|    r->n[0] += a;
  331|  70.8k|}
secp256k1.c:secp256k1_fe_impl_to_storage:
  428|   145k|static void secp256k1_fe_impl_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a) {
  429|   145k|    r->n[0] = a->n[0] | a->n[1] << 52;
  430|   145k|    r->n[1] = a->n[1] >> 12 | a->n[2] << 40;
  431|   145k|    r->n[2] = a->n[2] >> 24 | a->n[3] << 28;
  432|   145k|    r->n[3] = a->n[3] >> 36 | a->n[4] << 16;
  433|   145k|}
secp256k1.c:secp256k1_fe_impl_from_storage:
  435|  7.22M|static SECP256K1_INLINE void secp256k1_fe_impl_from_storage(secp256k1_fe *r, const secp256k1_fe_storage *a) {
  436|  7.22M|    r->n[0] = a->n[0] & 0xFFFFFFFFFFFFFULL;
  437|  7.22M|    r->n[1] = a->n[0] >> 52 | ((a->n[1] << 12) & 0xFFFFFFFFFFFFFULL);
  438|  7.22M|    r->n[2] = a->n[1] >> 40 | ((a->n[2] << 24) & 0xFFFFFFFFFFFFFULL);
  439|  7.22M|    r->n[3] = a->n[2] >> 28 | ((a->n[3] << 36) & 0xFFFFFFFFFFFFFULL);
  440|  7.22M|    r->n[4] = a->n[3] >> 16;
  441|  7.22M|}
secp256k1.c:secp256k1_fe_impl_is_zero:
  206|   171k|SECP256K1_INLINE static int secp256k1_fe_impl_is_zero(const secp256k1_fe *a) {
  207|   171k|    const uint64_t *t = a->n;
  208|   171k|    return (t[0] | t[1] | t[2] | t[3] | t[4]) == 0;
  209|   171k|}
secp256k1.c:secp256k1_fe_impl_add:
  333|  43.7M|SECP256K1_INLINE static void secp256k1_fe_impl_add(secp256k1_fe *r, const secp256k1_fe *a) {
  334|  43.7M|    r->n[0] += a->n[0];
  335|  43.7M|    r->n[1] += a->n[1];
  336|  43.7M|    r->n[2] += a->n[2];
  337|  43.7M|    r->n[3] += a->n[3];
  338|  43.7M|    r->n[4] += a->n[4];
  339|  43.7M|}
secp256k1.c:secp256k1_fe_storage_cmov:
  416|   217M|static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag) {
  417|   217M|    uint64_t mask0, mask1;
  418|   217M|    volatile int vflag = flag;
  419|   217M|    SECP256K1_CHECKMEM_CHECK_VERIFY(r->n, sizeof(r->n));
  ------------------
  |  |   99|   217M|#define SECP256K1_CHECKMEM_CHECK_VERIFY(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|   217M|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 217M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  420|   217M|    mask0 = vflag + ~((uint64_t)0);
  421|   217M|    mask1 = ~mask0;
  422|   217M|    r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);
  423|   217M|    r->n[1] = (r->n[1] & mask0) | (a->n[1] & mask1);
  424|   217M|    r->n[2] = (r->n[2] & mask0) | (a->n[2] & mask1);
  425|   217M|    r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);
  426|   217M|}
secp256k1.c:secp256k1_fe_impl_negate_unchecked:
  306|  23.8M|SECP256K1_INLINE static void secp256k1_fe_impl_negate_unchecked(secp256k1_fe *r, const secp256k1_fe *a, int m) {
  307|       |    /* For all legal values of m (0..31), the following properties hold: */
  308|  23.8M|    VERIFY_CHECK(0xFFFFEFFFFFC2FULL * 2 * (m + 1) >= 0xFFFFFFFFFFFFFULL * 2 * m);
  309|  23.8M|    VERIFY_CHECK(0xFFFFFFFFFFFFFULL * 2 * (m + 1) >= 0xFFFFFFFFFFFFFULL * 2 * m);
  310|  23.8M|    VERIFY_CHECK(0x0FFFFFFFFFFFFULL * 2 * (m + 1) >= 0x0FFFFFFFFFFFFULL * 2 * m);
  311|       |
  312|       |    /* Due to the properties above, the left hand in the subtractions below is never less than
  313|       |     * the right hand. */
  314|  23.8M|    r->n[0] = 0xFFFFEFFFFFC2FULL * 2 * (m + 1) - a->n[0];
  315|  23.8M|    r->n[1] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[1];
  316|  23.8M|    r->n[2] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[2];
  317|  23.8M|    r->n[3] = 0xFFFFFFFFFFFFFULL * 2 * (m + 1) - a->n[3];
  318|  23.8M|    r->n[4] = 0x0FFFFFFFFFFFFULL * 2 * (m + 1) - a->n[4];
  319|  23.8M|}
secp256k1.c:secp256k1_fe_impl_cmov:
  349|  48.1M|SECP256K1_INLINE static void secp256k1_fe_impl_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag) {
  350|  48.1M|    uint64_t mask0, mask1;
  351|  48.1M|    volatile int vflag = flag;
  352|  48.1M|    SECP256K1_CHECKMEM_CHECK_VERIFY(r->n, sizeof(r->n));
  ------------------
  |  |   99|  48.1M|#define SECP256K1_CHECKMEM_CHECK_VERIFY(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  48.1M|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 48.1M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  353|  48.1M|    mask0 = vflag + ~((uint64_t)0);
  354|  48.1M|    mask1 = ~mask0;
  355|  48.1M|    r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);
  356|  48.1M|    r->n[1] = (r->n[1] & mask0) | (a->n[1] & mask1);
  357|  48.1M|    r->n[2] = (r->n[2] & mask0) | (a->n[2] & mask1);
  358|  48.1M|    r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);
  359|  48.1M|    r->n[4] = (r->n[4] & mask0) | (a->n[4] & mask1);
  360|  48.1M|}
secp256k1.c:secp256k1_fe_impl_mul_int_unchecked:
  321|  10.7M|SECP256K1_INLINE static void secp256k1_fe_impl_mul_int_unchecked(secp256k1_fe *r, int a) {
  322|  10.7M|    r->n[0] *= a;
  323|  10.7M|    r->n[1] *= a;
  324|  10.7M|    r->n[2] *= a;
  325|  10.7M|    r->n[3] *= a;
  326|  10.7M|    r->n[4] *= a;
  327|  10.7M|}
secp256k1.c:secp256k1_fe_impl_half:
  362|  6.63M|static SECP256K1_INLINE void secp256k1_fe_impl_half(secp256k1_fe *r) {
  363|  6.63M|    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];
  364|  6.63M|    uint64_t one = (uint64_t)1;
  365|  6.63M|    uint64_t mask = -(t0 & one) >> 12;
  366|       |
  367|       |    /* Bounds analysis (over the rationals).
  368|       |     *
  369|       |     * Let m = r->magnitude
  370|       |     *     C = 0xFFFFFFFFFFFFFULL * 2
  371|       |     *     D = 0x0FFFFFFFFFFFFULL * 2
  372|       |     *
  373|       |     * Initial bounds: t0..t3 <= C * m
  374|       |     *                     t4 <= D * m
  375|       |     */
  376|       |
  377|  6.63M|    t0 += 0xFFFFEFFFFFC2FULL & mask;
  378|  6.63M|    t1 += mask;
  379|  6.63M|    t2 += mask;
  380|  6.63M|    t3 += mask;
  381|  6.63M|    t4 += mask >> 4;
  382|       |
  383|  6.63M|    VERIFY_CHECK((t0 & one) == 0);
  384|       |
  385|       |    /* t0..t3: added <= C/2
  386|       |     *     t4: added <= D/2
  387|       |     *
  388|       |     * Current bounds: t0..t3 <= C * (m + 1/2)
  389|       |     *                     t4 <= D * (m + 1/2)
  390|       |     */
  391|       |
  392|  6.63M|    r->n[0] = (t0 >> 1) + ((t1 & one) << 51);
  393|  6.63M|    r->n[1] = (t1 >> 1) + ((t2 & one) << 51);
  394|  6.63M|    r->n[2] = (t2 >> 1) + ((t3 & one) << 51);
  395|  6.63M|    r->n[3] = (t3 >> 1) + ((t4 & one) << 51);
  396|  6.63M|    r->n[4] = (t4 >> 1);
  397|       |
  398|       |    /* t0..t3: shifted right and added <= C/4 + 1/2
  399|       |     *     t4: shifted right
  400|       |     *
  401|       |     * Current bounds: t0..t3 <= C * (m/2 + 1/2)
  402|       |     *                     t4 <= D * (m/2 + 1/4)
  403|       |     *
  404|       |     * Therefore the output magnitude (M) has to be set such that:
  405|       |     *     t0..t3: C * M >= C * (m/2 + 1/2)
  406|       |     *         t4: D * M >= D * (m/2 + 1/4)
  407|       |     *
  408|       |     * It suffices for all limbs that, for any input magnitude m:
  409|       |     *     M >= m/2 + 1/2
  410|       |     *
  411|       |     * and since we want the smallest such integer value for M:
  412|       |     *     M == floor(m/2) + 1
  413|       |     */
  414|  6.63M|}
secp256k1.c:secp256k1_fe_impl_normalize_weak:
   80|   115k|static void secp256k1_fe_impl_normalize_weak(secp256k1_fe *r) {
   81|   115k|    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];
   82|       |
   83|       |    /* Reduce t4 at the start so there will be at most a single carry from the first pass */
   84|   115k|    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;
   85|       |
   86|       |    /* The first pass ensures the magnitude is 1, ... */
   87|   115k|    t0 += x * 0x1000003D1ULL;
   88|   115k|    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;
   89|   115k|    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL;
   90|   115k|    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL;
   91|   115k|    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL;
   92|       |
   93|       |    /* ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element) */
   94|   115k|    VERIFY_CHECK(t4 >> 49 == 0);
   95|       |
   96|   115k|    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;
   97|   115k|}
secp256k1.c:secp256k1_fe_impl_normalizes_to_zero:
  137|  8.13M|static int secp256k1_fe_impl_normalizes_to_zero(const secp256k1_fe *r) {
  138|  8.13M|    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];
  139|       |
  140|       |    /* z0 tracks a possible raw value of 0, z1 tracks a possible raw value of P */
  141|  8.13M|    uint64_t z0, z1;
  142|       |
  143|       |    /* Reduce t4 at the start so there will be at most a single carry from the first pass */
  144|  8.13M|    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;
  145|       |
  146|       |    /* The first pass ensures the magnitude is 1, ... */
  147|  8.13M|    t0 += x * 0x1000003D1ULL;
  148|  8.13M|    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL; z0  = t0; z1  = t0 ^ 0x1000003D0ULL;
  149|  8.13M|    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; z0 |= t1; z1 &= t1;
  150|  8.13M|    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; z0 |= t2; z1 &= t2;
  151|  8.13M|    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; z0 |= t3; z1 &= t3;
  152|  8.13M|                                                z0 |= t4; z1 &= t4 ^ 0xF000000000000ULL;
  153|       |
  154|       |    /* ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element) */
  155|  8.13M|    VERIFY_CHECK(t4 >> 49 == 0);
  156|       |
  157|  8.13M|    return (z0 == 0) | (z1 == 0xFFFFFFFFFFFFFULL);
  158|  8.13M|}
secp256k1.c:secp256k1_fe_impl_set_int:
  201|   281k|SECP256K1_INLINE static void secp256k1_fe_impl_set_int(secp256k1_fe *r, int a) {
  202|   281k|    r->n[0] = a;
  203|   281k|    r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;
  204|   281k|}
secp256k1.c:secp256k1_fe_impl_inv:
  479|  91.8k|static void secp256k1_fe_impl_inv(secp256k1_fe *r, const secp256k1_fe *x) {
  480|  91.8k|    secp256k1_fe tmp = *x;
  481|  91.8k|    secp256k1_modinv64_signed62 s;
  482|       |
  483|  91.8k|    secp256k1_fe_normalize(&tmp);
  ------------------
  |  |   78|  91.8k|#  define secp256k1_fe_normalize secp256k1_fe_impl_normalize
  ------------------
  484|  91.8k|    secp256k1_fe_to_signed62(&s, &tmp);
  485|  91.8k|    secp256k1_modinv64(&s, &secp256k1_const_modinfo_fe);
  486|  91.8k|    secp256k1_fe_from_signed62(r, &s);
  487|  91.8k|}
secp256k1.c:secp256k1_fe_to_signed62:
  463|   210k|static void secp256k1_fe_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_fe *a) {
  464|   210k|    const uint64_t M62 = UINT64_MAX >> 2;
  465|   210k|    const uint64_t a0 = a->n[0], a1 = a->n[1], a2 = a->n[2], a3 = a->n[3], a4 = a->n[4];
  466|       |
  467|   210k|    r->v[0] = (a0       | a1 << 52) & M62;
  468|   210k|    r->v[1] = (a1 >> 10 | a2 << 42) & M62;
  469|   210k|    r->v[2] = (a2 >> 20 | a3 << 32) & M62;
  470|   210k|    r->v[3] = (a3 >> 30 | a4 << 22) & M62;
  471|   210k|    r->v[4] =  a4 >> 40;
  472|   210k|}
secp256k1.c:secp256k1_fe_from_signed62:
  443|   115k|static void secp256k1_fe_from_signed62(secp256k1_fe *r, const secp256k1_modinv64_signed62 *a) {
  444|   115k|    const uint64_t M52 = UINT64_MAX >> 12;
  445|   115k|    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];
  446|       |
  447|       |    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and
  448|       |     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).
  449|       |     */
  450|   115k|    VERIFY_CHECK(a0 >> 62 == 0);
  451|   115k|    VERIFY_CHECK(a1 >> 62 == 0);
  452|   115k|    VERIFY_CHECK(a2 >> 62 == 0);
  453|   115k|    VERIFY_CHECK(a3 >> 62 == 0);
  454|   115k|    VERIFY_CHECK(a4 >> 8 == 0);
  455|       |
  456|   115k|    r->n[0] =  a0                   & M52;
  457|   115k|    r->n[1] = (a0 >> 52 | a1 << 10) & M52;
  458|   115k|    r->n[2] = (a1 >> 42 | a2 << 20) & M52;
  459|   115k|    r->n[3] = (a2 >> 32 | a3 << 30) & M52;
  460|   115k|    r->n[4] = (a3 >> 22 | a4 << 40);
  461|   115k|}
secp256k1.c:secp256k1_fe_impl_set_b32_limit:
  265|  12.0k|static int secp256k1_fe_impl_set_b32_limit(secp256k1_fe *r, const unsigned char *a) {
  266|  12.0k|    secp256k1_fe_impl_set_b32_mod(r, a);
  267|  12.0k|    return !((r->n[4] == 0x0FFFFFFFFFFFFULL) & ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL) & (r->n[0] >= 0xFFFFEFFFFFC2FULL));
  268|  12.0k|}
secp256k1.c:secp256k1_fe_impl_get_b32:
  271|   102k|static void secp256k1_fe_impl_get_b32(unsigned char *r, const secp256k1_fe *a) {
  272|   102k|    r[0] = (a->n[4] >> 40) & 0xFF;
  273|   102k|    r[1] = (a->n[4] >> 32) & 0xFF;
  274|   102k|    r[2] = (a->n[4] >> 24) & 0xFF;
  275|   102k|    r[3] = (a->n[4] >> 16) & 0xFF;
  276|   102k|    r[4] = (a->n[4] >> 8) & 0xFF;
  277|   102k|    r[5] = a->n[4] & 0xFF;
  278|   102k|    r[6] = (a->n[3] >> 44) & 0xFF;
  279|   102k|    r[7] = (a->n[3] >> 36) & 0xFF;
  280|   102k|    r[8] = (a->n[3] >> 28) & 0xFF;
  281|   102k|    r[9] = (a->n[3] >> 20) & 0xFF;
  282|   102k|    r[10] = (a->n[3] >> 12) & 0xFF;
  283|   102k|    r[11] = (a->n[3] >> 4) & 0xFF;
  284|   102k|    r[12] = ((a->n[2] >> 48) & 0xF) | ((a->n[3] & 0xF) << 4);
  285|   102k|    r[13] = (a->n[2] >> 40) & 0xFF;
  286|   102k|    r[14] = (a->n[2] >> 32) & 0xFF;
  287|   102k|    r[15] = (a->n[2] >> 24) & 0xFF;
  288|   102k|    r[16] = (a->n[2] >> 16) & 0xFF;
  289|   102k|    r[17] = (a->n[2] >> 8) & 0xFF;
  290|   102k|    r[18] = a->n[2] & 0xFF;
  291|   102k|    r[19] = (a->n[1] >> 44) & 0xFF;
  292|   102k|    r[20] = (a->n[1] >> 36) & 0xFF;
  293|   102k|    r[21] = (a->n[1] >> 28) & 0xFF;
  294|   102k|    r[22] = (a->n[1] >> 20) & 0xFF;
  295|   102k|    r[23] = (a->n[1] >> 12) & 0xFF;
  296|   102k|    r[24] = (a->n[1] >> 4) & 0xFF;
  297|   102k|    r[25] = ((a->n[0] >> 48) & 0xF) | ((a->n[1] & 0xF) << 4);
  298|   102k|    r[26] = (a->n[0] >> 40) & 0xFF;
  299|   102k|    r[27] = (a->n[0] >> 32) & 0xFF;
  300|   102k|    r[28] = (a->n[0] >> 24) & 0xFF;
  301|   102k|    r[29] = (a->n[0] >> 16) & 0xFF;
  302|   102k|    r[30] = (a->n[0] >> 8) & 0xFF;
  303|   102k|    r[31] = a->n[0] & 0xFF;
  304|   102k|}
secp256k1.c:secp256k1_fe_impl_normalize_var:
   99|   313k|static void secp256k1_fe_impl_normalize_var(secp256k1_fe *r) {
  100|   313k|    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];
  101|       |
  102|       |    /* Reduce t4 at the start so there will be at most a single carry from the first pass */
  103|   313k|    uint64_t m;
  104|   313k|    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;
  105|       |
  106|       |    /* The first pass ensures the magnitude is 1, ... */
  107|   313k|    t0 += x * 0x1000003D1ULL;
  108|   313k|    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;
  109|   313k|    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; m = t1;
  110|   313k|    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; m &= t2;
  111|   313k|    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; m &= t3;
  112|       |
  113|       |    /* ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element) */
  114|   313k|    VERIFY_CHECK(t4 >> 49 == 0);
  115|       |
  116|       |    /* At most a single final reduction is needed; check if the value is >= the field characteristic */
  117|   313k|    x = (t4 >> 48) | ((t4 == 0x0FFFFFFFFFFFFULL) & (m == 0xFFFFFFFFFFFFFULL)
  118|   313k|        & (t0 >= 0xFFFFEFFFFFC2FULL));
  119|       |
  120|   313k|    if (x) {
  ------------------
  |  Branch (120:9): [True: 0, False: 313k]
  ------------------
  121|      0|        t0 += 0x1000003D1ULL;
  122|      0|        t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;
  123|      0|        t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL;
  124|      0|        t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL;
  125|      0|        t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL;
  126|       |
  127|       |        /* If t4 didn't carry to bit 48 already, then it should have after any final reduction */
  128|      0|        VERIFY_CHECK(t4 >> 48 == x);
  129|       |
  130|       |        /* Mask off the possible multiple of 2^256 from the final reduction */
  131|      0|        t4 &= 0x0FFFFFFFFFFFFULL;
  132|      0|    }
  133|       |
  134|   313k|    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;
  135|   313k|}
secp256k1.c:secp256k1_fe_impl_is_odd:
  211|   115k|SECP256K1_INLINE static int secp256k1_fe_impl_is_odd(const secp256k1_fe *a) {
  212|   115k|    return a->n[0] & 1;
  213|   115k|}
secp256k1.c:secp256k1_fe_impl_normalizes_to_zero_var:
  160|   756k|static int secp256k1_fe_impl_normalizes_to_zero_var(const secp256k1_fe *r) {
  161|   756k|    uint64_t t0, t1, t2, t3, t4;
  162|   756k|    uint64_t z0, z1;
  163|   756k|    uint64_t x;
  164|       |
  165|   756k|    t0 = r->n[0];
  166|   756k|    t4 = r->n[4];
  167|       |
  168|       |    /* Reduce t4 at the start so there will be at most a single carry from the first pass */
  169|   756k|    x = t4 >> 48;
  170|       |
  171|       |    /* The first pass ensures the magnitude is 1, ... */
  172|   756k|    t0 += x * 0x1000003D1ULL;
  173|       |
  174|       |    /* z0 tracks a possible raw value of 0, z1 tracks a possible raw value of P */
  175|   756k|    z0 = t0 & 0xFFFFFFFFFFFFFULL;
  176|   756k|    z1 = z0 ^ 0x1000003D0ULL;
  177|       |
  178|       |    /* Fast return path should catch the majority of cases */
  179|   756k|    if ((z0 != 0ULL) & (z1 != 0xFFFFFFFFFFFFFULL)) {
  ------------------
  |  Branch (179:9): [True: 756k, False: 0]
  ------------------
  180|   756k|        return 0;
  181|   756k|    }
  182|       |
  183|      0|    t1 = r->n[1];
  184|      0|    t2 = r->n[2];
  185|      0|    t3 = r->n[3];
  186|       |
  187|      0|    t4 &= 0x0FFFFFFFFFFFFULL;
  188|       |
  189|      0|    t1 += (t0 >> 52);
  190|      0|    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; z0 |= t1; z1 &= t1;
  191|      0|    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; z0 |= t2; z1 &= t2;
  192|      0|    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; z0 |= t3; z1 &= t3;
  193|      0|                                                z0 |= t4; z1 &= t4 ^ 0xF000000000000ULL;
  194|       |
  195|       |    /* ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element) */
  196|      0|    VERIFY_CHECK(t4 >> 49 == 0);
  197|       |
  198|      0|    return (z0 == 0) | (z1 == 0xFFFFFFFFFFFFFULL);
  199|   756k|}
secp256k1.c:secp256k1_fe_impl_inv_var:
  489|  23.7k|static void secp256k1_fe_impl_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {
  490|  23.7k|    secp256k1_fe tmp = *x;
  491|  23.7k|    secp256k1_modinv64_signed62 s;
  492|       |
  493|  23.7k|    secp256k1_fe_normalize_var(&tmp);
  ------------------
  |  |   80|  23.7k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  494|  23.7k|    secp256k1_fe_to_signed62(&s, &tmp);
  495|  23.7k|    secp256k1_modinv64_var(&s, &secp256k1_const_modinfo_fe);
  496|  23.7k|    secp256k1_fe_from_signed62(r, &s);
  497|  23.7k|}
secp256k1.c:secp256k1_fe_impl_is_square_var:
  499|  95.2k|static int secp256k1_fe_impl_is_square_var(const secp256k1_fe *x) {
  500|  95.2k|    secp256k1_fe tmp;
  501|  95.2k|    secp256k1_modinv64_signed62 s;
  502|  95.2k|    int jac, ret;
  503|       |
  504|  95.2k|    tmp = *x;
  505|  95.2k|    secp256k1_fe_normalize_var(&tmp);
  ------------------
  |  |   80|  95.2k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  506|       |    /* secp256k1_jacobi64_maybe_var cannot deal with input 0. */
  507|  95.2k|    if (secp256k1_fe_is_zero(&tmp)) return 1;
  ------------------
  |  |   84|  95.2k|#  define secp256k1_fe_is_zero secp256k1_fe_impl_is_zero
  ------------------
  |  Branch (507:9): [True: 0, False: 95.2k]
  ------------------
  508|  95.2k|    secp256k1_fe_to_signed62(&s, &tmp);
  509|  95.2k|    jac = secp256k1_jacobi64_maybe_var(&s, &secp256k1_const_modinfo_fe);
  510|  95.2k|    if (jac == 0) {
  ------------------
  |  Branch (510:9): [True: 0, False: 95.2k]
  ------------------
  511|       |        /* secp256k1_jacobi64_maybe_var failed to compute the Jacobi symbol. Fall back
  512|       |         * to computing a square root. This should be extremely rare with random
  513|       |         * input (except in VERIFY mode, where a lower iteration count is used). */
  514|      0|        secp256k1_fe dummy;
  515|      0|        ret = secp256k1_fe_sqrt(&dummy, &tmp);
  516|  95.2k|    } else {
  517|  95.2k|        ret = jac >= 0;
  518|  95.2k|    }
  519|  95.2k|    return ret;
  520|  95.2k|}
secp256k1.c:secp256k1_fe_impl_set_b32_mod:
  228|  90.1k|static void secp256k1_fe_impl_set_b32_mod(secp256k1_fe *r, const unsigned char *a) {
  229|  90.1k|    r->n[0] = (uint64_t)a[31]
  230|  90.1k|            | ((uint64_t)a[30] << 8)
  231|  90.1k|            | ((uint64_t)a[29] << 16)
  232|  90.1k|            | ((uint64_t)a[28] << 24)
  233|  90.1k|            | ((uint64_t)a[27] << 32)
  234|  90.1k|            | ((uint64_t)a[26] << 40)
  235|  90.1k|            | ((uint64_t)(a[25] & 0xF)  << 48);
  236|  90.1k|    r->n[1] = (uint64_t)((a[25] >> 4) & 0xF)
  237|  90.1k|            | ((uint64_t)a[24] << 4)
  238|  90.1k|            | ((uint64_t)a[23] << 12)
  239|  90.1k|            | ((uint64_t)a[22] << 20)
  240|  90.1k|            | ((uint64_t)a[21] << 28)
  241|  90.1k|            | ((uint64_t)a[20] << 36)
  242|  90.1k|            | ((uint64_t)a[19] << 44);
  243|  90.1k|    r->n[2] = (uint64_t)a[18]
  244|  90.1k|            | ((uint64_t)a[17] << 8)
  245|  90.1k|            | ((uint64_t)a[16] << 16)
  246|  90.1k|            | ((uint64_t)a[15] << 24)
  247|  90.1k|            | ((uint64_t)a[14] << 32)
  248|  90.1k|            | ((uint64_t)a[13] << 40)
  249|  90.1k|            | ((uint64_t)(a[12] & 0xF) << 48);
  250|  90.1k|    r->n[3] = (uint64_t)((a[12] >> 4) & 0xF)
  251|  90.1k|            | ((uint64_t)a[11] << 4)
  252|  90.1k|            | ((uint64_t)a[10] << 12)
  253|  90.1k|            | ((uint64_t)a[9]  << 20)
  254|  90.1k|            | ((uint64_t)a[8]  << 28)
  255|  90.1k|            | ((uint64_t)a[7]  << 36)
  256|  90.1k|            | ((uint64_t)a[6]  << 44);
  257|  90.1k|    r->n[4] = (uint64_t)a[5]
  258|  90.1k|            | ((uint64_t)a[4] << 8)
  259|  90.1k|            | ((uint64_t)a[3] << 16)
  260|  90.1k|            | ((uint64_t)a[2] << 24)
  261|  90.1k|            | ((uint64_t)a[1] << 32)
  262|  90.1k|            | ((uint64_t)a[0] << 40);
  263|  90.1k|}
secp256k1.c:secp256k1_fe_impl_normalize:
   43|   249k|static void secp256k1_fe_impl_normalize(secp256k1_fe *r) {
   44|   249k|    uint64_t t0 = r->n[0], t1 = r->n[1], t2 = r->n[2], t3 = r->n[3], t4 = r->n[4];
   45|       |
   46|       |    /* Reduce t4 at the start so there will be at most a single carry from the first pass */
   47|   249k|    uint64_t m;
   48|   249k|    uint64_t x = t4 >> 48; t4 &= 0x0FFFFFFFFFFFFULL;
   49|       |
   50|       |    /* The first pass ensures the magnitude is 1, ... */
   51|   249k|    t0 += x * 0x1000003D1ULL;
   52|   249k|    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;
   53|   249k|    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL; m = t1;
   54|   249k|    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL; m &= t2;
   55|   249k|    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL; m &= t3;
   56|       |
   57|       |    /* ... except for a possible carry at bit 48 of t4 (i.e. bit 256 of the field element) */
   58|   249k|    VERIFY_CHECK(t4 >> 49 == 0);
   59|       |
   60|       |    /* At most a single final reduction is needed; check if the value is >= the field characteristic */
   61|   249k|    x = (t4 >> 48) | ((t4 == 0x0FFFFFFFFFFFFULL) & (m == 0xFFFFFFFFFFFFFULL)
   62|   249k|        & (t0 >= 0xFFFFEFFFFFC2FULL));
   63|       |
   64|       |    /* Apply the final reduction (for constant-time behaviour, we do it always) */
   65|   249k|    t0 += x * 0x1000003D1ULL;
   66|   249k|    t1 += (t0 >> 52); t0 &= 0xFFFFFFFFFFFFFULL;
   67|   249k|    t2 += (t1 >> 52); t1 &= 0xFFFFFFFFFFFFFULL;
   68|   249k|    t3 += (t2 >> 52); t2 &= 0xFFFFFFFFFFFFFULL;
   69|   249k|    t4 += (t3 >> 52); t3 &= 0xFFFFFFFFFFFFFULL;
   70|       |
   71|       |    /* If t4 didn't carry to bit 48 already, then it should have after any final reduction */
   72|   249k|    VERIFY_CHECK(t4 >> 48 == x);
   73|       |
   74|       |    /* Mask off the possible multiple of 2^256 from the final reduction */
   75|   249k|    t4 &= 0x0FFFFFFFFFFFFULL;
   76|       |
   77|   249k|    r->n[0] = t0; r->n[1] = t1; r->n[2] = t2; r->n[3] = t3; r->n[4] = t4;
   78|   249k|}

secp256k1.c:secp256k1_fe_sqr_inner:
  154|  40.2M|SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t *a) {
  155|  40.2M|    secp256k1_uint128 c, d;
  156|  40.2M|    uint64_t a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4];
  157|  40.2M|    uint64_t t3, t4, tx, u0;
  158|  40.2M|    const uint64_t M = 0xFFFFFFFFFFFFFULL, R = 0x1000003D10ULL;
  159|       |
  160|  40.2M|    VERIFY_BITS(a[0], 56);
  161|  40.2M|    VERIFY_BITS(a[1], 56);
  162|  40.2M|    VERIFY_BITS(a[2], 56);
  163|  40.2M|    VERIFY_BITS(a[3], 56);
  164|  40.2M|    VERIFY_BITS(a[4], 52);
  165|       |
  166|       |    /**  [... a b c] is a shorthand for ... + a<<104 + b<<52 + c<<0 mod n.
  167|       |     *  px is a shorthand for sum(a[i]*a[x-i], i=0..x).
  168|       |     *  Note that [x 0 0 0 0 0] = [x*R].
  169|       |     */
  170|       |
  171|  40.2M|    secp256k1_u128_mul(&d, a0*2, a3);
  172|  40.2M|    secp256k1_u128_accum_mul(&d, a1*2, a2);
  173|  40.2M|    VERIFY_BITS_128(&d, 114);
  174|       |    /* [d 0 0 0] = [p3 0 0 0] */
  175|  40.2M|    secp256k1_u128_mul(&c, a4, a4);
  176|  40.2M|    VERIFY_BITS_128(&c, 112);
  177|       |    /* [c 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */
  178|  40.2M|    secp256k1_u128_accum_mul(&d, R, secp256k1_u128_to_u64(&c)); secp256k1_u128_rshift(&c, 64);
  179|  40.2M|    VERIFY_BITS_128(&d, 115);
  180|  40.2M|    VERIFY_BITS_128(&c, 48);
  181|       |    /* [(c<<12) 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */
  182|  40.2M|    t3 = secp256k1_u128_to_u64(&d) & M; secp256k1_u128_rshift(&d, 52);
  183|  40.2M|    VERIFY_BITS(t3, 52);
  184|  40.2M|    VERIFY_BITS_128(&d, 63);
  185|       |    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */
  186|       |
  187|  40.2M|    a4 *= 2;
  188|  40.2M|    secp256k1_u128_accum_mul(&d, a0, a4);
  189|  40.2M|    secp256k1_u128_accum_mul(&d, a1*2, a3);
  190|  40.2M|    secp256k1_u128_accum_mul(&d, a2, a2);
  191|  40.2M|    VERIFY_BITS_128(&d, 115);
  192|       |    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
  193|  40.2M|    secp256k1_u128_accum_mul(&d, R << 12, secp256k1_u128_to_u64(&c));
  194|  40.2M|    VERIFY_BITS_128(&d, 116);
  195|       |    /* [d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
  196|  40.2M|    t4 = secp256k1_u128_to_u64(&d) & M; secp256k1_u128_rshift(&d, 52);
  197|  40.2M|    VERIFY_BITS(t4, 52);
  198|  40.2M|    VERIFY_BITS_128(&d, 64);
  199|       |    /* [d t4 t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
  200|  40.2M|    tx = (t4 >> 48); t4 &= (M >> 4);
  201|  40.2M|    VERIFY_BITS(tx, 4);
  202|  40.2M|    VERIFY_BITS(t4, 48);
  203|       |    /* [d t4+(tx<<48) t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
  204|       |
  205|  40.2M|    secp256k1_u128_mul(&c, a0, a0);
  206|  40.2M|    VERIFY_BITS_128(&c, 112);
  207|       |    /* [d t4+(tx<<48) t3 0 0 c] = [p8 0 0 0 p4 p3 0 0 p0] */
  208|  40.2M|    secp256k1_u128_accum_mul(&d, a1, a4);
  209|  40.2M|    secp256k1_u128_accum_mul(&d, a2*2, a3);
  210|  40.2M|    VERIFY_BITS_128(&d, 114);
  211|       |    /* [d t4+(tx<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
  212|  40.2M|    u0 = secp256k1_u128_to_u64(&d) & M; secp256k1_u128_rshift(&d, 52);
  213|  40.2M|    VERIFY_BITS(u0, 52);
  214|  40.2M|    VERIFY_BITS_128(&d, 62);
  215|       |    /* [d u0 t4+(tx<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
  216|       |    /* [d 0 t4+(tx<<48)+(u0<<52) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
  217|  40.2M|    u0 = (u0 << 4) | tx;
  218|  40.2M|    VERIFY_BITS(u0, 56);
  219|       |    /* [d 0 t4+(u0<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
  220|  40.2M|    secp256k1_u128_accum_mul(&c, u0, R >> 4);
  221|  40.2M|    VERIFY_BITS_128(&c, 113);
  222|       |    /* [d 0 t4 t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
  223|  40.2M|    r[0] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  224|  40.2M|    VERIFY_BITS(r[0], 52);
  225|  40.2M|    VERIFY_BITS_128(&c, 61);
  226|       |    /* [d 0 t4 t3 0 c r0] = [p8 0 0 p5 p4 p3 0 0 p0] */
  227|       |
  228|  40.2M|    a0 *= 2;
  229|  40.2M|    secp256k1_u128_accum_mul(&c, a0, a1);
  230|  40.2M|    VERIFY_BITS_128(&c, 114);
  231|       |    /* [d 0 t4 t3 0 c r0] = [p8 0 0 p5 p4 p3 0 p1 p0] */
  232|  40.2M|    secp256k1_u128_accum_mul(&d, a2, a4);
  233|  40.2M|    secp256k1_u128_accum_mul(&d, a3, a3);
  234|  40.2M|    VERIFY_BITS_128(&d, 114);
  235|       |    /* [d 0 t4 t3 0 c r0] = [p8 0 p6 p5 p4 p3 0 p1 p0] */
  236|  40.2M|    secp256k1_u128_accum_mul(&c, secp256k1_u128_to_u64(&d) & M, R); secp256k1_u128_rshift(&d, 52);
  237|  40.2M|    VERIFY_BITS_128(&c, 115);
  238|  40.2M|    VERIFY_BITS_128(&d, 62);
  239|       |    /* [d 0 0 t4 t3 0 c r0] = [p8 0 p6 p5 p4 p3 0 p1 p0] */
  240|  40.2M|    r[1] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  241|  40.2M|    VERIFY_BITS(r[1], 52);
  242|  40.2M|    VERIFY_BITS_128(&c, 63);
  243|       |    /* [d 0 0 t4 t3 c r1 r0] = [p8 0 p6 p5 p4 p3 0 p1 p0] */
  244|       |
  245|  40.2M|    secp256k1_u128_accum_mul(&c, a0, a2);
  246|  40.2M|    secp256k1_u128_accum_mul(&c, a1, a1);
  247|  40.2M|    VERIFY_BITS_128(&c, 114);
  248|       |    /* [d 0 0 t4 t3 c r1 r0] = [p8 0 p6 p5 p4 p3 p2 p1 p0] */
  249|  40.2M|    secp256k1_u128_accum_mul(&d, a3, a4);
  250|  40.2M|    VERIFY_BITS_128(&d, 114);
  251|       |    /* [d 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  252|  40.2M|    secp256k1_u128_accum_mul(&c, R, secp256k1_u128_to_u64(&d)); secp256k1_u128_rshift(&d, 64);
  253|  40.2M|    VERIFY_BITS_128(&c, 115);
  254|  40.2M|    VERIFY_BITS_128(&d, 50);
  255|       |    /* [(d<<12) 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  256|  40.2M|    r[2] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  257|  40.2M|    VERIFY_BITS(r[2], 52);
  258|  40.2M|    VERIFY_BITS_128(&c, 63);
  259|       |    /* [(d<<12) 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  260|       |
  261|  40.2M|    secp256k1_u128_accum_mul(&c, R << 12, secp256k1_u128_to_u64(&d));
  262|  40.2M|    secp256k1_u128_accum_u64(&c, t3);
  263|  40.2M|    VERIFY_BITS_128(&c, 100);
  264|       |    /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  265|  40.2M|    r[3] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  266|  40.2M|    VERIFY_BITS(r[3], 52);
  267|  40.2M|    VERIFY_BITS_128(&c, 48);
  268|       |    /* [t4+c r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  269|  40.2M|    r[4] = secp256k1_u128_to_u64(&c) + t4;
  270|  40.2M|    VERIFY_BITS(r[4], 49);
  271|       |    /* [r4 r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  272|  40.2M|}
secp256k1.c:secp256k1_fe_mul_inner:
   18|  44.4M|SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t *a, const uint64_t * SECP256K1_RESTRICT b) {
   19|  44.4M|    secp256k1_uint128 c, d;
   20|  44.4M|    uint64_t t3, t4, tx, u0;
   21|  44.4M|    uint64_t a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4];
   22|  44.4M|    const uint64_t M = 0xFFFFFFFFFFFFFULL, R = 0x1000003D10ULL;
   23|       |
   24|  44.4M|    VERIFY_BITS(a[0], 56);
   25|  44.4M|    VERIFY_BITS(a[1], 56);
   26|  44.4M|    VERIFY_BITS(a[2], 56);
   27|  44.4M|    VERIFY_BITS(a[3], 56);
   28|  44.4M|    VERIFY_BITS(a[4], 52);
   29|  44.4M|    VERIFY_BITS(b[0], 56);
   30|  44.4M|    VERIFY_BITS(b[1], 56);
   31|  44.4M|    VERIFY_BITS(b[2], 56);
   32|  44.4M|    VERIFY_BITS(b[3], 56);
   33|  44.4M|    VERIFY_BITS(b[4], 52);
   34|  44.4M|    VERIFY_CHECK(r != b);
   35|  44.4M|    VERIFY_CHECK(a != b);
   36|       |
   37|       |    /*  [... a b c] is a shorthand for ... + a<<104 + b<<52 + c<<0 mod n.
   38|       |     *  for 0 <= x <= 4, px is a shorthand for sum(a[i]*b[x-i], i=0..x).
   39|       |     *  for 4 <= x <= 8, px is a shorthand for sum(a[i]*b[x-i], i=(x-4)..4)
   40|       |     *  Note that [x 0 0 0 0 0] = [x*R].
   41|       |     */
   42|       |
   43|  44.4M|    secp256k1_u128_mul(&d, a0, b[3]);
   44|  44.4M|    secp256k1_u128_accum_mul(&d, a1, b[2]);
   45|  44.4M|    secp256k1_u128_accum_mul(&d, a2, b[1]);
   46|  44.4M|    secp256k1_u128_accum_mul(&d, a3, b[0]);
   47|  44.4M|    VERIFY_BITS_128(&d, 114);
   48|       |    /* [d 0 0 0] = [p3 0 0 0] */
   49|  44.4M|    secp256k1_u128_mul(&c, a4, b[4]);
   50|  44.4M|    VERIFY_BITS_128(&c, 112);
   51|       |    /* [c 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */
   52|  44.4M|    secp256k1_u128_accum_mul(&d, R, secp256k1_u128_to_u64(&c)); secp256k1_u128_rshift(&c, 64);
   53|  44.4M|    VERIFY_BITS_128(&d, 115);
   54|  44.4M|    VERIFY_BITS_128(&c, 48);
   55|       |    /* [(c<<12) 0 0 0 0 0 d 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */
   56|  44.4M|    t3 = secp256k1_u128_to_u64(&d) & M; secp256k1_u128_rshift(&d, 52);
   57|  44.4M|    VERIFY_BITS(t3, 52);
   58|  44.4M|    VERIFY_BITS_128(&d, 63);
   59|       |    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 0 p3 0 0 0] */
   60|       |
   61|  44.4M|    secp256k1_u128_accum_mul(&d, a0, b[4]);
   62|  44.4M|    secp256k1_u128_accum_mul(&d, a1, b[3]);
   63|  44.4M|    secp256k1_u128_accum_mul(&d, a2, b[2]);
   64|  44.4M|    secp256k1_u128_accum_mul(&d, a3, b[1]);
   65|  44.4M|    secp256k1_u128_accum_mul(&d, a4, b[0]);
   66|  44.4M|    VERIFY_BITS_128(&d, 115);
   67|       |    /* [(c<<12) 0 0 0 0 d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
   68|  44.4M|    secp256k1_u128_accum_mul(&d, R << 12, secp256k1_u128_to_u64(&c));
   69|  44.4M|    VERIFY_BITS_128(&d, 116);
   70|       |    /* [d t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
   71|  44.4M|    t4 = secp256k1_u128_to_u64(&d) & M; secp256k1_u128_rshift(&d, 52);
   72|  44.4M|    VERIFY_BITS(t4, 52);
   73|  44.4M|    VERIFY_BITS_128(&d, 64);
   74|       |    /* [d t4 t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
   75|  44.4M|    tx = (t4 >> 48); t4 &= (M >> 4);
   76|  44.4M|    VERIFY_BITS(tx, 4);
   77|  44.4M|    VERIFY_BITS(t4, 48);
   78|       |    /* [d t4+(tx<<48) t3 0 0 0] = [p8 0 0 0 p4 p3 0 0 0] */
   79|       |
   80|  44.4M|    secp256k1_u128_mul(&c, a0, b[0]);
   81|  44.4M|    VERIFY_BITS_128(&c, 112);
   82|       |    /* [d t4+(tx<<48) t3 0 0 c] = [p8 0 0 0 p4 p3 0 0 p0] */
   83|  44.4M|    secp256k1_u128_accum_mul(&d, a1, b[4]);
   84|  44.4M|    secp256k1_u128_accum_mul(&d, a2, b[3]);
   85|  44.4M|    secp256k1_u128_accum_mul(&d, a3, b[2]);
   86|  44.4M|    secp256k1_u128_accum_mul(&d, a4, b[1]);
   87|  44.4M|    VERIFY_BITS_128(&d, 114);
   88|       |    /* [d t4+(tx<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
   89|  44.4M|    u0 = secp256k1_u128_to_u64(&d) & M; secp256k1_u128_rshift(&d, 52);
   90|  44.4M|    VERIFY_BITS(u0, 52);
   91|  44.4M|    VERIFY_BITS_128(&d, 62);
   92|       |    /* [d u0 t4+(tx<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
   93|       |    /* [d 0 t4+(tx<<48)+(u0<<52) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
   94|  44.4M|    u0 = (u0 << 4) | tx;
   95|  44.4M|    VERIFY_BITS(u0, 56);
   96|       |    /* [d 0 t4+(u0<<48) t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
   97|  44.4M|    secp256k1_u128_accum_mul(&c, u0, R >> 4);
   98|  44.4M|    VERIFY_BITS_128(&c, 113);
   99|       |    /* [d 0 t4 t3 0 0 c] = [p8 0 0 p5 p4 p3 0 0 p0] */
  100|  44.4M|    r[0] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  101|  44.4M|    VERIFY_BITS(r[0], 52);
  102|  44.4M|    VERIFY_BITS_128(&c, 61);
  103|       |    /* [d 0 t4 t3 0 c r0] = [p8 0 0 p5 p4 p3 0 0 p0] */
  104|       |
  105|  44.4M|    secp256k1_u128_accum_mul(&c, a0, b[1]);
  106|  44.4M|    secp256k1_u128_accum_mul(&c, a1, b[0]);
  107|  44.4M|    VERIFY_BITS_128(&c, 114);
  108|       |    /* [d 0 t4 t3 0 c r0] = [p8 0 0 p5 p4 p3 0 p1 p0] */
  109|  44.4M|    secp256k1_u128_accum_mul(&d, a2, b[4]);
  110|  44.4M|    secp256k1_u128_accum_mul(&d, a3, b[3]);
  111|  44.4M|    secp256k1_u128_accum_mul(&d, a4, b[2]);
  112|  44.4M|    VERIFY_BITS_128(&d, 114);
  113|       |    /* [d 0 t4 t3 0 c r0] = [p8 0 p6 p5 p4 p3 0 p1 p0] */
  114|  44.4M|    secp256k1_u128_accum_mul(&c, secp256k1_u128_to_u64(&d) & M, R); secp256k1_u128_rshift(&d, 52);
  115|  44.4M|    VERIFY_BITS_128(&c, 115);
  116|  44.4M|    VERIFY_BITS_128(&d, 62);
  117|       |    /* [d 0 0 t4 t3 0 c r0] = [p8 0 p6 p5 p4 p3 0 p1 p0] */
  118|  44.4M|    r[1] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  119|  44.4M|    VERIFY_BITS(r[1], 52);
  120|  44.4M|    VERIFY_BITS_128(&c, 63);
  121|       |    /* [d 0 0 t4 t3 c r1 r0] = [p8 0 p6 p5 p4 p3 0 p1 p0] */
  122|       |
  123|  44.4M|    secp256k1_u128_accum_mul(&c, a0, b[2]);
  124|  44.4M|    secp256k1_u128_accum_mul(&c, a1, b[1]);
  125|  44.4M|    secp256k1_u128_accum_mul(&c, a2, b[0]);
  126|  44.4M|    VERIFY_BITS_128(&c, 114);
  127|       |    /* [d 0 0 t4 t3 c r1 r0] = [p8 0 p6 p5 p4 p3 p2 p1 p0] */
  128|  44.4M|    secp256k1_u128_accum_mul(&d, a3, b[4]);
  129|  44.4M|    secp256k1_u128_accum_mul(&d, a4, b[3]);
  130|  44.4M|    VERIFY_BITS_128(&d, 114);
  131|       |    /* [d 0 0 t4 t3 c t1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  132|  44.4M|    secp256k1_u128_accum_mul(&c, R, secp256k1_u128_to_u64(&d)); secp256k1_u128_rshift(&d, 64);
  133|  44.4M|    VERIFY_BITS_128(&c, 115);
  134|  44.4M|    VERIFY_BITS_128(&d, 50);
  135|       |    /* [(d<<12) 0 0 0 t4 t3 c r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  136|       |
  137|  44.4M|    r[2] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  138|  44.4M|    VERIFY_BITS(r[2], 52);
  139|  44.4M|    VERIFY_BITS_128(&c, 63);
  140|       |    /* [(d<<12) 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  141|  44.4M|    secp256k1_u128_accum_mul(&c, R << 12, secp256k1_u128_to_u64(&d));
  142|  44.4M|    secp256k1_u128_accum_u64(&c, t3);
  143|  44.4M|    VERIFY_BITS_128(&c, 100);
  144|       |    /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  145|  44.4M|    r[3] = secp256k1_u128_to_u64(&c) & M; secp256k1_u128_rshift(&c, 52);
  146|  44.4M|    VERIFY_BITS(r[3], 52);
  147|  44.4M|    VERIFY_BITS_128(&c, 48);
  148|       |    /* [t4+c r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  149|  44.4M|    r[4] = secp256k1_u128_to_u64(&c) + t4;
  150|  44.4M|    VERIFY_BITS(r[4], 49);
  151|       |    /* [r4 r3 r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */
  152|  44.4M|}

secp256k1.c:secp256k1_fe_verify:
  149|  73.5M|static void secp256k1_fe_verify(const secp256k1_fe *a) { (void)a; }
secp256k1.c:secp256k1_fe_verify_magnitude:
  150|  71.9M|static void secp256k1_fe_verify_magnitude(const secp256k1_fe *a, int m) { (void)a; (void)m; }
secp256k1.c:secp256k1_fe_sqrt:
   37|  27.1k|static int secp256k1_fe_sqrt(secp256k1_fe * SECP256K1_RESTRICT r, const secp256k1_fe * SECP256K1_RESTRICT a) {
   38|       |    /** Given that p is congruent to 3 mod 4, we can compute the square root of
   39|       |     *  a mod p as the (p+1)/4'th power of a.
   40|       |     *
   41|       |     *  As (p+1)/4 is an even number, it will have the same result for a and for
   42|       |     *  (-a). Only one of these two numbers actually has a square root however,
   43|       |     *  so we test at the end by squaring and comparing to the input.
   44|       |     *  Also because (p+1)/4 is an even number, the computed square root is
   45|       |     *  itself always a square (a ** ((p+1)/4) is the square of a ** ((p+1)/8)).
   46|       |     */
   47|  27.1k|    secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;
   48|  27.1k|    int j, ret;
   49|       |
   50|  27.1k|    VERIFY_CHECK(r != a);
   51|  27.1k|    SECP256K1_FE_VERIFY(a);
  ------------------
  |  |  344|  27.1k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   52|  27.1k|    SECP256K1_FE_VERIFY_MAGNITUDE(a, 8);
  ------------------
  |  |  348|  27.1k|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   53|       |
   54|       |    /** The binary representation of (p + 1)/4 has 3 blocks of 1s, with lengths in
   55|       |     *  { 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:
   56|       |     *  1, [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]
   57|       |     */
   58|       |
   59|  27.1k|    secp256k1_fe_sqr(&x2, a);
  ------------------
  |  |   94|  27.1k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   60|  27.1k|    secp256k1_fe_mul(&x2, &x2, a);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   61|       |
   62|  27.1k|    secp256k1_fe_sqr(&x3, &x2);
  ------------------
  |  |   94|  27.1k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   63|  27.1k|    secp256k1_fe_mul(&x3, &x3, a);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   64|       |
   65|  27.1k|    x6 = x3;
   66|   108k|    for (j=0; j<3; j++) {
  ------------------
  |  Branch (66:15): [True: 81.5k, False: 27.1k]
  ------------------
   67|  81.5k|        secp256k1_fe_sqr(&x6, &x6);
  ------------------
  |  |   94|  81.5k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   68|  81.5k|    }
   69|  27.1k|    secp256k1_fe_mul(&x6, &x6, &x3);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   70|       |
   71|  27.1k|    x9 = x6;
   72|   108k|    for (j=0; j<3; j++) {
  ------------------
  |  Branch (72:15): [True: 81.5k, False: 27.1k]
  ------------------
   73|  81.5k|        secp256k1_fe_sqr(&x9, &x9);
  ------------------
  |  |   94|  81.5k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   74|  81.5k|    }
   75|  27.1k|    secp256k1_fe_mul(&x9, &x9, &x3);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   76|       |
   77|  27.1k|    x11 = x9;
   78|  81.5k|    for (j=0; j<2; j++) {
  ------------------
  |  Branch (78:15): [True: 54.3k, False: 27.1k]
  ------------------
   79|  54.3k|        secp256k1_fe_sqr(&x11, &x11);
  ------------------
  |  |   94|  54.3k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   80|  54.3k|    }
   81|  27.1k|    secp256k1_fe_mul(&x11, &x11, &x2);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   82|       |
   83|  27.1k|    x22 = x11;
   84|   326k|    for (j=0; j<11; j++) {
  ------------------
  |  Branch (84:15): [True: 299k, False: 27.1k]
  ------------------
   85|   299k|        secp256k1_fe_sqr(&x22, &x22);
  ------------------
  |  |   94|   299k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   86|   299k|    }
   87|  27.1k|    secp256k1_fe_mul(&x22, &x22, &x11);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   88|       |
   89|  27.1k|    x44 = x22;
   90|   625k|    for (j=0; j<22; j++) {
  ------------------
  |  Branch (90:15): [True: 598k, False: 27.1k]
  ------------------
   91|   598k|        secp256k1_fe_sqr(&x44, &x44);
  ------------------
  |  |   94|   598k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   92|   598k|    }
   93|  27.1k|    secp256k1_fe_mul(&x44, &x44, &x22);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   94|       |
   95|  27.1k|    x88 = x44;
   96|  1.22M|    for (j=0; j<44; j++) {
  ------------------
  |  Branch (96:15): [True: 1.19M, False: 27.1k]
  ------------------
   97|  1.19M|        secp256k1_fe_sqr(&x88, &x88);
  ------------------
  |  |   94|  1.19M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   98|  1.19M|    }
   99|  27.1k|    secp256k1_fe_mul(&x88, &x88, &x44);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  100|       |
  101|  27.1k|    x176 = x88;
  102|  2.41M|    for (j=0; j<88; j++) {
  ------------------
  |  Branch (102:15): [True: 2.39M, False: 27.1k]
  ------------------
  103|  2.39M|        secp256k1_fe_sqr(&x176, &x176);
  ------------------
  |  |   94|  2.39M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  104|  2.39M|    }
  105|  27.1k|    secp256k1_fe_mul(&x176, &x176, &x88);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  106|       |
  107|  27.1k|    x220 = x176;
  108|  1.22M|    for (j=0; j<44; j++) {
  ------------------
  |  Branch (108:15): [True: 1.19M, False: 27.1k]
  ------------------
  109|  1.19M|        secp256k1_fe_sqr(&x220, &x220);
  ------------------
  |  |   94|  1.19M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  110|  1.19M|    }
  111|  27.1k|    secp256k1_fe_mul(&x220, &x220, &x44);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  112|       |
  113|  27.1k|    x223 = x220;
  114|   108k|    for (j=0; j<3; j++) {
  ------------------
  |  Branch (114:15): [True: 81.5k, False: 27.1k]
  ------------------
  115|  81.5k|        secp256k1_fe_sqr(&x223, &x223);
  ------------------
  |  |   94|  81.5k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  116|  81.5k|    }
  117|  27.1k|    secp256k1_fe_mul(&x223, &x223, &x3);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  118|       |
  119|       |    /* The final result is then assembled using a sliding window over the blocks. */
  120|       |
  121|  27.1k|    t1 = x223;
  122|   652k|    for (j=0; j<23; j++) {
  ------------------
  |  Branch (122:15): [True: 625k, False: 27.1k]
  ------------------
  123|   625k|        secp256k1_fe_sqr(&t1, &t1);
  ------------------
  |  |   94|   625k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  124|   625k|    }
  125|  27.1k|    secp256k1_fe_mul(&t1, &t1, &x22);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  126|   190k|    for (j=0; j<6; j++) {
  ------------------
  |  Branch (126:15): [True: 163k, False: 27.1k]
  ------------------
  127|   163k|        secp256k1_fe_sqr(&t1, &t1);
  ------------------
  |  |   94|   163k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  128|   163k|    }
  129|  27.1k|    secp256k1_fe_mul(&t1, &t1, &x2);
  ------------------
  |  |   93|  27.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  130|  27.1k|    secp256k1_fe_sqr(&t1, &t1);
  ------------------
  |  |   94|  27.1k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  131|  27.1k|    secp256k1_fe_sqr(r, &t1);
  ------------------
  |  |   94|  27.1k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  132|       |
  133|       |    /* Check that a square root was actually calculated */
  134|       |
  135|  27.1k|    secp256k1_fe_sqr(&t1, r);
  ------------------
  |  |   94|  27.1k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  136|  27.1k|    ret = secp256k1_fe_equal(&t1, a);
  137|       |
  138|       |#ifdef VERIFY
  139|       |    if (!ret) {
  140|       |        secp256k1_fe_negate(&t1, &t1, 1);
  141|       |        secp256k1_fe_normalize_var(&t1);
  142|       |        VERIFY_CHECK(secp256k1_fe_equal(&t1, a));
  143|       |    }
  144|       |#endif
  145|  27.1k|    return ret;
  146|  27.1k|}
secp256k1.c:secp256k1_fe_equal:
   25|  34.0k|SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {
   26|  34.0k|    secp256k1_fe na;
   27|  34.0k|    SECP256K1_FE_VERIFY(a);
  ------------------
  |  |  344|  34.0k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   28|  34.0k|    SECP256K1_FE_VERIFY(b);
  ------------------
  |  |  344|  34.0k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   29|  34.0k|    SECP256K1_FE_VERIFY_MAGNITUDE(a, 1);
  ------------------
  |  |  348|  34.0k|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   30|  34.0k|    SECP256K1_FE_VERIFY_MAGNITUDE(b, 31);
  ------------------
  |  |  348|  34.0k|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   31|       |
   32|  34.0k|    secp256k1_fe_negate(&na, a, 1);
  ------------------
  |  |  211|  34.0k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  34.0k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  34.0k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 34.0k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  34.0k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 34.0k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  34.0k|    } \
  |  |  |  |   84|  34.0k|    stmt; \
  |  |  |  |   85|  34.0k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 34.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   33|  34.0k|    secp256k1_fe_add(&na, b);
  ------------------
  |  |   92|  34.0k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
   34|  34.0k|    return secp256k1_fe_normalizes_to_zero(&na);
  ------------------
  |  |   81|  34.0k|#  define secp256k1_fe_normalizes_to_zero secp256k1_fe_impl_normalizes_to_zero
  ------------------
   35|  34.0k|}
secp256k1.c:secp256k1_fe_clear:
   21|  91.8k|SECP256K1_INLINE static void secp256k1_fe_clear(secp256k1_fe *a) {
   22|  91.8k|    secp256k1_memclear(a, sizeof(secp256k1_fe));
   23|  91.8k|}

secp256k1.c:secp256k1_ge_set_xy:
  132|   438k|static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const secp256k1_fe *y) {
  133|   438k|    SECP256K1_FE_VERIFY(x);
  ------------------
  |  |  344|   438k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  134|   438k|    SECP256K1_FE_VERIFY(y);
  ------------------
  |  |  344|   438k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  135|       |
  136|   438k|    r->infinity = 0;
  137|   438k|    r->x = *x;
  138|   438k|    r->y = *y;
  139|       |
  140|   438k|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|   438k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  141|   438k|}
secp256k1.c:secp256k1_ge_verify:
   78|  10.1M|static void secp256k1_ge_verify(const secp256k1_ge *a) {
   79|  10.1M|    SECP256K1_FE_VERIFY(&a->x);
  ------------------
  |  |  344|  10.1M|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   80|  10.1M|    SECP256K1_FE_VERIFY(&a->y);
  ------------------
  |  |  344|  10.1M|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   81|  10.1M|    SECP256K1_FE_VERIFY_MAGNITUDE(&a->x, SECP256K1_GE_X_MAGNITUDE_MAX);
  ------------------
  |  |  348|  10.1M|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   82|  10.1M|    SECP256K1_FE_VERIFY_MAGNITUDE(&a->y, SECP256K1_GE_Y_MAGNITUDE_MAX);
  ------------------
  |  |  348|  10.1M|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   83|  10.1M|    VERIFY_CHECK(a->infinity == 0 || a->infinity == 1);
   84|  10.1M|    (void)a;
   85|  10.1M|}
secp256k1.c:secp256k1_ge_is_in_correct_subgroup:
  924|  4.34k|static int secp256k1_ge_is_in_correct_subgroup(const secp256k1_ge* ge) {
  925|       |#ifdef EXHAUSTIVE_TEST_ORDER
  926|       |    secp256k1_gej out;
  927|       |    int i;
  928|       |    SECP256K1_GE_VERIFY(ge);
  929|       |
  930|       |    /* A very simple EC multiplication ladder that avoids a dependency on ecmult. */
  931|       |    secp256k1_gej_set_infinity(&out);
  932|       |    for (i = 0; i < 32; ++i) {
  933|       |        secp256k1_gej_double_var(&out, &out, NULL);
  934|       |        if ((((uint32_t)EXHAUSTIVE_TEST_ORDER) >> (31 - i)) & 1) {
  935|       |            secp256k1_gej_add_ge_var(&out, &out, ge, NULL);
  936|       |        }
  937|       |    }
  938|       |    return secp256k1_gej_is_infinity(&out);
  939|       |#else
  940|  4.34k|    SECP256K1_GE_VERIFY(ge);
  ------------------
  |  |  210|  4.34k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  941|       |
  942|  4.34k|    (void)ge;
  943|       |    /* The real secp256k1 group has cofactor 1, so the subgroup is the entire curve. */
  944|  4.34k|    return 1;
  945|  4.34k|#endif
  946|  4.34k|}
secp256k1.c:secp256k1_ge_to_bytes:
  975|  72.6k|static void secp256k1_ge_to_bytes(unsigned char *buf, const secp256k1_ge *a) {
  976|  72.6k|    secp256k1_ge_storage s;
  977|       |
  978|       |    /* We require that the secp256k1_ge_storage type is exactly 64 bytes.
  979|       |     * This is formally not guaranteed by the C standard, but should hold on any
  980|       |     * sane compiler in the real world. */
  981|  72.6k|    STATIC_ASSERT(sizeof(secp256k1_ge_storage) == 64);
  ------------------
  |  |   64|  72.6k|#define STATIC_ASSERT(expr) do { \
  |  |   65|  72.6k|    switch(0) { \
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded, False: 0]
  |  |  ------------------
  |  |   66|  72.6k|        case 0: \
  |  |  ------------------
  |  |  |  Branch (66:9): [True: 72.6k, False: 0]
  |  |  ------------------
  |  |   67|  72.6k|        /* If expr evaluates to 0, we have two case labels "0", which is illegal. */ \
  |  |   68|  72.6k|        case /* ERROR: static assertion failed */ (expr): \
  |  |  ------------------
  |  |  |  Branch (68:9): [True: 0, False: 72.6k]
  |  |  ------------------
  |  |   69|  72.6k|        ; \
  |  |   70|  72.6k|    } \
  |  |   71|  72.6k|} while(0)
  |  |  ------------------
  |  |  |  Branch (71:9): [Folded, False: 72.6k]
  |  |  ------------------
  ------------------
  982|  72.6k|    VERIFY_CHECK(!secp256k1_ge_is_infinity(a));
  983|  72.6k|    secp256k1_ge_to_storage(&s, a);
  984|  72.6k|    memcpy(buf, &s, 64);
  985|  72.6k|}
secp256k1.c:secp256k1_ge_to_storage:
  877|  72.6k|static void secp256k1_ge_to_storage(secp256k1_ge_storage *r, const secp256k1_ge *a) {
  878|  72.6k|    secp256k1_fe x, y;
  879|  72.6k|    SECP256K1_GE_VERIFY(a);
  ------------------
  |  |  210|  72.6k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  880|  72.6k|    VERIFY_CHECK(!a->infinity);
  881|       |
  882|  72.6k|    x = a->x;
  883|  72.6k|    secp256k1_fe_normalize(&x);
  ------------------
  |  |   78|  72.6k|#  define secp256k1_fe_normalize secp256k1_fe_impl_normalize
  ------------------
  884|  72.6k|    y = a->y;
  885|  72.6k|    secp256k1_fe_normalize(&y);
  ------------------
  |  |   78|  72.6k|#  define secp256k1_fe_normalize secp256k1_fe_impl_normalize
  ------------------
  886|  72.6k|    secp256k1_fe_to_storage(&r->x, &x);
  ------------------
  |  |   96|  72.6k|#  define secp256k1_fe_to_storage secp256k1_fe_impl_to_storage
  ------------------
  887|  72.6k|    secp256k1_fe_to_storage(&r->y, &y);
  ------------------
  |  |   96|  72.6k|#  define secp256k1_fe_to_storage secp256k1_fe_impl_to_storage
  ------------------
  888|  72.6k|}
secp256k1.c:secp256k1_ge_clear:
  343|  79.1k|static void secp256k1_ge_clear(secp256k1_ge *r) {
  344|  79.1k|    secp256k1_memclear(r, sizeof(secp256k1_ge));
  345|  79.1k|}
secp256k1.c:secp256k1_ge_from_bytes:
  987|  76.0k|static void secp256k1_ge_from_bytes(secp256k1_ge *r, const unsigned char *buf) {
  988|  76.0k|    secp256k1_ge_storage s;
  989|       |
  990|  76.0k|    STATIC_ASSERT(sizeof(secp256k1_ge_storage) == 64);
  ------------------
  |  |   64|  76.0k|#define STATIC_ASSERT(expr) do { \
  |  |   65|  76.0k|    switch(0) { \
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded, False: 0]
  |  |  ------------------
  |  |   66|  76.0k|        case 0: \
  |  |  ------------------
  |  |  |  Branch (66:9): [True: 76.0k, False: 0]
  |  |  ------------------
  |  |   67|  76.0k|        /* If expr evaluates to 0, we have two case labels "0", which is illegal. */ \
  |  |   68|  76.0k|        case /* ERROR: static assertion failed */ (expr): \
  |  |  ------------------
  |  |  |  Branch (68:9): [True: 0, False: 76.0k]
  |  |  ------------------
  |  |   69|  76.0k|        ; \
  |  |   70|  76.0k|    } \
  |  |   71|  76.0k|} while(0)
  |  |  ------------------
  |  |  |  Branch (71:9): [Folded, False: 76.0k]
  |  |  ------------------
  ------------------
  991|  76.0k|    memcpy(&s, buf, 64);
  992|  76.0k|    secp256k1_ge_from_storage(r, &s);
  993|  76.0k|}
secp256k1.c:secp256k1_ge_from_storage:
  890|  3.61M|static void secp256k1_ge_from_storage(secp256k1_ge *r, const secp256k1_ge_storage *a) {
  891|  3.61M|    secp256k1_fe_from_storage(&r->x, &a->x);
  ------------------
  |  |   97|  3.61M|#  define secp256k1_fe_from_storage secp256k1_fe_impl_from_storage
  ------------------
  892|  3.61M|    secp256k1_fe_from_storage(&r->y, &a->y);
  ------------------
  |  |   97|  3.61M|#  define secp256k1_fe_from_storage secp256k1_fe_impl_from_storage
  ------------------
  893|  3.61M|    r->infinity = 0;
  894|       |
  895|  3.61M|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|  3.61M|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  896|  3.61M|}
secp256k1.c:secp256k1_gej_verify:
   87|  17.1M|static void secp256k1_gej_verify(const secp256k1_gej *a) {
   88|  17.1M|    SECP256K1_FE_VERIFY(&a->x);
  ------------------
  |  |  344|  17.1M|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   89|  17.1M|    SECP256K1_FE_VERIFY(&a->y);
  ------------------
  |  |  344|  17.1M|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   90|  17.1M|    SECP256K1_FE_VERIFY(&a->z);
  ------------------
  |  |  344|  17.1M|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
   91|  17.1M|    SECP256K1_FE_VERIFY_MAGNITUDE(&a->x, SECP256K1_GEJ_X_MAGNITUDE_MAX);
  ------------------
  |  |  348|  17.1M|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   92|  17.1M|    SECP256K1_FE_VERIFY_MAGNITUDE(&a->y, SECP256K1_GEJ_Y_MAGNITUDE_MAX);
  ------------------
  |  |  348|  17.1M|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   93|  17.1M|    SECP256K1_FE_VERIFY_MAGNITUDE(&a->z, SECP256K1_GEJ_Z_MAGNITUDE_MAX);
  ------------------
  |  |  348|  17.1M|#define SECP256K1_FE_VERIFY_MAGNITUDE(a, m) secp256k1_fe_verify_magnitude(a, m)
  ------------------
   94|  17.1M|    VERIFY_CHECK(a->infinity == 0 || a->infinity == 1);
   95|  17.1M|    (void)a;
   96|  17.1M|}
secp256k1.c:secp256k1_ge_storage_cmov:
  910|   108M|static SECP256K1_INLINE void secp256k1_ge_storage_cmov(secp256k1_ge_storage *r, const secp256k1_ge_storage *a, int flag) {
  911|   108M|    secp256k1_fe_storage_cmov(&r->x, &a->x, flag);
  912|   108M|    secp256k1_fe_storage_cmov(&r->y, &a->y, flag);
  913|   108M|}
secp256k1.c:secp256k1_gej_rescale:
  861|  79.1k|static void secp256k1_gej_rescale(secp256k1_gej *r, const secp256k1_fe *s) {
  862|       |    /* Operations: 4 mul, 1 sqr */
  863|  79.1k|    secp256k1_fe zz;
  864|  79.1k|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|  79.1k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  865|  79.1k|    SECP256K1_FE_VERIFY(s);
  ------------------
  |  |  344|  79.1k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  866|  79.1k|    VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(s));
  867|       |
  868|  79.1k|    secp256k1_fe_sqr(&zz, s);
  ------------------
  |  |   94|  79.1k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  869|  79.1k|    secp256k1_fe_mul(&r->x, &r->x, &zz);                /* r->x *= s^2 */
  ------------------
  |  |   93|  79.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  870|  79.1k|    secp256k1_fe_mul(&r->y, &r->y, &zz);
  ------------------
  |  |   93|  79.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  871|  79.1k|    secp256k1_fe_mul(&r->y, &r->y, s);                  /* r->y *= s^3 */
  ------------------
  |  |   93|  79.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  872|  79.1k|    secp256k1_fe_mul(&r->z, &r->z, s);                  /* r->z *= s   */
  ------------------
  |  |   93|  79.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  873|       |
  874|  79.1k|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|  79.1k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  875|  79.1k|}
secp256k1.c:secp256k1_gej_double:
  460|  2.58M|static SECP256K1_INLINE void secp256k1_gej_double(secp256k1_gej *r, const secp256k1_gej *a) {
  461|       |    /* Operations: 3 mul, 4 sqr, 8 add/half/mul_int/negate */
  462|  2.58M|    secp256k1_fe l, s, t;
  463|  2.58M|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  2.58M|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  464|       |
  465|  2.58M|    r->infinity = a->infinity;
  466|       |
  467|       |    /* Formula used:
  468|       |     * L = (3/2) * X1^2
  469|       |     * S = Y1^2
  470|       |     * T = -X1*S
  471|       |     * X3 = L^2 + 2*T
  472|       |     * Y3 = -(L*(X3 + T) + S^2)
  473|       |     * Z3 = Y1*Z1
  474|       |     */
  475|       |
  476|  2.58M|    secp256k1_fe_mul(&r->z, &a->z, &a->y); /* Z3 = Y1*Z1 (1) */
  ------------------
  |  |   93|  2.58M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  477|  2.58M|    secp256k1_fe_sqr(&s, &a->y);           /* S = Y1^2 (1) */
  ------------------
  |  |   94|  2.58M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  478|  2.58M|    secp256k1_fe_sqr(&l, &a->x);           /* L = X1^2 (1) */
  ------------------
  |  |   94|  2.58M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  479|  2.58M|    secp256k1_fe_mul_int(&l, 3);           /* L = 3*X1^2 (3) */
  ------------------
  |  |  233|  2.58M|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  2.58M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  2.58M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 2.58M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  2.58M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 2.58M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  2.58M|    } \
  |  |  |  |   84|  2.58M|    stmt; \
  |  |  |  |   85|  2.58M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 2.58M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  480|  2.58M|    secp256k1_fe_half(&l);                 /* L = 3/2*X1^2 (2) */
  ------------------
  |  |  101|  2.58M|#  define secp256k1_fe_half secp256k1_fe_impl_half
  ------------------
  481|  2.58M|    secp256k1_fe_negate(&t, &s, 1);        /* T = -S (2) */
  ------------------
  |  |  211|  2.58M|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  2.58M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  2.58M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 2.58M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  2.58M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 2.58M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  2.58M|    } \
  |  |  |  |   84|  2.58M|    stmt; \
  |  |  |  |   85|  2.58M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 2.58M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  482|  2.58M|    secp256k1_fe_mul(&t, &t, &a->x);       /* T = -X1*S (1) */
  ------------------
  |  |   93|  2.58M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  483|  2.58M|    secp256k1_fe_sqr(&r->x, &l);           /* X3 = L^2 (1) */
  ------------------
  |  |   94|  2.58M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  484|  2.58M|    secp256k1_fe_add(&r->x, &t);           /* X3 = L^2 + T (2) */
  ------------------
  |  |   92|  2.58M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  485|  2.58M|    secp256k1_fe_add(&r->x, &t);           /* X3 = L^2 + 2*T (3) */
  ------------------
  |  |   92|  2.58M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  486|  2.58M|    secp256k1_fe_sqr(&s, &s);              /* S' = S^2 (1) */
  ------------------
  |  |   94|  2.58M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  487|  2.58M|    secp256k1_fe_add(&t, &r->x);           /* T' = X3 + T (4) */
  ------------------
  |  |   92|  2.58M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  488|  2.58M|    secp256k1_fe_mul(&r->y, &t, &l);       /* Y3 = L*(X3 + T) (1) */
  ------------------
  |  |   93|  2.58M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  489|  2.58M|    secp256k1_fe_add(&r->y, &s);           /* Y3 = L*(X3 + T) + S^2 (2) */
  ------------------
  |  |   92|  2.58M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  490|  2.58M|    secp256k1_fe_negate(&r->y, &r->y, 2);  /* Y3 = -(L*(X3 + T) + S^2) (3) */
  ------------------
  |  |  211|  2.58M|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  2.58M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  2.58M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 2.58M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  2.58M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 2.58M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  2.58M|    } \
  |  |  |  |   84|  2.58M|    stmt; \
  |  |  |  |   85|  2.58M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 2.58M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  491|       |
  492|  2.58M|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|  2.58M|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  493|  2.58M|}
secp256k1.c:secp256k1_gej_clear:
  339|  79.1k|static void secp256k1_gej_clear(secp256k1_gej *r) {
  340|  79.1k|    secp256k1_memclear(r, sizeof(secp256k1_gej));
  341|  79.1k|}
secp256k1.c:secp256k1_gej_set_infinity:
  322|  15.4k|static void secp256k1_gej_set_infinity(secp256k1_gej *r) {
  323|  15.4k|    r->infinity = 1;
  324|  15.4k|    secp256k1_fe_set_int(&r->x, 0);
  ------------------
  |  |   83|  15.4k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  325|  15.4k|    secp256k1_fe_set_int(&r->y, 0);
  ------------------
  |  |   83|  15.4k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  326|  15.4k|    secp256k1_fe_set_int(&r->z, 0);
  ------------------
  |  |   83|  15.4k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  327|       |
  328|  15.4k|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|  15.4k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  329|  15.4k|}
secp256k1.c:secp256k1_gej_add_ge:
  724|  4.05M|static void secp256k1_gej_add_ge(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b) {
  725|       |    /* Operations: 7 mul, 5 sqr, 21 add/cmov/half/mul_int/negate/normalizes_to_zero */
  726|  4.05M|    secp256k1_fe zz, u1, u2, s1, s2, t, tt, m, n, q, rr;
  727|  4.05M|    secp256k1_fe m_alt, rr_alt;
  728|  4.05M|    int degenerate;
  729|  4.05M|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  4.05M|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  730|  4.05M|    SECP256K1_GE_VERIFY(b);
  ------------------
  |  |  210|  4.05M|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  731|  4.05M|    VERIFY_CHECK(!b->infinity);
  732|       |
  733|       |    /*  In:
  734|       |     *    Eric Brier and Marc Joye, Weierstrass Elliptic Curves and Side-Channel Attacks.
  735|       |     *    In D. Naccache and P. Paillier, Eds., Public Key Cryptography, vol. 2274 of Lecture Notes in Computer Science, pages 335-345. Springer-Verlag, 2002.
  736|       |     *  we find as solution for a unified addition/doubling formula:
  737|       |     *    lambda = ((x1 + x2)^2 - x1 * x2 + a) / (y1 + y2), with a = 0 for secp256k1's curve equation.
  738|       |     *    x3 = lambda^2 - (x1 + x2)
  739|       |     *    2*y3 = lambda * (x1 + x2 - 2 * x3) - (y1 + y2).
  740|       |     *
  741|       |     *  Substituting x_i = Xi / Zi^2 and yi = Yi / Zi^3, for i=1,2,3, gives:
  742|       |     *    U1 = X1*Z2^2, U2 = X2*Z1^2
  743|       |     *    S1 = Y1*Z2^3, S2 = Y2*Z1^3
  744|       |     *    Z = Z1*Z2
  745|       |     *    T = U1+U2
  746|       |     *    M = S1+S2
  747|       |     *    Q = -T*M^2
  748|       |     *    R = T^2-U1*U2
  749|       |     *    X3 = R^2+Q
  750|       |     *    Y3 = -(R*(2*X3+Q)+M^4)/2
  751|       |     *    Z3 = M*Z
  752|       |     *  (Note that the paper uses xi = Xi / Zi and yi = Yi / Zi instead.)
  753|       |     *
  754|       |     *  This formula has the benefit of being the same for both addition
  755|       |     *  of distinct points and doubling. However, it breaks down in the
  756|       |     *  case that either point is infinity, or that y1 = -y2. We handle
  757|       |     *  these cases in the following ways:
  758|       |     *
  759|       |     *    - If b is infinity we simply bail by means of a VERIFY_CHECK.
  760|       |     *
  761|       |     *    - If a is infinity, we detect this, and at the end of the
  762|       |     *      computation replace the result (which will be meaningless,
  763|       |     *      but we compute to be constant-time) with b.x : b.y : 1.
  764|       |     *
  765|       |     *    - If a = -b, we have y1 = -y2, which is a degenerate case.
  766|       |     *      But here the answer is infinity, so we simply set the
  767|       |     *      infinity flag of the result, overriding the computed values
  768|       |     *      without even needing to cmov.
  769|       |     *
  770|       |     *    - If y1 = -y2 but x1 != x2, which does occur thanks to certain
  771|       |     *      properties of our curve (specifically, 1 has nontrivial cube
  772|       |     *      roots in our field, and the curve equation has no x coefficient)
  773|       |     *      then the answer is not infinity but also not given by the above
  774|       |     *      equation. In this case, we cmov in place an alternate expression
  775|       |     *      for lambda. Specifically (y1 - y2)/(x1 - x2). Where both these
  776|       |     *      expressions for lambda are defined, they are equal, and can be
  777|       |     *      obtained from each other by multiplication by (y1 + y2)/(y1 + y2)
  778|       |     *      then substitution of x^3 + 7 for y^2 (using the curve equation).
  779|       |     *      For all pairs of nonzero points (a, b) at least one is defined,
  780|       |     *      so this covers everything.
  781|       |     */
  782|       |
  783|  4.05M|    secp256k1_fe_sqr(&zz, &a->z);                       /* z = Z1^2 */
  ------------------
  |  |   94|  4.05M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  784|  4.05M|    u1 = a->x;                                          /* u1 = U1 = X1*Z2^2 (GEJ_X_M) */
  785|  4.05M|    secp256k1_fe_mul(&u2, &b->x, &zz);                  /* u2 = U2 = X2*Z1^2 (1) */
  ------------------
  |  |   93|  4.05M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  786|  4.05M|    s1 = a->y;                                          /* s1 = S1 = Y1*Z2^3 (GEJ_Y_M) */
  787|  4.05M|    secp256k1_fe_mul(&s2, &b->y, &zz);                  /* s2 = Y2*Z1^2 (1) */
  ------------------
  |  |   93|  4.05M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  788|  4.05M|    secp256k1_fe_mul(&s2, &s2, &a->z);                  /* s2 = S2 = Y2*Z1^3 (1) */
  ------------------
  |  |   93|  4.05M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  789|  4.05M|    t = u1; secp256k1_fe_add(&t, &u2);                  /* t = T = U1+U2 (GEJ_X_M+1) */
  ------------------
  |  |   92|  4.05M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  790|  4.05M|    m = s1; secp256k1_fe_add(&m, &s2);                  /* m = M = S1+S2 (GEJ_Y_M+1) */
  ------------------
  |  |   92|  4.05M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  791|  4.05M|    secp256k1_fe_sqr(&rr, &t);                          /* rr = T^2 (1) */
  ------------------
  |  |   94|  4.05M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  792|  4.05M|    secp256k1_fe_negate(&m_alt, &u2, 1);                /* Malt = -X2*Z1^2 (2) */
  ------------------
  |  |  211|  4.05M|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  4.05M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  4.05M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 4.05M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  4.05M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 4.05M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  4.05M|    } \
  |  |  |  |   84|  4.05M|    stmt; \
  |  |  |  |   85|  4.05M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 4.05M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  793|  4.05M|    secp256k1_fe_mul(&tt, &u1, &m_alt);                 /* tt = -U1*U2 (1) */
  ------------------
  |  |   93|  4.05M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  794|  4.05M|    secp256k1_fe_add(&rr, &tt);                         /* rr = R = T^2-U1*U2 (2) */
  ------------------
  |  |   92|  4.05M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  795|       |    /* If lambda = R/M = R/0 we have a problem (except in the "trivial"
  796|       |     * case that Z = z1z2 = 0, and this is special-cased later on). */
  797|  4.05M|    degenerate = secp256k1_fe_normalizes_to_zero(&m);
  ------------------
  |  |   81|  4.05M|#  define secp256k1_fe_normalizes_to_zero secp256k1_fe_impl_normalizes_to_zero
  ------------------
  798|       |    /* This only occurs when y1 == -y2 and x1^3 == x2^3, but x1 != x2.
  799|       |     * This means either x1 == beta*x2 or beta*x1 == x2, where beta is
  800|       |     * a nontrivial cube root of one. In either case, an alternate
  801|       |     * non-indeterminate expression for lambda is (y1 - y2)/(x1 - x2),
  802|       |     * so we set R/M equal to this. */
  803|  4.05M|    rr_alt = s1;
  804|  4.05M|    secp256k1_fe_mul_int(&rr_alt, 2);       /* rr_alt = Y1*Z2^3 - Y2*Z1^3 (GEJ_Y_M*2) */
  ------------------
  |  |  233|  4.05M|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  4.05M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  4.05M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 4.05M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  4.05M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 4.05M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  4.05M|    } \
  |  |  |  |   84|  4.05M|    stmt; \
  |  |  |  |   85|  4.05M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 4.05M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  805|  4.05M|    secp256k1_fe_add(&m_alt, &u1);          /* Malt = X1*Z2^2 - X2*Z1^2 (GEJ_X_M+2) */
  ------------------
  |  |   92|  4.05M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  806|       |
  807|  4.05M|    secp256k1_fe_cmov(&rr_alt, &rr, !degenerate);       /* rr_alt (GEJ_Y_M*2) */
  ------------------
  |  |   95|  4.05M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  ------------------
  808|  4.05M|    secp256k1_fe_cmov(&m_alt, &m, !degenerate);         /* m_alt (GEJ_X_M+2) */
  ------------------
  |  |   95|  4.05M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  ------------------
  809|       |    /* Now Ralt / Malt = lambda and is guaranteed not to be Ralt / 0.
  810|       |     * From here on out Ralt and Malt represent the numerator
  811|       |     * and denominator of lambda; R and M represent the explicit
  812|       |     * expressions x1^2 + x2^2 + x1x2 and y1 + y2. */
  813|  4.05M|    secp256k1_fe_sqr(&n, &m_alt);                       /* n = Malt^2 (1) */
  ------------------
  |  |   94|  4.05M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  814|  4.05M|    secp256k1_fe_negate(&q, &t,
  ------------------
  |  |  211|  4.05M|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  4.05M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  4.05M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 4.05M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  4.05M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 4.05M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  4.05M|    } \
  |  |  |  |   84|  4.05M|    stmt; \
  |  |  |  |   85|  4.05M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 4.05M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  815|  4.05M|        SECP256K1_GEJ_X_MAGNITUDE_MAX + 1);             /* q = -T (GEJ_X_M+2) */
  816|  4.05M|    secp256k1_fe_mul(&q, &q, &n);                       /* q = Q = -T*Malt^2 (1) */
  ------------------
  |  |   93|  4.05M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  817|       |    /* These two lines use the observation that either M == Malt or M == 0,
  818|       |     * so M^3 * Malt is either Malt^4 (which is computed by squaring), or
  819|       |     * zero (which is "computed" by cmov). So the cost is one squaring
  820|       |     * versus two multiplications. */
  821|  4.05M|    secp256k1_fe_sqr(&n, &n);                           /* n = Malt^4 (1) */
  ------------------
  |  |   94|  4.05M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  822|  4.05M|    secp256k1_fe_cmov(&n, &m, degenerate);              /* n = M^3 * Malt (GEJ_Y_M+1) */
  ------------------
  |  |   95|  4.05M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  ------------------
  823|  4.05M|    secp256k1_fe_sqr(&t, &rr_alt);                      /* t = Ralt^2 (1) */
  ------------------
  |  |   94|  4.05M|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  824|  4.05M|    secp256k1_fe_mul(&r->z, &a->z, &m_alt);             /* r->z = Z3 = Malt*Z (1) */
  ------------------
  |  |   93|  4.05M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  825|  4.05M|    secp256k1_fe_add(&t, &q);                           /* t = Ralt^2 + Q (2) */
  ------------------
  |  |   92|  4.05M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  826|  4.05M|    r->x = t;                                           /* r->x = X3 = Ralt^2 + Q (2) */
  827|  4.05M|    secp256k1_fe_mul_int(&t, 2);                        /* t = 2*X3 (4) */
  ------------------
  |  |  233|  4.05M|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  4.05M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  4.05M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 4.05M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  4.05M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 4.05M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  4.05M|    } \
  |  |  |  |   84|  4.05M|    stmt; \
  |  |  |  |   85|  4.05M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 4.05M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  828|  4.05M|    secp256k1_fe_add(&t, &q);                           /* t = 2*X3 + Q (5) */
  ------------------
  |  |   92|  4.05M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  829|  4.05M|    secp256k1_fe_mul(&t, &t, &rr_alt);                  /* t = Ralt*(2*X3 + Q) (1) */
  ------------------
  |  |   93|  4.05M|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  830|  4.05M|    secp256k1_fe_add(&t, &n);                           /* t = Ralt*(2*X3 + Q) + M^3*Malt (GEJ_Y_M+2) */
  ------------------
  |  |   92|  4.05M|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  831|  4.05M|    secp256k1_fe_negate(&r->y, &t,
  ------------------
  |  |  211|  4.05M|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  4.05M|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  4.05M|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 4.05M]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  4.05M|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 4.05M, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  4.05M|    } \
  |  |  |  |   84|  4.05M|    stmt; \
  |  |  |  |   85|  4.05M|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 4.05M]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  832|  4.05M|        SECP256K1_GEJ_Y_MAGNITUDE_MAX + 2);             /* r->y = -(Ralt*(2*X3 + Q) + M^3*Malt) (GEJ_Y_M+3) */
  833|  4.05M|    secp256k1_fe_half(&r->y);                           /* r->y = Y3 = -(Ralt*(2*X3 + Q) + M^3*Malt)/2 ((GEJ_Y_M+3)/2 + 1) */
  ------------------
  |  |  101|  4.05M|#  define secp256k1_fe_half secp256k1_fe_impl_half
  ------------------
  834|       |
  835|       |    /* In case a->infinity == 1, replace r with (b->x, b->y, 1). */
  836|  4.05M|    secp256k1_fe_cmov(&r->x, &b->x, a->infinity);
  ------------------
  |  |   95|  4.05M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  ------------------
  837|  4.05M|    secp256k1_fe_cmov(&r->y, &b->y, a->infinity);
  ------------------
  |  |   95|  4.05M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  ------------------
  838|  4.05M|    secp256k1_fe_cmov(&r->z, &secp256k1_fe_one, a->infinity);
  ------------------
  |  |   95|  4.05M|#  define secp256k1_fe_cmov secp256k1_fe_impl_cmov
  ------------------
  839|       |
  840|       |    /* Set r->infinity if r->z is 0.
  841|       |     *
  842|       |     * If a->infinity is set, then r->infinity = (r->z == 0) = (1 == 0) = false,
  843|       |     * which is correct because the function assumes that b is not infinity.
  844|       |     *
  845|       |     * Now assume !a->infinity. This implies Z = Z1 != 0.
  846|       |     *
  847|       |     * Case y1 = -y2:
  848|       |     * In this case we could have a = -b, namely if x1 = x2.
  849|       |     * We have degenerate = true, r->z = (x1 - x2) * Z.
  850|       |     * Then r->infinity = ((x1 - x2)Z == 0) = (x1 == x2) = (a == -b).
  851|       |     *
  852|       |     * Case y1 != -y2:
  853|       |     * In this case, we can't have a = -b.
  854|       |     * We have degenerate = false, r->z = (y1 + y2) * Z.
  855|       |     * Then r->infinity = ((y1 + y2)Z == 0) = (y1 == -y2) = false. */
  856|  4.05M|    r->infinity = secp256k1_fe_normalizes_to_zero(&r->z);
  ------------------
  |  |   81|  4.05M|#  define secp256k1_fe_normalizes_to_zero secp256k1_fe_impl_normalizes_to_zero
  ------------------
  857|       |
  858|  4.05M|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|  4.05M|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  859|  4.05M|}
secp256k1.c:secp256k1_gej_is_infinity:
  440|  15.4k|static int secp256k1_gej_is_infinity(const secp256k1_gej *a) {
  441|  15.4k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  15.4k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  442|       |
  443|  15.4k|    return a->infinity;
  444|  15.4k|}
secp256k1.c:secp256k1_ge_set_gej:
  159|  79.1k|static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a) {
  160|  79.1k|    secp256k1_fe z2, z3;
  161|  79.1k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  79.1k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  162|       |
  163|  79.1k|    r->infinity = a->infinity;
  164|  79.1k|    secp256k1_fe_inv(&a->z, &a->z);
  ------------------
  |  |   98|  79.1k|#  define secp256k1_fe_inv secp256k1_fe_impl_inv
  ------------------
  165|  79.1k|    secp256k1_fe_sqr(&z2, &a->z);
  ------------------
  |  |   94|  79.1k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  166|  79.1k|    secp256k1_fe_mul(&z3, &a->z, &z2);
  ------------------
  |  |   93|  79.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  167|  79.1k|    secp256k1_fe_mul(&a->x, &a->x, &z2);
  ------------------
  |  |   93|  79.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  168|  79.1k|    secp256k1_fe_mul(&a->y, &a->y, &z3);
  ------------------
  |  |   93|  79.1k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  169|  79.1k|    secp256k1_fe_set_int(&a->z, 1);
  ------------------
  |  |   83|  79.1k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  170|  79.1k|    r->x = a->x;
  171|  79.1k|    r->y = a->y;
  172|       |
  173|  79.1k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  79.1k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  174|  79.1k|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|  79.1k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  175|  79.1k|}
secp256k1.c:secp256k1_ge_set_xo_var:
  347|  6.90k|static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {
  348|  6.90k|    secp256k1_fe x2, x3;
  349|  6.90k|    int ret;
  350|  6.90k|    SECP256K1_FE_VERIFY(x);
  ------------------
  |  |  344|  6.90k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  351|       |
  352|  6.90k|    r->x = *x;
  353|  6.90k|    secp256k1_fe_sqr(&x2, x);
  ------------------
  |  |   94|  6.90k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  354|  6.90k|    secp256k1_fe_mul(&x3, x, &x2);
  ------------------
  |  |   93|  6.90k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  355|  6.90k|    r->infinity = 0;
  356|  6.90k|    secp256k1_fe_add_int(&x3, SECP256K1_B);
  ------------------
  |  |  102|  6.90k|#  define secp256k1_fe_add_int secp256k1_fe_impl_add_int
  ------------------
                  secp256k1_fe_add_int(&x3, SECP256K1_B);
  ------------------
  |  |   73|  6.90k|#define SECP256K1_B 7
  ------------------
  357|  6.90k|    ret = secp256k1_fe_sqrt(&r->y, &x3);
  358|  6.90k|    secp256k1_fe_normalize_var(&r->y);
  ------------------
  |  |   80|  6.90k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  359|  6.90k|    if (secp256k1_fe_is_odd(&r->y) != odd) {
  ------------------
  |  |   85|  6.90k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
  |  Branch (359:9): [True: 3.49k, False: 3.41k]
  ------------------
  360|  3.49k|        secp256k1_fe_negate(&r->y, &r->y, 1);
  ------------------
  |  |  211|  3.49k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  3.49k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  3.49k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 3.49k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  3.49k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 3.49k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  3.49k|    } \
  |  |  |  |   84|  3.49k|    stmt; \
  |  |  |  |   85|  3.49k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 3.49k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  361|  3.49k|    }
  362|       |
  363|  6.90k|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|  6.90k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  364|  6.90k|    return ret;
  365|  6.90k|}
secp256k1.c:secp256k1_gej_set_ge:
  367|   137k|static void secp256k1_gej_set_ge(secp256k1_gej *r, const secp256k1_ge *a) {
  368|   137k|   SECP256K1_GE_VERIFY(a);
  ------------------
  |  |  210|   137k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  369|       |
  370|   137k|   r->infinity = a->infinity;
  371|   137k|   r->x = a->x;
  372|   137k|   r->y = a->y;
  373|   137k|   secp256k1_fe_set_int(&r->z, 1);
  ------------------
  |  |   83|   137k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  374|       |
  375|   137k|   SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|   137k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  376|   137k|}
secp256k1.c:secp256k1_ge_set_gej_zinv:
   99|  20.3k|static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {
  100|  20.3k|    secp256k1_fe zi2;
  101|  20.3k|    secp256k1_fe zi3;
  102|  20.3k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  20.3k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  103|  20.3k|    SECP256K1_FE_VERIFY(zi);
  ------------------
  |  |  344|  20.3k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  104|  20.3k|    VERIFY_CHECK(!a->infinity);
  105|       |
  106|  20.3k|    secp256k1_fe_sqr(&zi2, zi);
  ------------------
  |  |   94|  20.3k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  107|  20.3k|    secp256k1_fe_mul(&zi3, &zi2, zi);
  ------------------
  |  |   93|  20.3k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  108|  20.3k|    secp256k1_fe_mul(&r->x, &a->x, &zi2);
  ------------------
  |  |   93|  20.3k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  109|  20.3k|    secp256k1_fe_mul(&r->y, &a->y, &zi3);
  ------------------
  |  |   93|  20.3k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  110|  20.3k|    r->infinity = a->infinity;
  111|       |
  112|  20.3k|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|  20.3k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  113|  20.3k|}
secp256k1.c:secp256k1_ge_table_set_globalz:
  289|  20.3k|static void secp256k1_ge_table_set_globalz(size_t len, secp256k1_ge *a, const secp256k1_fe *zr) {
  290|  20.3k|    size_t i;
  291|  20.3k|    secp256k1_fe zs;
  292|       |#ifdef VERIFY
  293|       |    for (i = 0; i < len; i++) {
  294|       |        SECP256K1_GE_VERIFY(&a[i]);
  295|       |        SECP256K1_FE_VERIFY(&zr[i]);
  296|       |    }
  297|       |#endif
  298|       |
  299|  20.3k|    if (len > 0) {
  ------------------
  |  Branch (299:9): [True: 20.3k, False: 0]
  ------------------
  300|  20.3k|        i = len - 1;
  301|       |        /* Ensure all y values are in weak normal form for fast negation of points */
  302|  20.3k|        secp256k1_fe_normalize_weak(&a[i].y);
  ------------------
  |  |   79|  20.3k|#  define secp256k1_fe_normalize_weak secp256k1_fe_impl_normalize_weak
  ------------------
  303|  20.3k|        zs = zr[i];
  304|       |
  305|       |        /* Work our way backwards, using the z-ratios to scale the x/y values. */
  306|   264k|        while (i > 0) {
  ------------------
  |  Branch (306:16): [True: 244k, False: 20.3k]
  ------------------
  307|   244k|            if (i != len - 1) {
  ------------------
  |  Branch (307:17): [True: 223k, False: 20.3k]
  ------------------
  308|   223k|                secp256k1_fe_mul(&zs, &zs, &zr[i]);
  ------------------
  |  |   93|   223k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  309|   223k|            }
  310|   244k|            i--;
  311|   244k|            secp256k1_ge_set_ge_zinv(&a[i], &a[i], &zs);
  312|   244k|        }
  313|  20.3k|    }
  314|       |
  315|       |#ifdef VERIFY
  316|       |    for (i = 0; i < len; i++) {
  317|       |        SECP256K1_GE_VERIFY(&a[i]);
  318|       |    }
  319|       |#endif
  320|  20.3k|}
secp256k1.c:secp256k1_ge_set_ge_zinv:
  116|   244k|static void secp256k1_ge_set_ge_zinv(secp256k1_ge *r, const secp256k1_ge *a, const secp256k1_fe *zi) {
  117|   244k|    secp256k1_fe zi2;
  118|   244k|    secp256k1_fe zi3;
  119|   244k|    SECP256K1_GE_VERIFY(a);
  ------------------
  |  |  210|   244k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  120|   244k|    SECP256K1_FE_VERIFY(zi);
  ------------------
  |  |  344|   244k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  121|   244k|    VERIFY_CHECK(!a->infinity);
  122|       |
  123|   244k|    secp256k1_fe_sqr(&zi2, zi);
  ------------------
  |  |   94|   244k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  124|   244k|    secp256k1_fe_mul(&zi3, &zi2, zi);
  ------------------
  |  |   93|   244k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  125|   244k|    secp256k1_fe_mul(&r->x, &a->x, &zi2);
  ------------------
  |  |   93|   244k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  126|   244k|    secp256k1_fe_mul(&r->y, &a->y, &zi3);
  ------------------
  |  |   93|   244k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  127|   244k|    r->infinity = a->infinity;
  128|       |
  129|   244k|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|   244k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  130|   244k|}
secp256k1.c:secp256k1_gej_double_var:
  495|  1.00M|static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {
  496|  1.00M|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  1.00M|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  497|       |
  498|       |    /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,
  499|       |     *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have
  500|       |     *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.
  501|       |     *
  502|       |     *  Having said this, if this function receives a point on a sextic twist, e.g. by
  503|       |     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,
  504|       |     *  since -6 does have a cube root mod p. For this point, this function will not set
  505|       |     *  the infinity flag even though the point doubles to infinity, and the result
  506|       |     *  point will be gibberish (z = 0 but infinity = 0).
  507|       |     */
  508|  1.00M|    if (a->infinity) {
  ------------------
  |  Branch (508:9): [True: 7.70k, False: 995k]
  ------------------
  509|  7.70k|        secp256k1_gej_set_infinity(r);
  510|  7.70k|        if (rzr != NULL) {
  ------------------
  |  Branch (510:13): [True: 0, False: 7.70k]
  ------------------
  511|      0|            secp256k1_fe_set_int(rzr, 1);
  ------------------
  |  |   83|      0|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  512|      0|        }
  513|  7.70k|        return;
  514|  7.70k|    }
  515|       |
  516|   995k|    if (rzr != NULL) {
  ------------------
  |  Branch (516:9): [True: 0, False: 995k]
  ------------------
  517|      0|        *rzr = a->y;
  518|      0|        secp256k1_fe_normalize_weak(rzr);
  ------------------
  |  |   79|      0|#  define secp256k1_fe_normalize_weak secp256k1_fe_impl_normalize_weak
  ------------------
  519|      0|    }
  520|       |
  521|   995k|    secp256k1_gej_double(r, a);
  522|       |
  523|   995k|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|   995k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  524|   995k|}
secp256k1.c:secp256k1_gej_add_ge_var:
  590|   577k|static void secp256k1_gej_add_ge_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b, secp256k1_fe *rzr) {
  591|       |    /* Operations: 8 mul, 3 sqr, 11 add/negate/normalizes_to_zero (ignoring special cases) */
  592|   577k|    secp256k1_fe z12, u1, u2, s1, s2, h, i, h2, h3, t;
  593|   577k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|   577k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  594|   577k|    SECP256K1_GE_VERIFY(b);
  ------------------
  |  |  210|   577k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  595|       |
  596|   577k|    if (a->infinity) {
  ------------------
  |  Branch (596:9): [True: 4.48k, False: 572k]
  ------------------
  597|  4.48k|        VERIFY_CHECK(rzr == NULL);
  598|  4.48k|        secp256k1_gej_set_ge(r, b);
  599|  4.48k|        return;
  600|  4.48k|    }
  601|   572k|    if (b->infinity) {
  ------------------
  |  Branch (601:9): [True: 0, False: 572k]
  ------------------
  602|      0|        if (rzr != NULL) {
  ------------------
  |  Branch (602:13): [True: 0, False: 0]
  ------------------
  603|      0|            secp256k1_fe_set_int(rzr, 1);
  ------------------
  |  |   83|      0|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  604|      0|        }
  605|      0|        *r = *a;
  606|      0|        return;
  607|      0|    }
  608|       |
  609|   572k|    secp256k1_fe_sqr(&z12, &a->z);
  ------------------
  |  |   94|   572k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  610|   572k|    u1 = a->x;
  611|   572k|    secp256k1_fe_mul(&u2, &b->x, &z12);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  612|   572k|    s1 = a->y;
  613|   572k|    secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
                  secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &a->z);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  614|   572k|    secp256k1_fe_negate(&h, &u1, SECP256K1_GEJ_X_MAGNITUDE_MAX); secp256k1_fe_add(&h, &u2);
  ------------------
  |  |  211|   572k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|   572k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|   572k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 572k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|   572k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 572k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|   572k|    } \
  |  |  |  |   84|   572k|    stmt; \
  |  |  |  |   85|   572k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 572k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  secp256k1_fe_negate(&h, &u1, SECP256K1_GEJ_X_MAGNITUDE_MAX); secp256k1_fe_add(&h, &u2);
  ------------------
  |  |   92|   572k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  615|   572k|    secp256k1_fe_negate(&i, &s2, 1); secp256k1_fe_add(&i, &s1);
  ------------------
  |  |  211|   572k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|   572k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|   572k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 572k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|   572k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 572k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|   572k|    } \
  |  |  |  |   84|   572k|    stmt; \
  |  |  |  |   85|   572k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 572k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  secp256k1_fe_negate(&i, &s2, 1); secp256k1_fe_add(&i, &s1);
  ------------------
  |  |   92|   572k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  616|   572k|    if (secp256k1_fe_normalizes_to_zero_var(&h)) {
  ------------------
  |  |   82|   572k|#  define secp256k1_fe_normalizes_to_zero_var secp256k1_fe_impl_normalizes_to_zero_var
  ------------------
  |  Branch (616:9): [True: 0, False: 572k]
  ------------------
  617|      0|        if (secp256k1_fe_normalizes_to_zero_var(&i)) {
  ------------------
  |  |   82|      0|#  define secp256k1_fe_normalizes_to_zero_var secp256k1_fe_impl_normalizes_to_zero_var
  ------------------
  |  Branch (617:13): [True: 0, False: 0]
  ------------------
  618|      0|            secp256k1_gej_double_var(r, a, rzr);
  619|      0|        } else {
  620|      0|            if (rzr != NULL) {
  ------------------
  |  Branch (620:17): [True: 0, False: 0]
  ------------------
  621|      0|                secp256k1_fe_set_int(rzr, 0);
  ------------------
  |  |   83|      0|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  622|      0|            }
  623|      0|            secp256k1_gej_set_infinity(r);
  624|      0|        }
  625|      0|        return;
  626|      0|    }
  627|       |
  628|   572k|    r->infinity = 0;
  629|   572k|    if (rzr != NULL) {
  ------------------
  |  Branch (629:9): [True: 244k, False: 328k]
  ------------------
  630|   244k|        *rzr = h;
  631|   244k|    }
  632|   572k|    secp256k1_fe_mul(&r->z, &a->z, &h);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  633|       |
  634|   572k|    secp256k1_fe_sqr(&h2, &h);
  ------------------
  |  |   94|   572k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  635|   572k|    secp256k1_fe_negate(&h2, &h2, 1);
  ------------------
  |  |  211|   572k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|   572k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|   572k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 572k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|   572k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 572k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|   572k|    } \
  |  |  |  |   84|   572k|    stmt; \
  |  |  |  |   85|   572k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 572k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  636|   572k|    secp256k1_fe_mul(&h3, &h2, &h);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  637|   572k|    secp256k1_fe_mul(&t, &u1, &h2);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  638|       |
  639|   572k|    secp256k1_fe_sqr(&r->x, &i);
  ------------------
  |  |   94|   572k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  640|   572k|    secp256k1_fe_add(&r->x, &h3);
  ------------------
  |  |   92|   572k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  641|   572k|    secp256k1_fe_add(&r->x, &t);
  ------------------
  |  |   92|   572k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  642|   572k|    secp256k1_fe_add(&r->x, &t);
  ------------------
  |  |   92|   572k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  643|       |
  644|   572k|    secp256k1_fe_add(&t, &r->x);
  ------------------
  |  |   92|   572k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  645|   572k|    secp256k1_fe_mul(&r->y, &t, &i);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  646|   572k|    secp256k1_fe_mul(&h3, &h3, &s1);
  ------------------
  |  |   93|   572k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  647|   572k|    secp256k1_fe_add(&r->y, &h3);
  ------------------
  |  |   92|   572k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  648|       |
  649|   572k|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|   572k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  650|   572k|    if (rzr != NULL) SECP256K1_FE_VERIFY(rzr);
  ------------------
  |  |  344|   244k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  |  Branch (650:9): [True: 244k, False: 328k]
  ------------------
  651|   572k|}
secp256k1.c:secp256k1_gej_add_zinv_var:
  653|   131k|static void secp256k1_gej_add_zinv_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b, const secp256k1_fe *bzinv) {
  654|       |    /* Operations: 9 mul, 3 sqr, 11 add/negate/normalizes_to_zero (ignoring special cases) */
  655|   131k|    secp256k1_fe az, z12, u1, u2, s1, s2, h, i, h2, h3, t;
  656|   131k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|   131k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  657|   131k|    SECP256K1_GE_VERIFY(b);
  ------------------
  |  |  210|   131k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  658|   131k|    SECP256K1_FE_VERIFY(bzinv);
  ------------------
  |  |  344|   131k|#define SECP256K1_FE_VERIFY(a) secp256k1_fe_verify(a)
  ------------------
  659|       |
  660|   131k|    if (a->infinity) {
  ------------------
  |  Branch (660:9): [True: 3.22k, False: 128k]
  ------------------
  661|  3.22k|        secp256k1_fe bzinv2, bzinv3;
  662|  3.22k|        r->infinity = b->infinity;
  663|  3.22k|        secp256k1_fe_sqr(&bzinv2, bzinv);
  ------------------
  |  |   94|  3.22k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  664|  3.22k|        secp256k1_fe_mul(&bzinv3, &bzinv2, bzinv);
  ------------------
  |  |   93|  3.22k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  665|  3.22k|        secp256k1_fe_mul(&r->x, &b->x, &bzinv2);
  ------------------
  |  |   93|  3.22k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  666|  3.22k|        secp256k1_fe_mul(&r->y, &b->y, &bzinv3);
  ------------------
  |  |   93|  3.22k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  667|  3.22k|        secp256k1_fe_set_int(&r->z, 1);
  ------------------
  |  |   83|  3.22k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  668|  3.22k|        SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|  3.22k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  669|  3.22k|        return;
  670|  3.22k|    }
  671|   128k|    if (b->infinity) {
  ------------------
  |  Branch (671:9): [True: 0, False: 128k]
  ------------------
  672|      0|        *r = *a;
  673|      0|        return;
  674|      0|    }
  675|       |
  676|       |    /** We need to calculate (rx,ry,rz) = (ax,ay,az) + (bx,by,1/bzinv). Due to
  677|       |     *  secp256k1's isomorphism we can multiply the Z coordinates on both sides
  678|       |     *  by bzinv, and get: (rx,ry,rz*bzinv) = (ax,ay,az*bzinv) + (bx,by,1).
  679|       |     *  This means that (rx,ry,rz) can be calculated as
  680|       |     *  (ax,ay,az*bzinv) + (bx,by,1), when not applying the bzinv factor to rz.
  681|       |     *  The variable az below holds the modified Z coordinate for a, which is used
  682|       |     *  for the computation of rx and ry, but not for rz.
  683|       |     */
  684|   128k|    secp256k1_fe_mul(&az, &a->z, bzinv);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  685|       |
  686|   128k|    secp256k1_fe_sqr(&z12, &az);
  ------------------
  |  |   94|   128k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  687|   128k|    u1 = a->x;
  688|   128k|    secp256k1_fe_mul(&u2, &b->x, &z12);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  689|   128k|    s1 = a->y;
  690|   128k|    secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &az);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
                  secp256k1_fe_mul(&s2, &b->y, &z12); secp256k1_fe_mul(&s2, &s2, &az);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  691|   128k|    secp256k1_fe_negate(&h, &u1, SECP256K1_GEJ_X_MAGNITUDE_MAX); secp256k1_fe_add(&h, &u2);
  ------------------
  |  |  211|   128k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|   128k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|   128k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 128k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|   128k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 128k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|   128k|    } \
  |  |  |  |   84|   128k|    stmt; \
  |  |  |  |   85|   128k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 128k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  secp256k1_fe_negate(&h, &u1, SECP256K1_GEJ_X_MAGNITUDE_MAX); secp256k1_fe_add(&h, &u2);
  ------------------
  |  |   92|   128k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  692|   128k|    secp256k1_fe_negate(&i, &s2, 1); secp256k1_fe_add(&i, &s1);
  ------------------
  |  |  211|   128k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|   128k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|   128k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 128k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|   128k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 128k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|   128k|    } \
  |  |  |  |   84|   128k|    stmt; \
  |  |  |  |   85|   128k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 128k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  secp256k1_fe_negate(&i, &s2, 1); secp256k1_fe_add(&i, &s1);
  ------------------
  |  |   92|   128k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  693|   128k|    if (secp256k1_fe_normalizes_to_zero_var(&h)) {
  ------------------
  |  |   82|   128k|#  define secp256k1_fe_normalizes_to_zero_var secp256k1_fe_impl_normalizes_to_zero_var
  ------------------
  |  Branch (693:9): [True: 0, False: 128k]
  ------------------
  694|      0|        if (secp256k1_fe_normalizes_to_zero_var(&i)) {
  ------------------
  |  |   82|      0|#  define secp256k1_fe_normalizes_to_zero_var secp256k1_fe_impl_normalizes_to_zero_var
  ------------------
  |  Branch (694:13): [True: 0, False: 0]
  ------------------
  695|      0|            secp256k1_gej_double_var(r, a, NULL);
  696|      0|        } else {
  697|      0|            secp256k1_gej_set_infinity(r);
  698|      0|        }
  699|      0|        return;
  700|      0|    }
  701|       |
  702|   128k|    r->infinity = 0;
  703|   128k|    secp256k1_fe_mul(&r->z, &a->z, &h);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  704|       |
  705|   128k|    secp256k1_fe_sqr(&h2, &h);
  ------------------
  |  |   94|   128k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  706|   128k|    secp256k1_fe_negate(&h2, &h2, 1);
  ------------------
  |  |  211|   128k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|   128k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|   128k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 128k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|   128k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 128k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|   128k|    } \
  |  |  |  |   84|   128k|    stmt; \
  |  |  |  |   85|   128k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 128k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  707|   128k|    secp256k1_fe_mul(&h3, &h2, &h);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  708|   128k|    secp256k1_fe_mul(&t, &u1, &h2);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  709|       |
  710|   128k|    secp256k1_fe_sqr(&r->x, &i);
  ------------------
  |  |   94|   128k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  711|   128k|    secp256k1_fe_add(&r->x, &h3);
  ------------------
  |  |   92|   128k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  712|   128k|    secp256k1_fe_add(&r->x, &t);
  ------------------
  |  |   92|   128k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  713|   128k|    secp256k1_fe_add(&r->x, &t);
  ------------------
  |  |   92|   128k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  714|       |
  715|   128k|    secp256k1_fe_add(&t, &r->x);
  ------------------
  |  |   92|   128k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  716|   128k|    secp256k1_fe_mul(&r->y, &t, &i);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  717|   128k|    secp256k1_fe_mul(&h3, &h3, &s1);
  ------------------
  |  |   93|   128k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  718|   128k|    secp256k1_fe_add(&r->y, &h3);
  ------------------
  |  |   92|   128k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  719|       |
  720|   128k|    SECP256K1_GEJ_VERIFY(r);
  ------------------
  |  |  214|   128k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  721|   128k|}
secp256k1.c:secp256k1_ge_set_gej_var:
  177|  7.70k|static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {
  178|  7.70k|    secp256k1_fe z2, z3;
  179|  7.70k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  7.70k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  180|       |
  181|  7.70k|    if (secp256k1_gej_is_infinity(a)) {
  ------------------
  |  Branch (181:9): [True: 0, False: 7.70k]
  ------------------
  182|      0|        secp256k1_ge_set_infinity(r);
  183|      0|        return;
  184|      0|    }
  185|  7.70k|    r->infinity = 0;
  186|  7.70k|    secp256k1_fe_inv_var(&a->z, &a->z);
  ------------------
  |  |   99|  7.70k|#  define secp256k1_fe_inv_var secp256k1_fe_impl_inv_var
  ------------------
  187|  7.70k|    secp256k1_fe_sqr(&z2, &a->z);
  ------------------
  |  |   94|  7.70k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  188|  7.70k|    secp256k1_fe_mul(&z3, &a->z, &z2);
  ------------------
  |  |   93|  7.70k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  189|  7.70k|    secp256k1_fe_mul(&a->x, &a->x, &z2);
  ------------------
  |  |   93|  7.70k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  190|  7.70k|    secp256k1_fe_mul(&a->y, &a->y, &z3);
  ------------------
  |  |   93|  7.70k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  191|  7.70k|    secp256k1_fe_set_int(&a->z, 1);
  ------------------
  |  |   83|  7.70k|#  define secp256k1_fe_set_int secp256k1_fe_impl_set_int
  ------------------
  192|  7.70k|    secp256k1_ge_set_xy(r, &a->x, &a->y);
  193|       |
  194|  7.70k|    SECP256K1_GEJ_VERIFY(a);
  ------------------
  |  |  214|  7.70k|#define SECP256K1_GEJ_VERIFY(a) secp256k1_gej_verify(a)
  ------------------
  195|  7.70k|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|  7.70k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  196|  7.70k|}
secp256k1.c:secp256k1_ge_is_infinity:
  143|  81.9k|static int secp256k1_ge_is_infinity(const secp256k1_ge *a) {
  144|  81.9k|    SECP256K1_GE_VERIFY(a);
  ------------------
  |  |  210|  81.9k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  145|       |
  146|  81.9k|    return a->infinity;
  147|  81.9k|}
secp256k1.c:secp256k1_ge_mul_lambda:
  915|   202k|static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {
  916|   202k|    SECP256K1_GE_VERIFY(a);
  ------------------
  |  |  210|   202k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  917|       |
  918|   202k|    *r = *a;
  919|   202k|    secp256k1_fe_mul(&r->x, &r->x, &secp256k1_const_beta);
  ------------------
  |  |   93|   202k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  920|       |
  921|   202k|    SECP256K1_GE_VERIFY(r);
  ------------------
  |  |  210|   202k|#define SECP256K1_GE_VERIFY(a) secp256k1_ge_verify(a)
  ------------------
  922|   202k|}
secp256k1.c:secp256k1_ge_x_on_curve_var:
  948|  23.7k|static int secp256k1_ge_x_on_curve_var(const secp256k1_fe *x) {
  949|  23.7k|    secp256k1_fe c;
  950|  23.7k|    secp256k1_fe_sqr(&c, x);
  ------------------
  |  |   94|  23.7k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  951|  23.7k|    secp256k1_fe_mul(&c, &c, x);
  ------------------
  |  |   93|  23.7k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  952|  23.7k|    secp256k1_fe_add_int(&c, SECP256K1_B);
  ------------------
  |  |  102|  23.7k|#  define secp256k1_fe_add_int secp256k1_fe_impl_add_int
  ------------------
                  secp256k1_fe_add_int(&c, SECP256K1_B);
  ------------------
  |  |   73|  23.7k|#define SECP256K1_B 7
  ------------------
  953|  23.7k|    return secp256k1_fe_is_square_var(&c);
  ------------------
  |  |  103|  23.7k|#  define secp256k1_fe_is_square_var secp256k1_fe_impl_is_square_var
  ------------------
  954|  23.7k|}
secp256k1.c:secp256k1_ge_x_frac_on_curve_var:
  956|  22.7k|static int secp256k1_ge_x_frac_on_curve_var(const secp256k1_fe *xn, const secp256k1_fe *xd) {
  957|       |    /* We want to determine whether (xn/xd) is on the curve.
  958|       |     *
  959|       |     * (xn/xd)^3 + 7 is square <=> xd*xn^3 + 7*xd^4 is square (multiplying by xd^4, a square).
  960|       |     */
  961|  22.7k|     secp256k1_fe r, t;
  962|  22.7k|     VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(xd));
  963|       |
  964|  22.7k|     secp256k1_fe_mul(&r, xd, xn); /* r = xd*xn */
  ------------------
  |  |   93|  22.7k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  965|  22.7k|     secp256k1_fe_sqr(&t, xn); /* t = xn^2 */
  ------------------
  |  |   94|  22.7k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  966|  22.7k|     secp256k1_fe_mul(&r, &r, &t); /* r = xd*xn^3 */
  ------------------
  |  |   93|  22.7k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  967|  22.7k|     secp256k1_fe_sqr(&t, xd); /* t = xd^2 */
  ------------------
  |  |   94|  22.7k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  968|  22.7k|     secp256k1_fe_sqr(&t, &t); /* t = xd^4 */
  ------------------
  |  |   94|  22.7k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  969|  22.7k|     VERIFY_CHECK(SECP256K1_B <= 31);
  970|  22.7k|     secp256k1_fe_mul_int(&t, SECP256K1_B); /* t = 7*xd^4 */
  ------------------
  |  |  233|  22.7k|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  22.7k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  22.7k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 22.7k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  22.7k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 22.7k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  22.7k|    } \
  |  |  |  |   84|  22.7k|    stmt; \
  |  |  |  |   85|  22.7k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 22.7k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  971|  22.7k|     secp256k1_fe_add(&r, &t); /* r = xd*xn^3 + 7*xd^4 */
  ------------------
  |  |   92|  22.7k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  972|  22.7k|     return secp256k1_fe_is_square_var(&r);
  ------------------
  |  |  103|  22.7k|#  define secp256k1_fe_is_square_var secp256k1_fe_impl_is_square_var
  ------------------
  973|  22.7k|}

secp256k1.c:secp256k1_sha256_initialize:
   31|  43.9k|static void secp256k1_sha256_initialize(secp256k1_sha256 *hash) {
   32|  43.9k|    hash->s[0] = 0x6a09e667ul;
   33|  43.9k|    hash->s[1] = 0xbb67ae85ul;
   34|  43.9k|    hash->s[2] = 0x3c6ef372ul;
   35|  43.9k|    hash->s[3] = 0xa54ff53aul;
   36|  43.9k|    hash->s[4] = 0x510e527ful;
   37|  43.9k|    hash->s[5] = 0x9b05688cul;
   38|  43.9k|    hash->s[6] = 0x1f83d9abul;
   39|  43.9k|    hash->s[7] = 0x5be0cd19ul;
   40|  43.9k|    hash->bytes = 0;
   41|  43.9k|}
secp256k1.c:secp256k1_sha256_write:
  126|   369k|static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {
  127|   369k|    size_t bufsize = hash->bytes & 0x3F;
  128|   369k|    hash->bytes += len;
  129|   369k|    VERIFY_CHECK(hash->bytes >= len);
  130|   513k|    while (len >= 64 - bufsize) {
  ------------------
  |  Branch (130:12): [True: 144k, False: 369k]
  ------------------
  131|       |        /* Fill the buffer, and process it. */
  132|   144k|        size_t chunk_len = 64 - bufsize;
  133|   144k|        memcpy(hash->buf + bufsize, data, chunk_len);
  134|   144k|        data += chunk_len;
  135|   144k|        len -= chunk_len;
  136|   144k|        secp256k1_sha256_transform(hash->s, hash->buf);
  137|   144k|        bufsize = 0;
  138|   144k|    }
  139|   369k|    if (len) {
  ------------------
  |  Branch (139:9): [True: 224k, False: 144k]
  ------------------
  140|       |        /* Fill the buffer with what remains. */
  141|   224k|        memcpy(hash->buf + bufsize, data, len);
  142|   224k|    }
  143|   369k|}
secp256k1.c:secp256k1_sha256_transform:
   44|   144k|static void secp256k1_sha256_transform(uint32_t* s, const unsigned char* buf) {
   45|   144k|    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];
   46|   144k|    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;
   47|       |
   48|   144k|    Round(a, b, c, d, e, f, g, h, 0x428a2f98,  w0 = secp256k1_read_be32(&buf[0]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   49|   144k|    Round(h, a, b, c, d, e, f, g, 0x71374491,  w1 = secp256k1_read_be32(&buf[4]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   50|   144k|    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf,  w2 = secp256k1_read_be32(&buf[8]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   51|   144k|    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5,  w3 = secp256k1_read_be32(&buf[12]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   52|   144k|    Round(e, f, g, h, a, b, c, d, 0x3956c25b,  w4 = secp256k1_read_be32(&buf[16]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   53|   144k|    Round(d, e, f, g, h, a, b, c, 0x59f111f1,  w5 = secp256k1_read_be32(&buf[20]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   54|   144k|    Round(c, d, e, f, g, h, a, b, 0x923f82a4,  w6 = secp256k1_read_be32(&buf[24]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   55|   144k|    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5,  w7 = secp256k1_read_be32(&buf[28]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   56|   144k|    Round(a, b, c, d, e, f, g, h, 0xd807aa98,  w8 = secp256k1_read_be32(&buf[32]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   57|   144k|    Round(h, a, b, c, d, e, f, g, 0x12835b01,  w9 = secp256k1_read_be32(&buf[36]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   58|   144k|    Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = secp256k1_read_be32(&buf[40]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   59|   144k|    Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = secp256k1_read_be32(&buf[44]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   60|   144k|    Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = secp256k1_read_be32(&buf[48]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   61|   144k|    Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = secp256k1_read_be32(&buf[52]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   62|   144k|    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = secp256k1_read_be32(&buf[56]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   63|   144k|    Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = secp256k1_read_be32(&buf[60]));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   64|       |
   65|   144k|    Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += sigma1(w14) + w9 + sigma0(w1));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   66|   144k|    Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += sigma1(w15) + w10 + sigma0(w2));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   67|   144k|    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += sigma1(w0) + w11 + sigma0(w3));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   68|   144k|    Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += sigma1(w1) + w12 + sigma0(w4));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   69|   144k|    Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += sigma1(w2) + w13 + sigma0(w5));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   70|   144k|    Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += sigma1(w3) + w14 + sigma0(w6));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   71|   144k|    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += sigma1(w4) + w15 + sigma0(w7));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   72|   144k|    Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += sigma1(w5) + w0 + sigma0(w8));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   73|   144k|    Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += sigma1(w6) + w1 + sigma0(w9));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   74|   144k|    Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += sigma1(w7) + w2 + sigma0(w10));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   75|   144k|    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1(w8) + w3 + sigma0(w11));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   76|   144k|    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1(w9) + w4 + sigma0(w12));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   77|   144k|    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) + w5 + sigma0(w13));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   78|   144k|    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) + w6 + sigma0(w14));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   79|   144k|    Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) + w7 + sigma0(w15));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   80|   144k|    Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) + w8 + sigma0(w0));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   81|       |
   82|   144k|    Round(a, b, c, d, e, f, g, h, 0x27b70a85, w0 += sigma1(w14) + w9 + sigma0(w1));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   83|   144k|    Round(h, a, b, c, d, e, f, g, 0x2e1b2138, w1 += sigma1(w15) + w10 + sigma0(w2));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   84|   144k|    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w2 += sigma1(w0) + w11 + sigma0(w3));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   85|   144k|    Round(f, g, h, a, b, c, d, e, 0x53380d13, w3 += sigma1(w1) + w12 + sigma0(w4));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   86|   144k|    Round(e, f, g, h, a, b, c, d, 0x650a7354, w4 += sigma1(w2) + w13 + sigma0(w5));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   87|   144k|    Round(d, e, f, g, h, a, b, c, 0x766a0abb, w5 += sigma1(w3) + w14 + sigma0(w6));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   88|   144k|    Round(c, d, e, f, g, h, a, b, 0x81c2c92e, w6 += sigma1(w4) + w15 + sigma0(w7));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   89|   144k|    Round(b, c, d, e, f, g, h, a, 0x92722c85, w7 += sigma1(w5) + w0 + sigma0(w8));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   90|   144k|    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w8 += sigma1(w6) + w1 + sigma0(w9));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   91|   144k|    Round(h, a, b, c, d, e, f, g, 0xa81a664b, w9 += sigma1(w7) + w2 + sigma0(w10));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   92|   144k|    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1(w8) + w3 + sigma0(w11));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   93|   144k|    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1(w9) + w4 + sigma0(w12));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   94|   144k|    Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) + w5 + sigma0(w13));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   95|   144k|    Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) + w6 + sigma0(w14));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   96|   144k|    Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) + w7 + sigma0(w15));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   97|   144k|    Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) + w8 + sigma0(w0));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
   98|       |
   99|   144k|    Round(a, b, c, d, e, f, g, h, 0x19a4c116, w0 += sigma1(w14) + w9 + sigma0(w1));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  100|   144k|    Round(h, a, b, c, d, e, f, g, 0x1e376c08, w1 += sigma1(w15) + w10 + sigma0(w2));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  101|   144k|    Round(g, h, a, b, c, d, e, f, 0x2748774c, w2 += sigma1(w0) + w11 + sigma0(w3));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  102|   144k|    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5, w3 += sigma1(w1) + w12 + sigma0(w4));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  103|   144k|    Round(e, f, g, h, a, b, c, d, 0x391c0cb3, w4 += sigma1(w2) + w13 + sigma0(w5));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  104|   144k|    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w5 += sigma1(w3) + w14 + sigma0(w6));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  105|   144k|    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f, w6 += sigma1(w4) + w15 + sigma0(w7));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  106|   144k|    Round(b, c, d, e, f, g, h, a, 0x682e6ff3, w7 += sigma1(w5) + w0 + sigma0(w8));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  107|   144k|    Round(a, b, c, d, e, f, g, h, 0x748f82ee, w8 += sigma1(w6) + w1 + sigma0(w9));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  108|   144k|    Round(h, a, b, c, d, e, f, g, 0x78a5636f, w9 += sigma1(w7) + w2 + sigma0(w10));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  109|   144k|    Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1(w8) + w3 + sigma0(w11));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  110|   144k|    Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1(w9) + w4 + sigma0(w12));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  111|   144k|    Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) + w5 + sigma0(w13));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  112|   144k|    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) + w6 + sigma0(w14));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  113|   144k|    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14 + sigma1(w12) + w7 + sigma0(w15));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  114|   144k|    Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15 + sigma1(w13) + w8 + sigma0(w0));
  ------------------
  |  |   24|   144k|#define Round(a,b,c,d,e,f,g,h,k,w) do { \
  |  |   25|   144k|    uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   20|   144k|#define Sigma1(x) (((x) >> 6 | (x) << 26) ^ ((x) >> 11 | (x) << 21) ^ ((x) >> 25 | (x) << 7))
  |  |  ------------------
  |  |                   uint32_t t1 = (h) + Sigma1(e) + Ch((e), (f), (g)) + (k) + (w); \
  |  |  ------------------
  |  |  |  |   17|   144k|#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
  |  |  ------------------
  |  |   26|   144k|    uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   19|   144k|#define Sigma0(x) (((x) >> 2 | (x) << 30) ^ ((x) >> 13 | (x) << 19) ^ ((x) >> 22 | (x) << 10))
  |  |  ------------------
  |  |                   uint32_t t2 = Sigma0(a) + Maj((a), (b), (c)); \
  |  |  ------------------
  |  |  |  |   18|   144k|#define Maj(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))
  |  |  ------------------
  |  |   27|   144k|    (d) += t1; \
  |  |   28|   144k|    (h) = t1 + t2; \
  |  |   29|   144k|} while(0)
  |  |  ------------------
  |  |  |  Branch (29:9): [Folded, False: 144k]
  |  |  ------------------
  ------------------
  115|       |
  116|   144k|    s[0] += a;
  117|   144k|    s[1] += b;
  118|   144k|    s[2] += c;
  119|   144k|    s[3] += d;
  120|   144k|    s[4] += e;
  121|   144k|    s[5] += f;
  122|   144k|    s[6] += g;
  123|   144k|    s[7] += h;
  124|   144k|}
secp256k1.c:secp256k1_sha256_finalize:
  145|  91.5k|static void secp256k1_sha256_finalize(secp256k1_sha256 *hash, unsigned char *out32) {
  146|  91.5k|    static const unsigned char pad[64] = {0x80};
  147|  91.5k|    unsigned char sizedesc[8];
  148|  91.5k|    int i;
  149|       |    /* The maximum message size of SHA256 is 2^64-1 bits. */
  150|  91.5k|    VERIFY_CHECK(hash->bytes < ((uint64_t)1 << 61));
  151|  91.5k|    secp256k1_write_be32(&sizedesc[0], hash->bytes >> 29);
  152|  91.5k|    secp256k1_write_be32(&sizedesc[4], hash->bytes << 3);
  153|  91.5k|    secp256k1_sha256_write(hash, pad, 1 + ((119 - (hash->bytes % 64)) % 64));
  154|  91.5k|    secp256k1_sha256_write(hash, sizedesc, 8);
  155|   823k|    for (i = 0; i < 8; i++) {
  ------------------
  |  Branch (155:17): [True: 732k, False: 91.5k]
  ------------------
  156|   732k|        secp256k1_write_be32(&out32[4*i], hash->s[i]);
  157|   732k|        hash->s[i] = 0;
  158|   732k|    }
  159|  91.5k|}
secp256k1.c:secp256k1_sha256_clear:
  174|  16.0k|static void secp256k1_sha256_clear(secp256k1_sha256 *hash) {
  175|  16.0k|    secp256k1_memclear(hash, sizeof(*hash));
  176|  16.0k|}

secp256k1.c:secp256k1_u128_mul:
   11|   254M|static SECP256K1_INLINE void secp256k1_u128_mul(secp256k1_uint128 *r, uint64_t a, uint64_t b) {
   12|   254M|   *r = (uint128_t)a * b;
   13|   254M|}
secp256k1.c:secp256k1_u128_accum_mul:
   15|  1.96G|static SECP256K1_INLINE void secp256k1_u128_accum_mul(secp256k1_uint128 *r, uint64_t a, uint64_t b) {
   16|  1.96G|   *r += (uint128_t)a * b;
   17|  1.96G|}
secp256k1.c:secp256k1_u128_to_u64:
   28|  1.10G|static SECP256K1_INLINE uint64_t secp256k1_u128_to_u64(const secp256k1_uint128 *a) {
   29|  1.10G|   return (uint64_t)(*a);
   30|  1.10G|}
secp256k1.c:secp256k1_u128_rshift:
   23|   849M|static SECP256K1_INLINE void secp256k1_u128_rshift(secp256k1_uint128 *r, unsigned int n) {
   24|   849M|   VERIFY_CHECK(n < 128);
   25|   849M|   *r >>= n;
   26|   849M|}
secp256k1.c:secp256k1_u128_accum_u64:
   19|  89.2M|static SECP256K1_INLINE void secp256k1_u128_accum_u64(secp256k1_uint128 *r, uint64_t a) {
   20|  89.2M|   *r += a;
   21|  89.2M|}
secp256k1.c:secp256k1_u128_from_u64:
   36|   714k|static SECP256K1_INLINE void secp256k1_u128_from_u64(secp256k1_uint128 *r, uint64_t a) {
   37|   714k|   *r = a;
   38|   714k|}
secp256k1.c:secp256k1_i128_mul:
   49|  6.94M|static SECP256K1_INLINE void secp256k1_i128_mul(secp256k1_int128 *r, int64_t a, int64_t b) {
   50|  6.94M|   *r = (int128_t)a * b;
   51|  6.94M|}
secp256k1.c:secp256k1_i128_accum_mul:
   53|  54.0M|static SECP256K1_INLINE void secp256k1_i128_accum_mul(secp256k1_int128 *r, int64_t a, int64_t b) {
   54|  54.0M|   int128_t ab = (int128_t)a * b;
   55|  54.0M|   VERIFY_CHECK(0 <= ab ? *r <= INT128_MAX - ab : INT128_MIN - ab <= *r);
   56|  54.0M|   *r += ab;
   57|  54.0M|}
secp256k1.c:secp256k1_i128_to_u64:
   71|  23.5M|static SECP256K1_INLINE uint64_t secp256k1_i128_to_u64(const secp256k1_int128 *a) {
   72|  23.5M|   return (uint64_t)*a;
   73|  23.5M|}
secp256k1.c:secp256k1_i128_rshift:
   66|  28.2M|static SECP256K1_INLINE void secp256k1_i128_rshift(secp256k1_int128 *r, unsigned int n) {
   67|  28.2M|   VERIFY_CHECK(n < 128);
   68|  28.2M|   *r >>= n;
   69|  28.2M|}
secp256k1.c:secp256k1_i128_to_i64:
   75|  6.94M|static SECP256K1_INLINE int64_t secp256k1_i128_to_i64(const secp256k1_int128 *a) {
   76|  6.94M|   VERIFY_CHECK(INT64_MIN <= *a && *a <= INT64_MAX);
   77|  6.94M|   return *a;
   78|  6.94M|}

secp256k1.c:secp256k1_modinv64_var:
  637|  23.7k|static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {
  638|       |    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */
  639|  23.7k|    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};
  640|  23.7k|    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};
  641|  23.7k|    secp256k1_modinv64_signed62 f = modinfo->modulus;
  642|  23.7k|    secp256k1_modinv64_signed62 g = *x;
  643|       |#ifdef VERIFY
  644|       |    int i = 0;
  645|       |#endif
  646|  23.7k|    int j, len = 5;
  647|  23.7k|    int64_t eta = -1; /* eta = -delta; delta is initially 1 */
  648|  23.7k|    int64_t cond, fn, gn;
  649|       |
  650|       |    /* Do iterations of 62 divsteps each until g=0. */
  651|   213k|    while (1) {
  ------------------
  |  Branch (651:12): [True: 213k, Folded]
  ------------------
  652|       |        /* Compute transition matrix and new eta after 62 divsteps. */
  653|   213k|        secp256k1_modinv64_trans2x2 t;
  654|   213k|        eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);
  655|       |        /* Update d,e using that transition matrix. */
  656|   213k|        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);
  657|       |        /* Update f,g using that transition matrix. */
  658|   213k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */
  659|   213k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */
  660|   213k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */
  661|   213k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */
  662|       |
  663|   213k|        secp256k1_modinv64_update_fg_62_var(len, &f, &g, &t);
  664|       |        /* If the bottom limb of g is zero, there is a chance that g=0. */
  665|   213k|        if (g.v[0] == 0) {
  ------------------
  |  Branch (665:13): [True: 23.7k, False: 189k]
  ------------------
  666|  23.7k|            cond = 0;
  667|       |            /* Check if the other limbs are also 0. */
  668|  23.7k|            for (j = 1; j < len; ++j) {
  ------------------
  |  Branch (668:25): [True: 0, False: 23.7k]
  ------------------
  669|      0|                cond |= g.v[j];
  670|      0|            }
  671|       |            /* If so, we're done. */
  672|  23.7k|            if (cond == 0) break;
  ------------------
  |  Branch (672:17): [True: 23.7k, False: 0]
  ------------------
  673|  23.7k|        }
  674|       |
  675|       |        /* Determine if len>1 and limb (len-1) of both f and g is 0 or -1. */
  676|   189k|        fn = f.v[len - 1];
  677|   189k|        gn = g.v[len - 1];
  678|   189k|        cond = ((int64_t)len - 2) >> 63;
  679|   189k|        cond |= fn ^ (fn >> 63);
  680|   189k|        cond |= gn ^ (gn >> 63);
  681|       |        /* If so, reduce length, propagating the sign of f and g's top limb into the one below. */
  682|   189k|        if (cond == 0) {
  ------------------
  |  Branch (682:13): [True: 94.8k, False: 94.8k]
  ------------------
  683|  94.8k|            f.v[len - 2] |= (uint64_t)fn << 62;
  684|  94.8k|            g.v[len - 2] |= (uint64_t)gn << 62;
  685|  94.8k|            --len;
  686|  94.8k|        }
  687|       |
  688|   189k|        VERIFY_CHECK(++i < 12); /* We should never need more than 12*62 = 744 divsteps */
  689|   189k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */
  690|   189k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */
  691|   189k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */
  692|   189k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g <  modulus */
  693|   189k|    }
  694|       |
  695|       |    /* At this point g is 0 and (if g was not originally 0) f must now equal +/- GCD of
  696|       |     * the initial f, g values i.e. +/- 1, and d now contains +/- the modular inverse. */
  697|       |
  698|       |    /* g == 0 */
  699|  23.7k|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &SECP256K1_SIGNED62_ONE, 0) == 0);
  700|       |    /* |f| == 1, or (x == 0 and d == 0 and f == modulus) */
  701|  23.7k|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &SECP256K1_SIGNED62_ONE, -1) == 0 ||
  702|  23.7k|                 secp256k1_modinv64_mul_cmp_62(&f, len, &SECP256K1_SIGNED62_ONE, 1) == 0 ||
  703|  23.7k|                 (secp256k1_modinv64_mul_cmp_62(x, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&
  704|  23.7k|                  secp256k1_modinv64_mul_cmp_62(&d, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&
  705|  23.7k|                  secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) == 0));
  706|       |
  707|       |    /* Optionally negate d, normalize to [0,modulus), and return it. */
  708|  23.7k|    secp256k1_modinv64_normalize_62(&d, f.v[len - 1], modinfo);
  709|  23.7k|    *x = d;
  710|  23.7k|}
secp256k1.c:secp256k1_modinv64_divsteps_62_var:
  239|   213k|static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {
  240|       |    /* Transformation matrix; see comments in secp256k1_modinv64_divsteps_62. */
  241|   213k|    uint64_t u = 1, v = 0, q = 0, r = 1;
  242|   213k|    uint64_t f = f0, g = g0, m;
  243|   213k|    uint32_t w;
  244|   213k|    int i = 62, limit, zeros;
  245|       |
  246|  3.49M|    for (;;) {
  247|       |        /* Use a sentinel bit to count zeros only up to i. */
  248|  3.49M|        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));
  249|       |        /* Perform zeros divsteps at once; they all just divide g by two. */
  250|  3.49M|        g >>= zeros;
  251|  3.49M|        u <<= zeros;
  252|  3.49M|        v <<= zeros;
  253|  3.49M|        eta -= zeros;
  254|  3.49M|        i -= zeros;
  255|       |        /* We're done once we've done 62 divsteps. */
  256|  3.49M|        if (i == 0) break;
  ------------------
  |  Branch (256:13): [True: 213k, False: 3.27M]
  ------------------
  257|  3.27M|        VERIFY_CHECK((f & 1) == 1);
  258|  3.27M|        VERIFY_CHECK((g & 1) == 1);
  259|  3.27M|        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));
  260|  3.27M|        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));
  261|       |        /* Bounds on eta that follow from the bounds on iteration count (max 12*62 divsteps). */
  262|  3.27M|        VERIFY_CHECK(eta >= -745 && eta <= 745);
  263|       |        /* If eta is negative, negate it and replace f,g with g,-f. */
  264|  3.27M|        if (eta < 0) {
  ------------------
  |  Branch (264:13): [True: 3.16M, False: 113k]
  ------------------
  265|  3.16M|            uint64_t tmp;
  266|  3.16M|            eta = -eta;
  267|  3.16M|            tmp = f; f = g; g = -tmp;
  268|  3.16M|            tmp = u; u = q; q = -tmp;
  269|  3.16M|            tmp = v; v = r; r = -tmp;
  270|       |            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled
  271|       |             * out (as we'd be done before that point), and no more than eta+1 can be done as its
  272|       |             * sign will flip again once that happens. */
  273|  3.16M|            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);
  ------------------
  |  Branch (273:21): [True: 63.3k, False: 3.10M]
  ------------------
  274|  3.16M|            VERIFY_CHECK(limit > 0 && limit <= 62);
  275|       |            /* m is a mask for the bottom min(limit, 6) bits. */
  276|  3.16M|            m = (UINT64_MAX >> (64 - limit)) & 63U;
  277|       |            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)
  278|       |             * bits. */
  279|  3.16M|            w = (f * g * (f * f - 2)) & m;
  280|  3.16M|        } else {
  281|       |            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as
  282|       |             * eta tends to be smaller here. */
  283|   113k|            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);
  ------------------
  |  Branch (283:21): [True: 656, False: 112k]
  ------------------
  284|   113k|            VERIFY_CHECK(limit > 0 && limit <= 62);
  285|       |            /* m is a mask for the bottom min(limit, 4) bits. */
  286|   113k|            m = (UINT64_MAX >> (64 - limit)) & 15U;
  287|       |            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 4)
  288|       |             * bits. */
  289|   113k|            w = f + (((f + 1) & 4) << 1);
  290|   113k|            w = (-w * g) & m;
  291|   113k|        }
  292|  3.27M|        g += f * w;
  293|  3.27M|        q += u * w;
  294|  3.27M|        r += v * w;
  295|  3.27M|        VERIFY_CHECK((g & m) == 0);
  296|  3.27M|    }
  297|       |    /* Return data in t and return value. */
  298|   213k|    t->u = (int64_t)u;
  299|   213k|    t->v = (int64_t)v;
  300|   213k|    t->q = (int64_t)q;
  301|   213k|    t->r = (int64_t)r;
  302|       |
  303|       |    /* The determinant of t must be a power of two. This guarantees that multiplication with t
  304|       |     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which
  305|       |     * will be divided out again). As each divstep's individual matrix has determinant 2, the
  306|       |     * aggregate of 62 of them will have determinant 2^62. */
  307|   213k|    VERIFY_CHECK(secp256k1_modinv64_det_check_pow2(t, 62, 0));
  308|       |
  309|   213k|    return eta;
  310|   213k|}
secp256k1.c:secp256k1_modinv64_update_de_62:
  411|  1.13M|static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {
  412|  1.13M|    const uint64_t M62 = UINT64_MAX >> 2;
  413|  1.13M|    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];
  414|  1.13M|    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];
  415|  1.13M|    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;
  416|  1.13M|    int64_t md, me, sd, se;
  417|  1.13M|    secp256k1_int128 cd, ce;
  418|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, -2) > 0); /* d > -2*modulus */
  419|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, 1) < 0);  /* d <    modulus */
  420|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, -2) > 0); /* e > -2*modulus */
  421|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, 1) < 0);  /* e <    modulus */
  422|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_abs(u) <= (((int64_t)1 << 62) - secp256k1_modinv64_abs(v))); /* |u|+|v| <= 2^62 */
  423|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_abs(q) <= (((int64_t)1 << 62) - secp256k1_modinv64_abs(r))); /* |q|+|r| <= 2^62 */
  424|       |
  425|       |    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */
  426|  1.13M|    sd = d4 >> 63;
  427|  1.13M|    se = e4 >> 63;
  428|  1.13M|    md = (u & sd) + (v & se);
  429|  1.13M|    me = (q & sd) + (r & se);
  430|       |    /* Begin computing t*[d,e]. */
  431|  1.13M|    secp256k1_i128_mul(&cd, u, d0);
  432|  1.13M|    secp256k1_i128_accum_mul(&cd, v, e0);
  433|  1.13M|    secp256k1_i128_mul(&ce, q, d0);
  434|  1.13M|    secp256k1_i128_accum_mul(&ce, r, e0);
  435|       |    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */
  436|  1.13M|    md -= (modinfo->modulus_inv62 * secp256k1_i128_to_u64(&cd) + md) & M62;
  437|  1.13M|    me -= (modinfo->modulus_inv62 * secp256k1_i128_to_u64(&ce) + me) & M62;
  438|       |    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */
  439|  1.13M|    secp256k1_i128_accum_mul(&cd, modinfo->modulus.v[0], md);
  440|  1.13M|    secp256k1_i128_accum_mul(&ce, modinfo->modulus.v[0], me);
  441|       |    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */
  442|  1.13M|    VERIFY_CHECK((secp256k1_i128_to_u64(&cd) & M62) == 0); secp256k1_i128_rshift(&cd, 62);
  443|  1.13M|    VERIFY_CHECK((secp256k1_i128_to_u64(&ce) & M62) == 0); secp256k1_i128_rshift(&ce, 62);
  444|       |    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */
  445|  1.13M|    secp256k1_i128_accum_mul(&cd, u, d1);
  446|  1.13M|    secp256k1_i128_accum_mul(&cd, v, e1);
  447|  1.13M|    secp256k1_i128_accum_mul(&ce, q, d1);
  448|  1.13M|    secp256k1_i128_accum_mul(&ce, r, e1);
  449|  1.13M|    if (modinfo->modulus.v[1]) { /* Optimize for the case where limb of modulus is zero. */
  ------------------
  |  Branch (449:9): [True: 0, False: 1.13M]
  ------------------
  450|      0|        secp256k1_i128_accum_mul(&cd, modinfo->modulus.v[1], md);
  451|      0|        secp256k1_i128_accum_mul(&ce, modinfo->modulus.v[1], me);
  452|      0|    }
  453|  1.13M|    d->v[0] = secp256k1_i128_to_u64(&cd) & M62; secp256k1_i128_rshift(&cd, 62);
  454|  1.13M|    e->v[0] = secp256k1_i128_to_u64(&ce) & M62; secp256k1_i128_rshift(&ce, 62);
  455|       |    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */
  456|  1.13M|    secp256k1_i128_accum_mul(&cd, u, d2);
  457|  1.13M|    secp256k1_i128_accum_mul(&cd, v, e2);
  458|  1.13M|    secp256k1_i128_accum_mul(&ce, q, d2);
  459|  1.13M|    secp256k1_i128_accum_mul(&ce, r, e2);
  460|  1.13M|    if (modinfo->modulus.v[2]) { /* Optimize for the case where limb of modulus is zero. */
  ------------------
  |  Branch (460:9): [True: 0, False: 1.13M]
  ------------------
  461|      0|        secp256k1_i128_accum_mul(&cd, modinfo->modulus.v[2], md);
  462|      0|        secp256k1_i128_accum_mul(&ce, modinfo->modulus.v[2], me);
  463|      0|    }
  464|  1.13M|    d->v[1] = secp256k1_i128_to_u64(&cd) & M62; secp256k1_i128_rshift(&cd, 62);
  465|  1.13M|    e->v[1] = secp256k1_i128_to_u64(&ce) & M62; secp256k1_i128_rshift(&ce, 62);
  466|       |    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */
  467|  1.13M|    secp256k1_i128_accum_mul(&cd, u, d3);
  468|  1.13M|    secp256k1_i128_accum_mul(&cd, v, e3);
  469|  1.13M|    secp256k1_i128_accum_mul(&ce, q, d3);
  470|  1.13M|    secp256k1_i128_accum_mul(&ce, r, e3);
  471|  1.13M|    if (modinfo->modulus.v[3]) { /* Optimize for the case where limb of modulus is zero. */
  ------------------
  |  Branch (471:9): [True: 0, False: 1.13M]
  ------------------
  472|      0|        secp256k1_i128_accum_mul(&cd, modinfo->modulus.v[3], md);
  473|      0|        secp256k1_i128_accum_mul(&ce, modinfo->modulus.v[3], me);
  474|      0|    }
  475|  1.13M|    d->v[2] = secp256k1_i128_to_u64(&cd) & M62; secp256k1_i128_rshift(&cd, 62);
  476|  1.13M|    e->v[2] = secp256k1_i128_to_u64(&ce) & M62; secp256k1_i128_rshift(&ce, 62);
  477|       |    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */
  478|  1.13M|    secp256k1_i128_accum_mul(&cd, u, d4);
  479|  1.13M|    secp256k1_i128_accum_mul(&cd, v, e4);
  480|  1.13M|    secp256k1_i128_accum_mul(&ce, q, d4);
  481|  1.13M|    secp256k1_i128_accum_mul(&ce, r, e4);
  482|  1.13M|    secp256k1_i128_accum_mul(&cd, modinfo->modulus.v[4], md);
  483|  1.13M|    secp256k1_i128_accum_mul(&ce, modinfo->modulus.v[4], me);
  484|  1.13M|    d->v[3] = secp256k1_i128_to_u64(&cd) & M62; secp256k1_i128_rshift(&cd, 62);
  485|  1.13M|    e->v[3] = secp256k1_i128_to_u64(&ce) & M62; secp256k1_i128_rshift(&ce, 62);
  486|       |    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */
  487|  1.13M|    d->v[4] = secp256k1_i128_to_i64(&cd);
  488|  1.13M|    e->v[4] = secp256k1_i128_to_i64(&ce);
  489|       |
  490|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, -2) > 0); /* d > -2*modulus */
  491|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(d, 5, &modinfo->modulus, 1) < 0);  /* d <    modulus */
  492|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, -2) > 0); /* e > -2*modulus */
  493|  1.13M|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(e, 5, &modinfo->modulus, 1) < 0);  /* e <    modulus */
  494|  1.13M|}
secp256k1.c:secp256k1_modinv64_update_fg_62_var:
  553|  1.42M|static void secp256k1_modinv64_update_fg_62_var(int len, secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {
  554|  1.42M|    const uint64_t M62 = UINT64_MAX >> 2;
  555|  1.42M|    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;
  556|  1.42M|    int64_t fi, gi;
  557|  1.42M|    secp256k1_int128 cf, cg;
  558|  1.42M|    int i;
  559|  1.42M|    VERIFY_CHECK(len > 0);
  560|       |    /* Start computing t*[f,g]. */
  561|  1.42M|    fi = f->v[0];
  562|  1.42M|    gi = g->v[0];
  563|  1.42M|    secp256k1_i128_mul(&cf, u, fi);
  564|  1.42M|    secp256k1_i128_accum_mul(&cf, v, gi);
  565|  1.42M|    secp256k1_i128_mul(&cg, q, fi);
  566|  1.42M|    secp256k1_i128_accum_mul(&cg, r, gi);
  567|       |    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */
  568|  1.42M|    VERIFY_CHECK((secp256k1_i128_to_u64(&cf) & M62) == 0); secp256k1_i128_rshift(&cf, 62);
  569|  1.42M|    VERIFY_CHECK((secp256k1_i128_to_u64(&cg) & M62) == 0); secp256k1_i128_rshift(&cg, 62);
  570|       |    /* Now iteratively compute limb i=1..len of t*[f,g], and store them in output limb i-1 (shifting
  571|       |     * down by 62 bits). */
  572|  3.86M|    for (i = 1; i < len; ++i) {
  ------------------
  |  Branch (572:17): [True: 2.44M, False: 1.42M]
  ------------------
  573|  2.44M|        fi = f->v[i];
  574|  2.44M|        gi = g->v[i];
  575|  2.44M|        secp256k1_i128_accum_mul(&cf, u, fi);
  576|  2.44M|        secp256k1_i128_accum_mul(&cf, v, gi);
  577|  2.44M|        secp256k1_i128_accum_mul(&cg, q, fi);
  578|  2.44M|        secp256k1_i128_accum_mul(&cg, r, gi);
  579|  2.44M|        f->v[i - 1] = secp256k1_i128_to_u64(&cf) & M62; secp256k1_i128_rshift(&cf, 62);
  580|  2.44M|        g->v[i - 1] = secp256k1_i128_to_u64(&cg) & M62; secp256k1_i128_rshift(&cg, 62);
  581|  2.44M|    }
  582|       |    /* What remains is limb (len) of t*[f,g]; store it as output limb (len-1). */
  583|  1.42M|    f->v[len - 1] = secp256k1_i128_to_i64(&cf);
  584|  1.42M|    g->v[len - 1] = secp256k1_i128_to_i64(&cg);
  585|  1.42M|}
secp256k1.c:secp256k1_modinv64_normalize_62:
   88|   115k|static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {
   89|   115k|    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);
   90|   115k|    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];
   91|   115k|    volatile int64_t cond_add, cond_negate;
   92|       |
   93|       |#ifdef VERIFY
   94|       |    /* Verify that all limbs are in range (-2^62,2^62). */
   95|       |    int i;
   96|       |    for (i = 0; i < 5; ++i) {
   97|       |        VERIFY_CHECK(r->v[i] >= -M62);
   98|       |        VERIFY_CHECK(r->v[i] <= M62);
   99|       |    }
  100|       |    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */
  101|       |    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */
  102|       |#endif
  103|       |
  104|       |    /* In a first step, add the modulus if the input is negative, and then negate if requested.
  105|       |     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input
  106|       |     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right
  107|       |     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is
  108|       |     * indeed the behavior of the right shift operator). */
  109|   115k|    cond_add = r4 >> 63;
  110|   115k|    r0 += modinfo->modulus.v[0] & cond_add;
  111|   115k|    r1 += modinfo->modulus.v[1] & cond_add;
  112|   115k|    r2 += modinfo->modulus.v[2] & cond_add;
  113|   115k|    r3 += modinfo->modulus.v[3] & cond_add;
  114|   115k|    r4 += modinfo->modulus.v[4] & cond_add;
  115|   115k|    cond_negate = sign >> 63;
  116|   115k|    r0 = (r0 ^ cond_negate) - cond_negate;
  117|   115k|    r1 = (r1 ^ cond_negate) - cond_negate;
  118|   115k|    r2 = (r2 ^ cond_negate) - cond_negate;
  119|   115k|    r3 = (r3 ^ cond_negate) - cond_negate;
  120|   115k|    r4 = (r4 ^ cond_negate) - cond_negate;
  121|       |    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */
  122|   115k|    r1 += r0 >> 62; r0 &= M62;
  123|   115k|    r2 += r1 >> 62; r1 &= M62;
  124|   115k|    r3 += r2 >> 62; r2 &= M62;
  125|   115k|    r4 += r3 >> 62; r3 &= M62;
  126|       |
  127|       |    /* In a second step add the modulus again if the result is still negative, bringing
  128|       |     * r to range [0,modulus). */
  129|   115k|    cond_add = r4 >> 63;
  130|   115k|    r0 += modinfo->modulus.v[0] & cond_add;
  131|   115k|    r1 += modinfo->modulus.v[1] & cond_add;
  132|   115k|    r2 += modinfo->modulus.v[2] & cond_add;
  133|   115k|    r3 += modinfo->modulus.v[3] & cond_add;
  134|   115k|    r4 += modinfo->modulus.v[4] & cond_add;
  135|       |    /* And propagate again. */
  136|   115k|    r1 += r0 >> 62; r0 &= M62;
  137|   115k|    r2 += r1 >> 62; r1 &= M62;
  138|   115k|    r3 += r2 >> 62; r2 &= M62;
  139|   115k|    r4 += r3 >> 62; r3 &= M62;
  140|       |
  141|   115k|    r->v[0] = r0;
  142|   115k|    r->v[1] = r1;
  143|   115k|    r->v[2] = r2;
  144|   115k|    r->v[3] = r3;
  145|   115k|    r->v[4] = r4;
  146|       |
  147|   115k|    VERIFY_CHECK(r0 >> 62 == 0);
  148|   115k|    VERIFY_CHECK(r1 >> 62 == 0);
  149|   115k|    VERIFY_CHECK(r2 >> 62 == 0);
  150|   115k|    VERIFY_CHECK(r3 >> 62 == 0);
  151|   115k|    VERIFY_CHECK(r4 >> 62 == 0);
  152|   115k|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */
  153|   115k|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */
  154|   115k|}
secp256k1.c:secp256k1_modinv64:
  588|  91.8k|static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {
  589|       |    /* Start with d=0, e=1, f=modulus, g=x, zeta=-1. */
  590|  91.8k|    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};
  591|  91.8k|    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};
  592|  91.8k|    secp256k1_modinv64_signed62 f = modinfo->modulus;
  593|  91.8k|    secp256k1_modinv64_signed62 g = *x;
  594|  91.8k|    int i;
  595|  91.8k|    int64_t zeta = -1; /* zeta = -(delta+1/2); delta starts at 1/2. */
  596|       |
  597|       |    /* Do 10 iterations of 59 divsteps each = 590 divsteps. This suffices for 256-bit inputs. */
  598|  1.01M|    for (i = 0; i < 10; ++i) {
  ------------------
  |  Branch (598:17): [True: 918k, False: 91.8k]
  ------------------
  599|       |        /* Compute transition matrix and new zeta after 59 divsteps. */
  600|   918k|        secp256k1_modinv64_trans2x2 t;
  601|   918k|        zeta = secp256k1_modinv64_divsteps_59(zeta, f.v[0], g.v[0], &t);
  602|       |        /* Update d,e using that transition matrix. */
  603|   918k|        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);
  604|       |        /* Update f,g using that transition matrix. */
  605|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) > 0); /* f > -modulus */
  606|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) <= 0); /* f <= modulus */
  607|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, -1) > 0); /* g > -modulus */
  608|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, 1) < 0);  /* g <  modulus */
  609|       |
  610|   918k|        secp256k1_modinv64_update_fg_62(&f, &g, &t);
  611|       |
  612|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, -1) > 0); /* f > -modulus */
  613|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) <= 0); /* f <= modulus */
  614|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, -1) > 0); /* g > -modulus */
  615|   918k|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &modinfo->modulus, 1) < 0);  /* g <  modulus */
  616|   918k|    }
  617|       |
  618|       |    /* At this point sufficient iterations have been performed that g must have reached 0
  619|       |     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g
  620|       |     * values i.e. +/- 1, and d now contains +/- the modular inverse. */
  621|       |
  622|       |    /* g == 0 */
  623|  91.8k|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, 5, &SECP256K1_SIGNED62_ONE, 0) == 0);
  624|       |    /* |f| == 1, or (x == 0 and d == 0 and f == modulus) */
  625|  91.8k|    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, 5, &SECP256K1_SIGNED62_ONE, -1) == 0 ||
  626|  91.8k|                 secp256k1_modinv64_mul_cmp_62(&f, 5, &SECP256K1_SIGNED62_ONE, 1) == 0 ||
  627|  91.8k|                 (secp256k1_modinv64_mul_cmp_62(x, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&
  628|  91.8k|                  secp256k1_modinv64_mul_cmp_62(&d, 5, &SECP256K1_SIGNED62_ONE, 0) == 0 &&
  629|  91.8k|                  secp256k1_modinv64_mul_cmp_62(&f, 5, &modinfo->modulus, 1) == 0));
  630|       |
  631|       |    /* Optionally negate d, normalize to [0,modulus), and return it. */
  632|  91.8k|    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);
  633|  91.8k|    *x = d;
  634|  91.8k|}
secp256k1.c:secp256k1_modinv64_divsteps_59:
  167|   918k|static int64_t secp256k1_modinv64_divsteps_59(int64_t zeta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {
  168|       |    /* u,v,q,r are the elements of the transformation matrix being built up,
  169|       |     * starting with the identity matrix times 8 (because the caller expects
  170|       |     * a result scaled by 2^62). Semantically they are signed integers
  171|       |     * in range [-2^62,2^62], but here represented as unsigned mod 2^64. This
  172|       |     * permits left shifting (which is UB for negative numbers). The range
  173|       |     * being inside [-2^63,2^63) means that casting to signed works correctly.
  174|       |     */
  175|   918k|    uint64_t u = 8, v = 0, q = 0, r = 8;
  176|   918k|    volatile uint64_t c1, c2;
  177|   918k|    uint64_t mask1, mask2, f = f0, g = g0, x, y, z;
  178|   918k|    int i;
  179|       |
  180|  55.1M|    for (i = 3; i < 62; ++i) {
  ------------------
  |  Branch (180:17): [True: 54.1M, False: 918k]
  ------------------
  181|  54.1M|        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */
  182|  54.1M|        VERIFY_CHECK((u * f0 + v * g0) == f << i);
  183|  54.1M|        VERIFY_CHECK((q * f0 + r * g0) == g << i);
  184|       |        /* Compute conditional masks for (zeta < 0) and for (g & 1). */
  185|  54.1M|        c1 = zeta >> 63;
  186|  54.1M|        mask1 = c1;
  187|  54.1M|        c2 = g & 1;
  188|  54.1M|        mask2 = -c2;
  189|       |        /* Compute x,y,z, conditionally negated versions of f,u,v. */
  190|  54.1M|        x = (f ^ mask1) - mask1;
  191|  54.1M|        y = (u ^ mask1) - mask1;
  192|  54.1M|        z = (v ^ mask1) - mask1;
  193|       |        /* Conditionally add x,y,z to g,q,r. */
  194|  54.1M|        g += x & mask2;
  195|  54.1M|        q += y & mask2;
  196|  54.1M|        r += z & mask2;
  197|       |        /* In what follows, c1 is a condition mask for (zeta < 0) and (g & 1). */
  198|  54.1M|        mask1 &= mask2;
  199|       |        /* Conditionally change zeta into -zeta-2 or zeta-1. */
  200|  54.1M|        zeta = (zeta ^ mask1) - 1;
  201|       |        /* Conditionally add g,q,r to f,u,v. */
  202|  54.1M|        f += g & mask1;
  203|  54.1M|        u += q & mask1;
  204|  54.1M|        v += r & mask1;
  205|       |        /* Shifts */
  206|  54.1M|        g >>= 1;
  207|  54.1M|        u <<= 1;
  208|  54.1M|        v <<= 1;
  209|       |        /* Bounds on zeta that follow from the bounds on iteration count (max 10*59 divsteps). */
  210|  54.1M|        VERIFY_CHECK(zeta >= -591 && zeta <= 591);
  211|  54.1M|    }
  212|       |    /* Return data in t and return value. */
  213|   918k|    t->u = (int64_t)u;
  214|   918k|    t->v = (int64_t)v;
  215|   918k|    t->q = (int64_t)q;
  216|   918k|    t->r = (int64_t)r;
  217|       |
  218|       |    /* The determinant of t must be a power of two. This guarantees that multiplication with t
  219|       |     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which
  220|       |     * will be divided out again). As each divstep's individual matrix has determinant 2, the
  221|       |     * aggregate of 59 of them will have determinant 2^59. Multiplying with the initial
  222|       |     * 8*identity (which has determinant 2^6) means the overall outputs has determinant
  223|       |     * 2^65. */
  224|   918k|    VERIFY_CHECK(secp256k1_modinv64_det_check_pow2(t, 65, 0));
  225|       |
  226|   918k|    return zeta;
  227|   918k|}
secp256k1.c:secp256k1_modinv64_update_fg_62:
  500|   918k|static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {
  501|   918k|    const uint64_t M62 = UINT64_MAX >> 2;
  502|   918k|    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];
  503|   918k|    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];
  504|   918k|    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;
  505|   918k|    secp256k1_int128 cf, cg;
  506|       |    /* Start computing t*[f,g]. */
  507|   918k|    secp256k1_i128_mul(&cf, u, f0);
  508|   918k|    secp256k1_i128_accum_mul(&cf, v, g0);
  509|   918k|    secp256k1_i128_mul(&cg, q, f0);
  510|   918k|    secp256k1_i128_accum_mul(&cg, r, g0);
  511|       |    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */
  512|   918k|    VERIFY_CHECK((secp256k1_i128_to_u64(&cf) & M62) == 0); secp256k1_i128_rshift(&cf, 62);
  513|   918k|    VERIFY_CHECK((secp256k1_i128_to_u64(&cg) & M62) == 0); secp256k1_i128_rshift(&cg, 62);
  514|       |    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */
  515|   918k|    secp256k1_i128_accum_mul(&cf, u, f1);
  516|   918k|    secp256k1_i128_accum_mul(&cf, v, g1);
  517|   918k|    secp256k1_i128_accum_mul(&cg, q, f1);
  518|   918k|    secp256k1_i128_accum_mul(&cg, r, g1);
  519|   918k|    f->v[0] = secp256k1_i128_to_u64(&cf) & M62; secp256k1_i128_rshift(&cf, 62);
  520|   918k|    g->v[0] = secp256k1_i128_to_u64(&cg) & M62; secp256k1_i128_rshift(&cg, 62);
  521|       |    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */
  522|   918k|    secp256k1_i128_accum_mul(&cf, u, f2);
  523|   918k|    secp256k1_i128_accum_mul(&cf, v, g2);
  524|   918k|    secp256k1_i128_accum_mul(&cg, q, f2);
  525|   918k|    secp256k1_i128_accum_mul(&cg, r, g2);
  526|   918k|    f->v[1] = secp256k1_i128_to_u64(&cf) & M62; secp256k1_i128_rshift(&cf, 62);
  527|   918k|    g->v[1] = secp256k1_i128_to_u64(&cg) & M62; secp256k1_i128_rshift(&cg, 62);
  528|       |    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */
  529|   918k|    secp256k1_i128_accum_mul(&cf, u, f3);
  530|   918k|    secp256k1_i128_accum_mul(&cf, v, g3);
  531|   918k|    secp256k1_i128_accum_mul(&cg, q, f3);
  532|   918k|    secp256k1_i128_accum_mul(&cg, r, g3);
  533|   918k|    f->v[2] = secp256k1_i128_to_u64(&cf) & M62; secp256k1_i128_rshift(&cf, 62);
  534|   918k|    g->v[2] = secp256k1_i128_to_u64(&cg) & M62; secp256k1_i128_rshift(&cg, 62);
  535|       |    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */
  536|   918k|    secp256k1_i128_accum_mul(&cf, u, f4);
  537|   918k|    secp256k1_i128_accum_mul(&cf, v, g4);
  538|   918k|    secp256k1_i128_accum_mul(&cg, q, f4);
  539|   918k|    secp256k1_i128_accum_mul(&cg, r, g4);
  540|   918k|    f->v[3] = secp256k1_i128_to_u64(&cf) & M62; secp256k1_i128_rshift(&cf, 62);
  541|   918k|    g->v[3] = secp256k1_i128_to_u64(&cg) & M62; secp256k1_i128_rshift(&cg, 62);
  542|       |    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */
  543|   918k|    f->v[4] = secp256k1_i128_to_i64(&cf);
  544|   918k|    g->v[4] = secp256k1_i128_to_i64(&cg);
  545|   918k|}
secp256k1.c:secp256k1_jacobi64_maybe_var:
  721|  95.2k|static int secp256k1_jacobi64_maybe_var(const secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {
  722|       |    /* Start with f=modulus, g=x, eta=-1. */
  723|  95.2k|    secp256k1_modinv64_signed62 f = modinfo->modulus;
  724|  95.2k|    secp256k1_modinv64_signed62 g = *x;
  725|  95.2k|    int j, len = 5;
  726|  95.2k|    int64_t eta = -1; /* eta = -delta; delta is initially 1 */
  727|  95.2k|    int64_t cond, fn, gn;
  728|  95.2k|    int jac = 0;
  729|  95.2k|    int count;
  730|       |
  731|       |    /* The input limbs must all be non-negative. */
  732|  95.2k|    VERIFY_CHECK(g.v[0] >= 0 && g.v[1] >= 0 && g.v[2] >= 0 && g.v[3] >= 0 && g.v[4] >= 0);
  733|       |
  734|       |    /* If x > 0, then if the loop below converges, it converges to f=g=gcd(x,modulus). Since we
  735|       |     * require that gcd(x,modulus)=1 and modulus>=3, x cannot be 0. Thus, we must reach f=1 (or
  736|       |     * time out). */
  737|  95.2k|    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) != 0);
  738|       |
  739|  1.20M|    for (count = 0; count < JACOBI64_ITERATIONS; ++count) {
  ------------------
  |  |  717|  1.20M|#define JACOBI64_ITERATIONS 25
  ------------------
  |  Branch (739:21): [True: 1.20M, False: 0]
  ------------------
  740|       |        /* Compute transition matrix and new eta after 62 posdivsteps. */
  741|  1.20M|        secp256k1_modinv64_trans2x2 t;
  742|  1.20M|        eta = secp256k1_modinv64_posdivsteps_62_var(eta, f.v[0] | ((uint64_t)f.v[1] << 62), g.v[0] | ((uint64_t)g.v[1] << 62), &t, &jac);
  743|       |        /* Update f,g using that transition matrix. */
  744|  1.20M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */
  745|  1.20M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */
  746|  1.20M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */
  747|  1.20M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */
  748|       |
  749|  1.20M|        secp256k1_modinv64_update_fg_62_var(len, &f, &g, &t);
  750|       |        /* If the bottom limb of f is 1, there is a chance that f=1. */
  751|  1.20M|        if (f.v[0] == 1) {
  ------------------
  |  Branch (751:13): [True: 95.2k, False: 1.11M]
  ------------------
  752|  95.2k|            cond = 0;
  753|       |            /* Check if the other limbs are also 0. */
  754|  95.2k|            for (j = 1; j < len; ++j) {
  ------------------
  |  Branch (754:25): [True: 0, False: 95.2k]
  ------------------
  755|      0|                cond |= f.v[j];
  756|      0|            }
  757|       |            /* If so, we're done. When f=1, the Jacobi symbol (g | f)=1. */
  758|  95.2k|            if (cond == 0) return 1 - 2*(jac & 1);
  ------------------
  |  Branch (758:17): [True: 95.2k, False: 0]
  ------------------
  759|  95.2k|        }
  760|       |
  761|       |        /* Determine if len>1 and limb (len-1) of both f and g is 0. */
  762|  1.11M|        fn = f.v[len - 1];
  763|  1.11M|        gn = g.v[len - 1];
  764|  1.11M|        cond = ((int64_t)len - 2) >> 63;
  765|  1.11M|        cond |= fn;
  766|  1.11M|        cond |= gn;
  767|       |        /* If so, reduce length. */
  768|  1.11M|        if (cond == 0) --len;
  ------------------
  |  Branch (768:13): [True: 380k, False: 730k]
  ------------------
  769|       |
  770|  1.11M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 0) > 0); /* f > 0 */
  771|  1.11M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */
  772|  1.11M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 0) > 0); /* g > 0 */
  773|  1.11M|        VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, 1) < 0);  /* g < modulus */
  774|  1.11M|    }
  775|       |
  776|       |    /* The loop failed to converge to f=g after 1550 iterations. Return 0, indicating unknown result. */
  777|      0|    return 0;
  778|  95.2k|}
secp256k1.c:secp256k1_modinv64_posdivsteps_62_var:
  325|  1.20M|static int64_t secp256k1_modinv64_posdivsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t, int *jacp) {
  326|       |    /* Transformation matrix; see comments in secp256k1_modinv64_divsteps_62. */
  327|  1.20M|    uint64_t u = 1, v = 0, q = 0, r = 1;
  328|  1.20M|    uint64_t f = f0, g = g0, m;
  329|  1.20M|    uint32_t w;
  330|  1.20M|    int i = 62, limit, zeros;
  331|  1.20M|    int jac = *jacp;
  332|       |
  333|  21.2M|    for (;;) {
  334|       |        /* Use a sentinel bit to count zeros only up to i. */
  335|  21.2M|        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));
  336|       |        /* Perform zeros divsteps at once; they all just divide g by two. */
  337|  21.2M|        g >>= zeros;
  338|  21.2M|        u <<= zeros;
  339|  21.2M|        v <<= zeros;
  340|  21.2M|        eta -= zeros;
  341|  21.2M|        i -= zeros;
  342|       |        /* Update the bottom bit of jac: when dividing g by an odd power of 2,
  343|       |         * if (f mod 8) is 3 or 5, the Jacobi symbol changes sign. */
  344|  21.2M|        jac ^= (zeros & ((f >> 1) ^ (f >> 2)));
  345|       |        /* We're done once we've done 62 posdivsteps. */
  346|  21.2M|        if (i == 0) break;
  ------------------
  |  Branch (346:13): [True: 1.20M, False: 20.0M]
  ------------------
  347|  20.0M|        VERIFY_CHECK((f & 1) == 1);
  348|  20.0M|        VERIFY_CHECK((g & 1) == 1);
  349|  20.0M|        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));
  350|  20.0M|        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));
  351|       |        /* If eta is negative, negate it and replace f,g with g,f. */
  352|  20.0M|        if (eta < 0) {
  ------------------
  |  Branch (352:13): [True: 19.3M, False: 658k]
  ------------------
  353|  19.3M|            uint64_t tmp;
  354|  19.3M|            eta = -eta;
  355|  19.3M|            tmp = f; f = g; g = tmp;
  356|  19.3M|            tmp = u; u = q; q = tmp;
  357|  19.3M|            tmp = v; v = r; r = tmp;
  358|       |            /* Update bottom bit of jac: when swapping f and g, the Jacobi symbol changes sign
  359|       |             * if both f and g are 3 mod 4. */
  360|  19.3M|            jac ^= ((f & g) >> 1);
  361|       |            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled
  362|       |             * out (as we'd be done before that point), and no more than eta+1 can be done as its
  363|       |             * sign will flip again once that happens. */
  364|  19.3M|            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);
  ------------------
  |  Branch (364:21): [True: 372k, False: 19.0M]
  ------------------
  365|  19.3M|            VERIFY_CHECK(limit > 0 && limit <= 62);
  366|       |            /* m is a mask for the bottom min(limit, 6) bits. */
  367|  19.3M|            m = (UINT64_MAX >> (64 - limit)) & 63U;
  368|       |            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)
  369|       |             * bits. */
  370|  19.3M|            w = (f * g * (f * f - 2)) & m;
  371|  19.3M|        } else {
  372|       |            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as
  373|       |             * eta tends to be smaller here. */
  374|   658k|            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);
  ------------------
  |  Branch (374:21): [True: 4.04k, False: 654k]
  ------------------
  375|   658k|            VERIFY_CHECK(limit > 0 && limit <= 62);
  376|       |            /* m is a mask for the bottom min(limit, 4) bits. */
  377|   658k|            m = (UINT64_MAX >> (64 - limit)) & 15U;
  378|       |            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 4)
  379|       |             * bits. */
  380|   658k|            w = f + (((f + 1) & 4) << 1);
  381|   658k|            w = (-w * g) & m;
  382|   658k|        }
  383|  20.0M|        g += f * w;
  384|  20.0M|        q += u * w;
  385|  20.0M|        r += v * w;
  386|  20.0M|        VERIFY_CHECK((g & m) == 0);
  387|  20.0M|    }
  388|       |    /* Return data in t and return value. */
  389|  1.20M|    t->u = (int64_t)u;
  390|  1.20M|    t->v = (int64_t)v;
  391|  1.20M|    t->q = (int64_t)q;
  392|  1.20M|    t->r = (int64_t)r;
  393|       |
  394|       |    /* The determinant of t must be a power of two. This guarantees that multiplication with t
  395|       |     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which
  396|       |     * will be divided out again). As each divstep's individual matrix has determinant 2 or -2,
  397|       |     * the aggregate of 62 of them will have determinant 2^62 or -2^62. */
  398|  1.20M|    VERIFY_CHECK(secp256k1_modinv64_det_check_pow2(t, 62, 1));
  399|       |
  400|  1.20M|    *jacp = jac;
  401|  1.20M|    return eta;
  402|  1.20M|}

secp256k1_ellswift_create:
  450|  13.4k|int secp256k1_ellswift_create(const secp256k1_context *ctx, unsigned char *ell64, const unsigned char *seckey32, const unsigned char *auxrnd32) {
  451|  13.4k|    secp256k1_ge p;
  452|  13.4k|    secp256k1_fe t;
  453|  13.4k|    secp256k1_sha256 hash;
  454|  13.4k|    secp256k1_scalar seckey_scalar;
  455|  13.4k|    int ret;
  456|  13.4k|    static const unsigned char zero32[32] = {0};
  457|       |
  458|       |    /* Sanity check inputs. */
  459|  13.4k|    VERIFY_CHECK(ctx != NULL);
  460|  13.4k|    ARG_CHECK(ell64 != NULL);
  ------------------
  |  |   45|  13.4k|#define ARG_CHECK(cond) do { \
  |  |   46|  13.4k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  13.4k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 13.4k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  13.4k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 13.4k]
  |  |  ------------------
  ------------------
  461|  13.4k|    memset(ell64, 0, 64);
  462|  13.4k|    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));
  ------------------
  |  |   45|  13.4k|#define ARG_CHECK(cond) do { \
  |  |   46|  13.4k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  13.4k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 13.4k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  13.4k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 13.4k]
  |  |  ------------------
  ------------------
  463|  13.4k|    ARG_CHECK(seckey32 != NULL);
  ------------------
  |  |   45|  13.4k|#define ARG_CHECK(cond) do { \
  |  |   46|  13.4k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  13.4k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 13.4k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  13.4k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 13.4k]
  |  |  ------------------
  ------------------
  464|       |
  465|       |    /* Compute (affine) public key */
  466|  13.4k|    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey32);
  467|  13.4k|    secp256k1_declassify(ctx, &p, sizeof(p)); /* not constant time in produced pubkey */
  468|  13.4k|    secp256k1_fe_normalize_var(&p.x);
  ------------------
  |  |   80|  13.4k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  469|  13.4k|    secp256k1_fe_normalize_var(&p.y);
  ------------------
  |  |   80|  13.4k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  470|       |
  471|       |    /* Set up hasher state. The used RNG is H(privkey || "\x00"*32 [|| auxrnd32] || cnt++),
  472|       |     * using BIP340 tagged hash with tag "secp256k1_ellswift_create". */
  473|  13.4k|    secp256k1_ellswift_sha256_init_create(&hash);
  474|  13.4k|    secp256k1_sha256_write(&hash, seckey32, 32);
  475|  13.4k|    secp256k1_sha256_write(&hash, zero32, sizeof(zero32));
  476|  13.4k|    secp256k1_declassify(ctx, &hash, sizeof(hash)); /* private key is hashed now */
  477|  13.4k|    if (auxrnd32) secp256k1_sha256_write(&hash, auxrnd32, 32);
  ------------------
  |  Branch (477:9): [True: 13.4k, False: 0]
  ------------------
  478|       |
  479|       |    /* Compute ElligatorSwift encoding and construct output. */
  480|  13.4k|    secp256k1_ellswift_elligatorswift_var(ell64, &t, &p, &hash); /* puts u in ell64[0..32] */
  481|  13.4k|    secp256k1_fe_get_b32(ell64 + 32, &t); /* puts t in ell64[32..64] */
  ------------------
  |  |   89|  13.4k|#  define secp256k1_fe_get_b32 secp256k1_fe_impl_get_b32
  ------------------
  482|       |
  483|  13.4k|    secp256k1_memczero(ell64, 64, !ret);
  484|  13.4k|    secp256k1_scalar_clear(&seckey_scalar);
  485|       |
  486|  13.4k|    return ret;
  487|  13.4k|}
secp256k1_ellswift_decode:
  489|  2.56k|int secp256k1_ellswift_decode(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *ell64) {
  490|  2.56k|    secp256k1_fe u, t;
  491|  2.56k|    secp256k1_ge p;
  492|  2.56k|    VERIFY_CHECK(ctx != NULL);
  493|  2.56k|    ARG_CHECK(pubkey != NULL);
  ------------------
  |  |   45|  2.56k|#define ARG_CHECK(cond) do { \
  |  |   46|  2.56k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  2.56k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 2.56k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  2.56k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 2.56k]
  |  |  ------------------
  ------------------
  494|  2.56k|    ARG_CHECK(ell64 != NULL);
  ------------------
  |  |   45|  2.56k|#define ARG_CHECK(cond) do { \
  |  |   46|  2.56k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  2.56k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 2.56k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  2.56k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 2.56k]
  |  |  ------------------
  ------------------
  495|       |
  496|  2.56k|    secp256k1_fe_set_b32_mod(&u, ell64);
  ------------------
  |  |   87|  2.56k|#  define secp256k1_fe_set_b32_mod secp256k1_fe_impl_set_b32_mod
  ------------------
  497|  2.56k|    secp256k1_fe_set_b32_mod(&t, ell64 + 32);
  ------------------
  |  |   87|  2.56k|#  define secp256k1_fe_set_b32_mod secp256k1_fe_impl_set_b32_mod
  ------------------
  498|  2.56k|    secp256k1_fe_normalize_var(&t);
  ------------------
  |  |   80|  2.56k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  499|  2.56k|    secp256k1_ellswift_swiftec_var(&p, &u, &t);
  500|  2.56k|    secp256k1_pubkey_save(pubkey, &p);
  501|  2.56k|    return 1;
  502|  2.56k|}
secp256k1_ellswift_xdh:
  551|  12.6k|int secp256k1_ellswift_xdh(const secp256k1_context *ctx, unsigned char *output, const unsigned char *ell_a64, const unsigned char *ell_b64, const unsigned char *seckey32, int party, secp256k1_ellswift_xdh_hash_function hashfp, void *data) {
  552|  12.6k|    int ret = 0;
  553|  12.6k|    int overflow;
  554|  12.6k|    secp256k1_scalar s;
  555|  12.6k|    secp256k1_fe xn, xd, px, u, t;
  556|  12.6k|    unsigned char sx[32];
  557|  12.6k|    const unsigned char* theirs64;
  558|       |
  559|  12.6k|    VERIFY_CHECK(ctx != NULL);
  560|  12.6k|    ARG_CHECK(output != NULL);
  ------------------
  |  |   45|  12.6k|#define ARG_CHECK(cond) do { \
  |  |   46|  12.6k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  12.6k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  12.6k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 12.6k]
  |  |  ------------------
  ------------------
  561|  12.6k|    ARG_CHECK(ell_a64 != NULL);
  ------------------
  |  |   45|  12.6k|#define ARG_CHECK(cond) do { \
  |  |   46|  12.6k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  12.6k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  12.6k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 12.6k]
  |  |  ------------------
  ------------------
  562|  12.6k|    ARG_CHECK(ell_b64 != NULL);
  ------------------
  |  |   45|  12.6k|#define ARG_CHECK(cond) do { \
  |  |   46|  12.6k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  12.6k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  12.6k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 12.6k]
  |  |  ------------------
  ------------------
  563|  12.6k|    ARG_CHECK(seckey32 != NULL);
  ------------------
  |  |   45|  12.6k|#define ARG_CHECK(cond) do { \
  |  |   46|  12.6k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  12.6k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  12.6k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 12.6k]
  |  |  ------------------
  ------------------
  564|  12.6k|    ARG_CHECK(hashfp != NULL);
  ------------------
  |  |   45|  12.6k|#define ARG_CHECK(cond) do { \
  |  |   46|  12.6k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  12.6k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  12.6k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 12.6k]
  |  |  ------------------
  ------------------
  565|       |
  566|       |    /* Load remote public key (as fraction). */
  567|  12.6k|    theirs64 = party ? ell_a64 : ell_b64;
  ------------------
  |  Branch (567:16): [True: 6.72k, False: 5.96k]
  ------------------
  568|  12.6k|    secp256k1_fe_set_b32_mod(&u, theirs64);
  ------------------
  |  |   87|  12.6k|#  define secp256k1_fe_set_b32_mod secp256k1_fe_impl_set_b32_mod
  ------------------
  569|  12.6k|    secp256k1_fe_set_b32_mod(&t, theirs64 + 32);
  ------------------
  |  |   87|  12.6k|#  define secp256k1_fe_set_b32_mod secp256k1_fe_impl_set_b32_mod
  ------------------
  570|  12.6k|    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, &u, &t);
  571|       |
  572|       |    /* Load private key (using one if invalid). */
  573|  12.6k|    secp256k1_scalar_set_b32(&s, seckey32, &overflow);
  574|  12.6k|    overflow = secp256k1_scalar_is_zero(&s);
  575|  12.6k|    secp256k1_scalar_cmov(&s, &secp256k1_scalar_one, overflow);
  576|       |
  577|       |    /* Compute shared X coordinate. */
  578|  12.6k|    secp256k1_ecmult_const_xonly(&px, &xn, &xd, &s, 1);
  579|  12.6k|    secp256k1_fe_normalize(&px);
  ------------------
  |  |   78|  12.6k|#  define secp256k1_fe_normalize secp256k1_fe_impl_normalize
  ------------------
  580|  12.6k|    secp256k1_fe_get_b32(sx, &px);
  ------------------
  |  |   89|  12.6k|#  define secp256k1_fe_get_b32 secp256k1_fe_impl_get_b32
  ------------------
  581|       |
  582|       |    /* Invoke hasher */
  583|  12.6k|    ret = hashfp(output, sx, ell_a64, ell_b64, data);
  584|       |
  585|  12.6k|    secp256k1_memclear(sx, sizeof(sx));
  586|  12.6k|    secp256k1_fe_clear(&px);
  587|  12.6k|    secp256k1_scalar_clear(&s);
  588|       |
  589|  12.6k|    return !!ret & !overflow;
  590|  12.6k|}
secp256k1.c:secp256k1_ellswift_elligatorswift_var:
  375|  13.4k|static void secp256k1_ellswift_elligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_ge *p, const secp256k1_sha256 *hasher) {
  376|  13.4k|    secp256k1_ellswift_xelligatorswift_var(u32, t, &p->x, hasher);
  377|  13.4k|    secp256k1_fe_normalize_var(t);
  ------------------
  |  |   80|  13.4k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  378|  13.4k|    if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {
  ------------------
  |  |   85|  13.4k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
                  if (secp256k1_fe_is_odd(t) != secp256k1_fe_is_odd(&p->y)) {
  ------------------
  |  |   85|  13.4k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
  |  Branch (378:9): [True: 6.86k, False: 6.57k]
  ------------------
  379|  6.86k|        secp256k1_fe_negate(t, t, 1);
  ------------------
  |  |  211|  6.86k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  6.86k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  6.86k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 6.86k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  6.86k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 6.86k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  6.86k|    } \
  |  |  |  |   84|  6.86k|    stmt; \
  |  |  |  |   85|  6.86k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 6.86k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  380|  6.86k|        secp256k1_fe_normalize_var(t);
  ------------------
  |  |   80|  6.86k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  381|  6.86k|    }
  382|  13.4k|}
secp256k1.c:secp256k1_ellswift_xelligatorswift_var:
  333|  13.4k|static void secp256k1_ellswift_xelligatorswift_var(unsigned char *u32, secp256k1_fe *t, const secp256k1_fe *x, const secp256k1_sha256 *hasher) {
  334|       |    /* Pool of 3-bit branch values. */
  335|  13.4k|    unsigned char branch_hash[32];
  336|       |    /* Number of 3-bit values in branch_hash left. */
  337|  13.4k|    int branches_left = 0;
  338|       |    /* Field elements u and branch values are extracted from RNG based on hasher for consecutive
  339|       |     * values of cnt. cnt==0 is first used to populate a pool of 64 4-bit branch values. The 64
  340|       |     * cnt values that follow are used to generate field elements u. cnt==65 (and multiples
  341|       |     * thereof) are used to repopulate the pool and start over, if that were ever necessary.
  342|       |     * On average, 4 iterations are needed. */
  343|  13.4k|    uint32_t cnt = 0;
  344|  47.6k|    while (1) {
  ------------------
  |  Branch (344:12): [True: 47.6k, Folded]
  ------------------
  345|  47.6k|        int branch;
  346|  47.6k|        secp256k1_fe u;
  347|       |        /* If the pool of branch values is empty, populate it. */
  348|  47.6k|        if (branches_left == 0) {
  ------------------
  |  Branch (348:13): [True: 13.4k, False: 34.1k]
  ------------------
  349|  13.4k|            secp256k1_ellswift_prng(branch_hash, hasher, cnt++);
  350|  13.4k|            branches_left = 64;
  351|  13.4k|        }
  352|       |        /* Take a 3-bit branch value from the branch pool (top bit is discarded). */
  353|  47.6k|        --branches_left;
  354|  47.6k|        branch = (branch_hash[branches_left >> 1] >> ((branches_left & 1) << 2)) & 7;
  355|       |        /* Compute a new u value by hashing. */
  356|  47.6k|        secp256k1_ellswift_prng(u32, hasher, cnt++);
  357|       |        /* overflow is not a problem (we prefer uniform u32 over uniform u). */
  358|  47.6k|        secp256k1_fe_set_b32_mod(&u, u32);
  ------------------
  |  |   87|  47.6k|#  define secp256k1_fe_set_b32_mod secp256k1_fe_impl_set_b32_mod
  ------------------
  359|       |        /* Since u is the output of a hash, it should practically never be 0. We could apply the
  360|       |         * u=0 to u=1 correction here too to deal with that case still, but it's such a low
  361|       |         * probability event that we do not bother. */
  362|  47.6k|        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&u));
  363|       |
  364|       |        /* Find a remainder t, and return it if found. */
  365|  47.6k|        if (EXPECT(secp256k1_ellswift_xswiftec_inv_var(t, x, &u, branch), 0)) break;
  ------------------
  |  |  136|  47.6k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 13.4k, False: 34.1k]
  |  |  ------------------
  ------------------
  366|  47.6k|    }
  367|  13.4k|}
secp256k1.c:secp256k1_ellswift_prng:
  310|  61.0k|static void secp256k1_ellswift_prng(unsigned char* out32, const secp256k1_sha256 *hasher, uint32_t cnt) {
  311|  61.0k|    secp256k1_sha256 hash = *hasher;
  312|  61.0k|    unsigned char buf4[4];
  313|       |#ifdef VERIFY
  314|       |    size_t blocks = hash.bytes >> 6;
  315|       |#endif
  316|  61.0k|    buf4[0] = cnt;
  317|  61.0k|    buf4[1] = cnt >> 8;
  318|  61.0k|    buf4[2] = cnt >> 16;
  319|  61.0k|    buf4[3] = cnt >> 24;
  320|  61.0k|    secp256k1_sha256_write(&hash, buf4, 4);
  321|  61.0k|    secp256k1_sha256_finalize(&hash, out32);
  322|       |
  323|       |    /* Writing and finalizing together should trigger exactly one SHA256 compression. */
  324|  61.0k|    VERIFY_CHECK(((hash.bytes) >> 6) == (blocks + 1));
  325|  61.0k|}
secp256k1.c:secp256k1_ellswift_xswiftec_inv_var:
  168|  47.6k|static int secp256k1_ellswift_xswiftec_inv_var(secp256k1_fe *t, const secp256k1_fe *x_in, const secp256k1_fe *u_in, int c) {
  169|       |    /* The implemented algorithm is this (all arithmetic, except involving c, is mod p):
  170|       |     *
  171|       |     * - If (c & 2) = 0:
  172|       |     *   - If (-x-u) is a valid X coordinate, fail.
  173|       |     *   - Let s=-(u^3+7)/(u^2+u*x+x^2).
  174|       |     *   - If s is not square, fail.
  175|       |     *   - Let v=x.
  176|       |     * - If (c & 2) = 2:
  177|       |     *   - Let s=x-u.
  178|       |     *   - If s is not square, fail.
  179|       |     *   - Let r=sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist.
  180|       |     *   - If (c & 1) = 1 and r = 0, fail.
  181|       |     *   - If s=0, fail.
  182|       |     *   - Let v=(r/s-u)/2.
  183|       |     * - Let w=sqrt(s).
  184|       |     * - If (c & 5) = 0: return -w*(c3*u + v).
  185|       |     * - If (c & 5) = 1: return  w*(c4*u + v).
  186|       |     * - If (c & 5) = 4: return  w*(c3*u + v).
  187|       |     * - If (c & 5) = 5: return -w*(c4*u + v).
  188|       |     */
  189|  47.6k|    secp256k1_fe x = *x_in, u = *u_in, g, v, s, m, r, q;
  190|  47.6k|    int ret;
  191|       |
  192|  47.6k|    secp256k1_fe_normalize_weak(&x);
  ------------------
  |  |   79|  47.6k|#  define secp256k1_fe_normalize_weak secp256k1_fe_impl_normalize_weak
  ------------------
  193|  47.6k|    secp256k1_fe_normalize_weak(&u);
  ------------------
  |  |   79|  47.6k|#  define secp256k1_fe_normalize_weak secp256k1_fe_impl_normalize_weak
  ------------------
  194|       |
  195|  47.6k|    VERIFY_CHECK(c >= 0 && c < 8);
  196|  47.6k|    VERIFY_CHECK(secp256k1_ge_x_on_curve_var(&x));
  197|       |
  198|  47.6k|    if (!(c & 2)) {
  ------------------
  |  Branch (198:9): [True: 23.7k, False: 23.8k]
  ------------------
  199|       |        /* c is in {0, 1, 4, 5}. In this case we look for an inverse under the x1 (if c=0 or
  200|       |         * c=4) formula, or x2 (if c=1 or c=5) formula. */
  201|       |
  202|       |        /* If -u-x is a valid X coordinate, fail. This would yield an encoding that roundtrips
  203|       |         * back under the x3 formula instead (which has priority over x1 and x2, so the decoding
  204|       |         * would not match x). */
  205|  23.7k|        m = x;                                          /* m = x */
  206|  23.7k|        secp256k1_fe_add(&m, &u);                       /* m = u+x */
  ------------------
  |  |   92|  23.7k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  207|  23.7k|        secp256k1_fe_negate(&m, &m, 2);                 /* m = -u-x */
  ------------------
  |  |  211|  23.7k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  23.7k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  23.7k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 23.7k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  23.7k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 23.7k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  23.7k|    } \
  |  |  |  |   84|  23.7k|    stmt; \
  |  |  |  |   85|  23.7k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 23.7k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  208|       |        /* Test if (-u-x) is a valid X coordinate. If so, fail. */
  209|  23.7k|        if (secp256k1_ge_x_on_curve_var(&m)) return 0;
  ------------------
  |  Branch (209:13): [True: 11.5k, False: 12.2k]
  ------------------
  210|       |
  211|       |        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [first part] */
  212|  12.2k|        secp256k1_fe_sqr(&s, &m);                       /* s = (u+x)^2 */
  ------------------
  |  |   94|  12.2k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  213|  12.2k|        secp256k1_fe_negate(&s, &s, 1);                 /* s = -(u+x)^2 */
  ------------------
  |  |  211|  12.2k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  12.2k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  12.2k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 12.2k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  12.2k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 12.2k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  12.2k|    } \
  |  |  |  |   84|  12.2k|    stmt; \
  |  |  |  |   85|  12.2k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 12.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  214|  12.2k|        secp256k1_fe_mul(&m, &u, &x);                   /* m = u*x */
  ------------------
  |  |   93|  12.2k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  215|  12.2k|        secp256k1_fe_add(&s, &m);                       /* s = -(u^2 + u*x + x^2) */
  ------------------
  |  |   92|  12.2k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  216|       |
  217|       |        /* Note that at this point, s = 0 is impossible. If it were the case:
  218|       |         *             s = -(u^2 + u*x + x^2) = 0
  219|       |         * =>                 u^2 + u*x + x^2 = 0
  220|       |         * =>   (u + 2*x) * (u^2 + u*x + x^2) = 0
  221|       |         * => 2*x^3 + 3*x^2*u + 3*x*u^2 + u^3 = 0
  222|       |         * =>                 (x + u)^3 + x^3 = 0
  223|       |         * =>                             x^3 = -(x + u)^3
  224|       |         * =>                         x^3 + B = (-u - x)^3 + B
  225|       |         *
  226|       |         * However, we know x^3 + B is square (because x is on the curve) and
  227|       |         * that (-u-x)^3 + B is not square (the secp256k1_ge_x_on_curve_var(&m)
  228|       |         * test above would have failed). This is a contradiction, and thus the
  229|       |         * assumption s=0 is false. */
  230|  12.2k|        VERIFY_CHECK(!secp256k1_fe_normalizes_to_zero_var(&s));
  231|       |
  232|       |        /* If s is not square, fail. We have not fully computed s yet, but s is square iff
  233|       |         * -(u^3+7)*(u^2+u*x+x^2) is square (because a/b is square iff a*b is square and b is
  234|       |         * nonzero). */
  235|  12.2k|        secp256k1_fe_sqr(&g, &u);                       /* g = u^2 */
  ------------------
  |  |   94|  12.2k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  236|  12.2k|        secp256k1_fe_mul(&g, &g, &u);                   /* g = u^3 */
  ------------------
  |  |   93|  12.2k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  237|  12.2k|        secp256k1_fe_add_int(&g, SECP256K1_B);          /* g = u^3+7 */
  ------------------
  |  |  102|  12.2k|#  define secp256k1_fe_add_int secp256k1_fe_impl_add_int
  ------------------
                      secp256k1_fe_add_int(&g, SECP256K1_B);          /* g = u^3+7 */
  ------------------
  |  |   73|  12.2k|#define SECP256K1_B 7
  ------------------
  238|  12.2k|        secp256k1_fe_mul(&m, &s, &g);                   /* m = -(u^3 + 7)*(u^2 + u*x + x^2) */
  ------------------
  |  |   93|  12.2k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  239|  12.2k|        if (!secp256k1_fe_is_square_var(&m)) return 0;
  ------------------
  |  |  103|  12.2k|#  define secp256k1_fe_is_square_var secp256k1_fe_impl_is_square_var
  ------------------
  |  Branch (239:13): [True: 5.64k, False: 6.60k]
  ------------------
  240|       |
  241|       |        /* Let s = -(u^3 + 7)/(u^2 + u*x + x^2) [second part] */
  242|  6.60k|        secp256k1_fe_inv_var(&s, &s);                   /* s = -1/(u^2 + u*x + x^2) [no div by 0] */
  ------------------
  |  |   99|  6.60k|#  define secp256k1_fe_inv_var secp256k1_fe_impl_inv_var
  ------------------
  243|  6.60k|        secp256k1_fe_mul(&s, &s, &g);                   /* s = -(u^3 + 7)/(u^2 + u*x + x^2) */
  ------------------
  |  |   93|  6.60k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  244|       |
  245|       |        /* Let v = x. */
  246|  6.60k|        v = x;
  247|  23.8k|    } else {
  248|       |        /* c is in {2, 3, 6, 7}. In this case we look for an inverse under the x3 formula. */
  249|       |
  250|       |        /* Let s = x-u. */
  251|  23.8k|        secp256k1_fe_negate(&m, &u, 1);                 /* m = -u */
  ------------------
  |  |  211|  23.8k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  23.8k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  23.8k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 23.8k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  23.8k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 23.8k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  23.8k|    } \
  |  |  |  |   84|  23.8k|    stmt; \
  |  |  |  |   85|  23.8k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 23.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  252|  23.8k|        s = m;                                          /* s = -u */
  253|  23.8k|        secp256k1_fe_add(&s, &x);                       /* s = x-u */
  ------------------
  |  |   92|  23.8k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  254|       |
  255|       |        /* If s is not square, fail. */
  256|  23.8k|        if (!secp256k1_fe_is_square_var(&s)) return 0;
  ------------------
  |  |  103|  23.8k|#  define secp256k1_fe_is_square_var secp256k1_fe_impl_is_square_var
  ------------------
  |  Branch (256:13): [True: 11.2k, False: 12.6k]
  ------------------
  257|       |
  258|       |        /* Let r = sqrt(-s*(4*(u^3+7)+3*u^2*s)); fail if it doesn't exist. */
  259|  12.6k|        secp256k1_fe_sqr(&g, &u);                       /* g = u^2 */
  ------------------
  |  |   94|  12.6k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  260|  12.6k|        secp256k1_fe_mul(&q, &s, &g);                   /* q = s*u^2 */
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  261|  12.6k|        secp256k1_fe_mul_int(&q, 3);                    /* q = 3*s*u^2 */
  ------------------
  |  |  233|  12.6k|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  12.6k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  12.6k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  12.6k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 12.6k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  12.6k|    } \
  |  |  |  |   84|  12.6k|    stmt; \
  |  |  |  |   85|  12.6k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  262|  12.6k|        secp256k1_fe_mul(&g, &g, &u);                   /* g = u^3 */
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  263|  12.6k|        secp256k1_fe_mul_int(&g, 4);                    /* g = 4*u^3 */
  ------------------
  |  |  233|  12.6k|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  12.6k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  12.6k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  12.6k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 12.6k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  12.6k|    } \
  |  |  |  |   84|  12.6k|    stmt; \
  |  |  |  |   85|  12.6k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  264|  12.6k|        secp256k1_fe_add_int(&g, 4 * SECP256K1_B);      /* g = 4*(u^3+7) */
  ------------------
  |  |  102|  12.6k|#  define secp256k1_fe_add_int secp256k1_fe_impl_add_int
  ------------------
                      secp256k1_fe_add_int(&g, 4 * SECP256K1_B);      /* g = 4*(u^3+7) */
  ------------------
  |  |   73|  12.6k|#define SECP256K1_B 7
  ------------------
  265|  12.6k|        secp256k1_fe_add(&q, &g);                       /* q = 4*(u^3+7)+3*s*u^2 */
  ------------------
  |  |   92|  12.6k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  266|  12.6k|        secp256k1_fe_mul(&q, &q, &s);                   /* q = s*(4*(u^3+7)+3*u^2*s) */
  ------------------
  |  |   93|  12.6k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  267|  12.6k|        secp256k1_fe_negate(&q, &q, 1);                 /* q = -s*(4*(u^3+7)+3*u^2*s) */
  ------------------
  |  |  211|  12.6k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  12.6k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  12.6k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  12.6k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 12.6k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  12.6k|    } \
  |  |  |  |   84|  12.6k|    stmt; \
  |  |  |  |   85|  12.6k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  268|  12.6k|        if (!secp256k1_fe_is_square_var(&q)) return 0;
  ------------------
  |  |  103|  12.6k|#  define secp256k1_fe_is_square_var secp256k1_fe_impl_is_square_var
  ------------------
  |  Branch (268:13): [True: 5.80k, False: 6.83k]
  ------------------
  269|  6.83k|        ret = secp256k1_fe_sqrt(&r, &q);                /* r = sqrt(-s*(4*(u^3+7)+3*u^2*s)) */
  270|       |#ifdef VERIFY
  271|       |        VERIFY_CHECK(ret);
  272|       |#else
  273|  6.83k|        (void)ret;
  274|  6.83k|#endif
  275|       |
  276|       |        /* If (c & 1) = 1 and r = 0, fail. */
  277|  6.83k|        if (EXPECT((c & 1) && secp256k1_fe_normalizes_to_zero_var(&r), 0)) return 0;
  ------------------
  |  |  136|  10.2k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 0, False: 6.83k]
  |  |  |  Branch (136:39): [True: 3.43k, False: 3.40k]
  |  |  |  Branch (136:39): [True: 0, False: 3.43k]
  |  |  ------------------
  ------------------
  278|       |
  279|       |        /* If s = 0, fail. */
  280|  6.83k|        if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&s), 0)) return 0;
  ------------------
  |  |  136|  6.83k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 0, False: 6.83k]
  |  |  ------------------
  ------------------
  281|       |
  282|       |        /* Let v = (r/s-u)/2. */
  283|  6.83k|        secp256k1_fe_inv_var(&v, &s);                   /* v = 1/s [no div by 0] */
  ------------------
  |  |   99|  6.83k|#  define secp256k1_fe_inv_var secp256k1_fe_impl_inv_var
  ------------------
  284|  6.83k|        secp256k1_fe_mul(&v, &v, &r);                   /* v = r/s */
  ------------------
  |  |   93|  6.83k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  285|  6.83k|        secp256k1_fe_add(&v, &m);                       /* v = r/s-u */
  ------------------
  |  |   92|  6.83k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  286|  6.83k|        secp256k1_fe_half(&v);                          /* v = (r/s-u)/2 */
  ------------------
  |  |  101|  6.83k|#  define secp256k1_fe_half secp256k1_fe_impl_half
  ------------------
  287|  6.83k|    }
  288|       |
  289|       |    /* Let w = sqrt(s). */
  290|  13.4k|    ret = secp256k1_fe_sqrt(&m, &s);                    /* m = sqrt(s) = w */
  291|  13.4k|    VERIFY_CHECK(ret);
  292|       |
  293|       |    /* Return logic. */
  294|  13.4k|    if ((c & 5) == 0 || (c & 5) == 5) {
  ------------------
  |  Branch (294:9): [True: 3.31k, False: 10.1k]
  |  Branch (294:25): [True: 3.33k, False: 6.78k]
  ------------------
  295|  6.65k|        secp256k1_fe_negate(&m, &m, 1);                 /* m = -w */
  ------------------
  |  |  211|  6.65k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  6.65k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  6.65k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 6.65k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  6.65k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 6.65k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  6.65k|    } \
  |  |  |  |   84|  6.65k|    stmt; \
  |  |  |  |   85|  6.65k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 6.65k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  296|  6.65k|    }
  297|       |    /* Now m = {-w if c&5=0 or c&5=5; w otherwise}. */
  298|  13.4k|    secp256k1_fe_mul(&u, &u, c&1 ? &secp256k1_ellswift_c4 : &secp256k1_ellswift_c3);
  ------------------
  |  |   93|  13.4k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  |  Branch (298:30): [True: 6.73k, False: 6.70k]
  ------------------
  299|       |    /* u = {c4 if c&1=1; c3 otherwise}*u */
  300|  13.4k|    secp256k1_fe_add(&u, &v);                           /* u = {c4 if c&1=1; c3 otherwise}*u + v */
  ------------------
  |  |   92|  13.4k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  301|  13.4k|    secp256k1_fe_mul(t, &m, &u);
  ------------------
  |  |   93|  13.4k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  302|  13.4k|    return 1;
  303|  13.4k|}
secp256k1.c:secp256k1_ellswift_sha256_init_create:
  436|  13.4k|static void secp256k1_ellswift_sha256_init_create(secp256k1_sha256* hash) {
  437|  13.4k|    secp256k1_sha256_initialize(hash);
  438|  13.4k|    hash->s[0] = 0xd29e1bf5ul;
  439|  13.4k|    hash->s[1] = 0xf7025f42ul;
  440|  13.4k|    hash->s[2] = 0x9b024773ul;
  441|  13.4k|    hash->s[3] = 0x094cb7d5ul;
  442|  13.4k|    hash->s[4] = 0xe59ed789ul;
  443|  13.4k|    hash->s[5] = 0x03bc9786ul;
  444|  13.4k|    hash->s[6] = 0x68335b35ul;
  445|  13.4k|    hash->s[7] = 0x4e363b53ul;
  446|       |
  447|  13.4k|    hash->bytes = 64;
  448|  13.4k|}
secp256k1.c:secp256k1_ellswift_swiftec_var:
  143|  2.56k|static void secp256k1_ellswift_swiftec_var(secp256k1_ge *p, const secp256k1_fe *u, const secp256k1_fe *t) {
  144|  2.56k|    secp256k1_fe x;
  145|  2.56k|    secp256k1_ellswift_xswiftec_var(&x, u, t);
  146|  2.56k|    secp256k1_ge_set_xo_var(p, &x, secp256k1_fe_is_odd(t));
  ------------------
  |  |   85|  2.56k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
  147|  2.56k|}
secp256k1.c:secp256k1_ellswift_xswiftec_var:
  135|  2.56k|static void secp256k1_ellswift_xswiftec_var(secp256k1_fe *x, const secp256k1_fe *u, const secp256k1_fe *t) {
  136|  2.56k|    secp256k1_fe xn, xd;
  137|  2.56k|    secp256k1_ellswift_xswiftec_frac_var(&xn, &xd, u, t);
  138|  2.56k|    secp256k1_fe_inv_var(&xd, &xd);
  ------------------
  |  |   99|  2.56k|#  define secp256k1_fe_inv_var secp256k1_fe_impl_inv_var
  ------------------
  139|  2.56k|    secp256k1_fe_mul(x, &xn, &xd);
  ------------------
  |  |   93|  2.56k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  140|  2.56k|}
secp256k1.c:ellswift_xdh_hash_function_bip324:
  533|  12.6k|static int ellswift_xdh_hash_function_bip324(unsigned char* output, const unsigned char *x32, const unsigned char *ell_a64, const unsigned char *ell_b64, void *data) {
  534|  12.6k|    secp256k1_sha256 sha;
  535|       |
  536|  12.6k|    (void)data;
  537|       |
  538|  12.6k|    secp256k1_ellswift_sha256_init_bip324(&sha);
  539|  12.6k|    secp256k1_sha256_write(&sha, ell_a64, 64);
  540|  12.6k|    secp256k1_sha256_write(&sha, ell_b64, 64);
  541|  12.6k|    secp256k1_sha256_write(&sha, x32, 32);
  542|  12.6k|    secp256k1_sha256_finalize(&sha, output);
  543|  12.6k|    secp256k1_sha256_clear(&sha);
  544|       |
  545|  12.6k|    return 1;
  546|  12.6k|}
secp256k1.c:secp256k1_ellswift_sha256_init_bip324:
  519|  12.6k|static void secp256k1_ellswift_sha256_init_bip324(secp256k1_sha256* hash) {
  520|  12.6k|    secp256k1_sha256_initialize(hash);
  521|  12.6k|    hash->s[0] = 0x8c12d730ul;
  522|  12.6k|    hash->s[1] = 0x827bd392ul;
  523|  12.6k|    hash->s[2] = 0x9e4fb2eeul;
  524|  12.6k|    hash->s[3] = 0x207b373eul;
  525|  12.6k|    hash->s[4] = 0x2292bd7aul;
  526|  12.6k|    hash->s[5] = 0xaa5441bcul;
  527|  12.6k|    hash->s[6] = 0x15c3779ful;
  528|  12.6k|    hash->s[7] = 0xcfb52549ul;
  529|       |
  530|  12.6k|    hash->bytes = 64;
  531|  12.6k|}
secp256k1.c:secp256k1_ellswift_xswiftec_frac_var:
   24|  15.2k|static void secp256k1_ellswift_xswiftec_frac_var(secp256k1_fe *xn, secp256k1_fe *xd, const secp256k1_fe *u, const secp256k1_fe *t) {
   25|       |    /* The implemented algorithm is the following (all operations in GF(p)):
   26|       |     *
   27|       |     * - Let c0 = sqrt(-3) = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852.
   28|       |     * - If u = 0, set u = 1.
   29|       |     * - If t = 0, set t = 1.
   30|       |     * - If u^3+7+t^2 = 0, set t = 2*t.
   31|       |     * - Let X = (u^3+7-t^2)/(2*t).
   32|       |     * - Let Y = (X+t)/(c0*u).
   33|       |     * - If x3 = u+4*Y^2 is a valid x coordinate, return it.
   34|       |     * - If x2 = (-X/Y-u)/2 is a valid x coordinate, return it.
   35|       |     * - Return x1 = (X/Y-u)/2 (which is now guaranteed to be a valid x coordinate).
   36|       |     *
   37|       |     * Introducing s=t^2, g=u^3+7, and simplifying x1=-(x2+u) we get:
   38|       |     *
   39|       |     * - Let c0 = ...
   40|       |     * - If u = 0, set u = 1.
   41|       |     * - If t = 0, set t = 1.
   42|       |     * - Let s = t^2
   43|       |     * - Let g = u^3+7
   44|       |     * - If g+s = 0, set t = 2*t, s = 4*s
   45|       |     * - Let X = (g-s)/(2*t).
   46|       |     * - Let Y = (X+t)/(c0*u) = (g+s)/(2*c0*t*u).
   47|       |     * - If x3 = u+4*Y^2 is a valid x coordinate, return it.
   48|       |     * - If x2 = (-X/Y-u)/2 is a valid x coordinate, return it.
   49|       |     * - Return x1 = -(x2+u).
   50|       |     *
   51|       |     * Now substitute Y^2 = -(g+s)^2/(12*s*u^2) and X/Y = c0*u*(g-s)/(g+s). This
   52|       |     * means X and Y do not need to be evaluated explicitly anymore.
   53|       |     *
   54|       |     * - ...
   55|       |     * - If g+s = 0, set s = 4*s.
   56|       |     * - If x3 = u-(g+s)^2/(3*s*u^2) is a valid x coordinate, return it.
   57|       |     * - If x2 = (-c0*u*(g-s)/(g+s)-u)/2 is a valid x coordinate, return it.
   58|       |     * - Return x1 = -(x2+u).
   59|       |     *
   60|       |     * Simplifying x2 using 2 additional constants:
   61|       |     *
   62|       |     * - Let c1 = (c0-1)/2 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40.
   63|       |     * - Let c2 = (-c0-1)/2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee.
   64|       |     * - ...
   65|       |     * - If x2 = u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.
   66|       |     * - ...
   67|       |     *
   68|       |     * Writing x3 as a fraction:
   69|       |     *
   70|       |     * - ...
   71|       |     * - If x3 = (3*s*u^3-(g+s)^2)/(3*s*u^2) ...
   72|       |     * - ...
   73|       |
   74|       |     * Overall, we get:
   75|       |     *
   76|       |     * - Let c1 = 0x851695d49a83f8ef919bb86153cbcb16630fb68aed0a766a3ec693d68e6afa40.
   77|       |     * - Let c2 = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee.
   78|       |     * - If u = 0, set u = 1.
   79|       |     * - If t = 0, set s = 1, else set s = t^2.
   80|       |     * - Let g = u^3+7.
   81|       |     * - If g+s = 0, set s = 4*s.
   82|       |     * - If x3 = (3*s*u^3-(g+s)^2)/(3*s*u^2) is a valid x coordinate, return it.
   83|       |     * - If x2 = u*(c1*s+c2*g)/(g+s) is a valid x coordinate, return it.
   84|       |     * - Return x1 = -(x2+u).
   85|       |     */
   86|  15.2k|    secp256k1_fe u1, s, g, p, d, n, l;
   87|  15.2k|    u1 = *u;
   88|  15.2k|    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&u1), 0)) u1 = secp256k1_fe_one;
  ------------------
  |  |  136|  15.2k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 0, False: 15.2k]
  |  |  ------------------
  ------------------
   89|  15.2k|    secp256k1_fe_sqr(&s, t);
  ------------------
  |  |   94|  15.2k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   90|  15.2k|    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(t), 0)) s = secp256k1_fe_one;
  ------------------
  |  |  136|  15.2k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 0, False: 15.2k]
  |  |  ------------------
  ------------------
   91|  15.2k|    secp256k1_fe_sqr(&l, &u1);                                   /* l = u^2 */
  ------------------
  |  |   94|  15.2k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
   92|  15.2k|    secp256k1_fe_mul(&g, &l, &u1);                               /* g = u^3 */
  ------------------
  |  |   93|  15.2k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
   93|  15.2k|    secp256k1_fe_add_int(&g, SECP256K1_B);                       /* g = u^3 + 7 */
  ------------------
  |  |  102|  15.2k|#  define secp256k1_fe_add_int secp256k1_fe_impl_add_int
  ------------------
                  secp256k1_fe_add_int(&g, SECP256K1_B);                       /* g = u^3 + 7 */
  ------------------
  |  |   73|  15.2k|#define SECP256K1_B 7
  ------------------
   94|  15.2k|    p = g;                                                       /* p = g */
   95|  15.2k|    secp256k1_fe_add(&p, &s);                                    /* p = g+s */
  ------------------
  |  |   92|  15.2k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
   96|  15.2k|    if (EXPECT(secp256k1_fe_normalizes_to_zero_var(&p), 0)) {
  ------------------
  |  |  136|  15.2k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 0, False: 15.2k]
  |  |  ------------------
  ------------------
   97|      0|        secp256k1_fe_mul_int(&s, 4);
  ------------------
  |  |  233|      0|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|      0|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|      0|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|      0|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|      0|    } \
  |  |  |  |   84|      0|    stmt; \
  |  |  |  |   85|      0|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   98|       |        /* Recompute p = g+s */
   99|      0|        p = g;                                                   /* p = g */
  100|      0|        secp256k1_fe_add(&p, &s);                                /* p = g+s */
  ------------------
  |  |   92|      0|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  101|      0|    }
  102|  15.2k|    secp256k1_fe_mul(&d, &s, &l);                                /* d = s*u^2 */
  ------------------
  |  |   93|  15.2k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  103|  15.2k|    secp256k1_fe_mul_int(&d, 3);                                 /* d = 3*s*u^2 */
  ------------------
  |  |  233|  15.2k|#define secp256k1_fe_mul_int(r, a) ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
  |  |  ------------------
  |  |  |  |   77|  15.2k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  15.2k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 15.2k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  15.2k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 15.2k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  15.2k|    } \
  |  |  |  |   84|  15.2k|    stmt; \
  |  |  |  |   85|  15.2k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 15.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  104|  15.2k|    secp256k1_fe_sqr(&l, &p);                                    /* l = (g+s)^2 */
  ------------------
  |  |   94|  15.2k|#  define secp256k1_fe_sqr secp256k1_fe_impl_sqr
  ------------------
  105|  15.2k|    secp256k1_fe_negate(&l, &l, 1);                              /* l = -(g+s)^2 */
  ------------------
  |  |  211|  15.2k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  15.2k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  15.2k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 15.2k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  15.2k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 15.2k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  15.2k|    } \
  |  |  |  |   84|  15.2k|    stmt; \
  |  |  |  |   85|  15.2k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 15.2k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  106|  15.2k|    secp256k1_fe_mul(&n, &d, &u1);                               /* n = 3*s*u^3 */
  ------------------
  |  |   93|  15.2k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  107|  15.2k|    secp256k1_fe_add(&n, &l);                                    /* n = 3*s*u^3-(g+s)^2 */
  ------------------
  |  |   92|  15.2k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  108|  15.2k|    if (secp256k1_ge_x_frac_on_curve_var(&n, &d)) {
  ------------------
  |  Branch (108:9): [True: 7.75k, False: 7.48k]
  ------------------
  109|       |        /* Return x3 = n/d = (3*s*u^3-(g+s)^2)/(3*s*u^2) */
  110|  7.75k|        *xn = n;
  111|  7.75k|        *xd = d;
  112|  7.75k|        return;
  113|  7.75k|    }
  114|  7.48k|    *xd = p;
  115|  7.48k|    secp256k1_fe_mul(&l, &secp256k1_ellswift_c1, &s);            /* l = c1*s */
  ------------------
  |  |   93|  7.48k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  116|  7.48k|    secp256k1_fe_mul(&n, &secp256k1_ellswift_c2, &g);            /* n = c2*g */
  ------------------
  |  |   93|  7.48k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  117|  7.48k|    secp256k1_fe_add(&n, &l);                                    /* n = c1*s+c2*g */
  ------------------
  |  |   92|  7.48k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  118|  7.48k|    secp256k1_fe_mul(&n, &n, &u1);                               /* n = u*(c1*s+c2*g) */
  ------------------
  |  |   93|  7.48k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  119|       |    /* Possible optimization: in the invocation below, p^2 = (g+s)^2 is computed,
  120|       |     * which we already have computed above. This could be deduplicated. */
  121|  7.48k|    if (secp256k1_ge_x_frac_on_curve_var(&n, &p)) {
  ------------------
  |  Branch (121:9): [True: 3.67k, False: 3.81k]
  ------------------
  122|       |        /* Return x2 = n/p = u*(c1*s+c2*g)/(g+s) */
  123|  3.67k|        *xn = n;
  124|  3.67k|        return;
  125|  3.67k|    }
  126|  3.81k|    secp256k1_fe_mul(&l, &p, &u1);                               /* l = u*(g+s) */
  ------------------
  |  |   93|  3.81k|#  define secp256k1_fe_mul secp256k1_fe_impl_mul
  ------------------
  127|  3.81k|    secp256k1_fe_add(&n, &l);                                    /* n = u*(c1*s+c2*g)+u*(g+s) */
  ------------------
  |  |   92|  3.81k|#  define secp256k1_fe_add secp256k1_fe_impl_add
  ------------------
  128|  3.81k|    secp256k1_fe_negate(xn, &n, 2);                              /* n = -u*(c1*s+c2*g)-u*(g+s) */
  ------------------
  |  |  211|  3.81k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  3.81k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  3.81k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 3.81k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  3.81k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 3.81k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  3.81k|    } \
  |  |  |  |   84|  3.81k|    stmt; \
  |  |  |  |   85|  3.81k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 3.81k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  129|       |
  130|  3.81k|    VERIFY_CHECK(secp256k1_ge_x_frac_on_curve_var(xn, &p));
  131|       |    /* Return x3 = n/p = -(u*(c1*s+c2*g)/(g+s)+u) */
  132|  3.81k|}

secp256k1_xonly_pubkey_parse:
   22|  4.34k|int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32) {
   23|  4.34k|    secp256k1_ge pk;
   24|  4.34k|    secp256k1_fe x;
   25|       |
   26|  4.34k|    VERIFY_CHECK(ctx != NULL);
   27|  4.34k|    ARG_CHECK(pubkey != NULL);
  ------------------
  |  |   45|  4.34k|#define ARG_CHECK(cond) do { \
  |  |   46|  4.34k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  4.34k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 4.34k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  4.34k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 4.34k]
  |  |  ------------------
  ------------------
   28|  4.34k|    memset(pubkey, 0, sizeof(*pubkey));
   29|  4.34k|    ARG_CHECK(input32 != NULL);
  ------------------
  |  |   45|  4.34k|#define ARG_CHECK(cond) do { \
  |  |   46|  4.34k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  4.34k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 4.34k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  4.34k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 4.34k]
  |  |  ------------------
  ------------------
   30|       |
   31|  4.34k|    if (!secp256k1_fe_set_b32_limit(&x, input32)) {
  ------------------
  |  |   88|  4.34k|#  define secp256k1_fe_set_b32_limit secp256k1_fe_impl_set_b32_limit
  ------------------
  |  Branch (31:9): [True: 0, False: 4.34k]
  ------------------
   32|      0|        return 0;
   33|      0|    }
   34|  4.34k|    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {
  ------------------
  |  Branch (34:9): [True: 0, False: 4.34k]
  ------------------
   35|      0|        return 0;
   36|      0|    }
   37|  4.34k|    if (!secp256k1_ge_is_in_correct_subgroup(&pk)) {
  ------------------
  |  Branch (37:9): [True: 0, False: 4.34k]
  ------------------
   38|      0|        return 0;
   39|      0|    }
   40|  4.34k|    secp256k1_xonly_pubkey_save(pubkey, &pk);
   41|  4.34k|    return 1;
   42|  4.34k|}
secp256k1_keypair_create:
  196|  3.36k|int secp256k1_keypair_create(const secp256k1_context* ctx, secp256k1_keypair *keypair, const unsigned char *seckey32) {
  197|  3.36k|    secp256k1_scalar sk;
  198|  3.36k|    secp256k1_ge pk;
  199|  3.36k|    int ret = 0;
  200|  3.36k|    VERIFY_CHECK(ctx != NULL);
  201|  3.36k|    ARG_CHECK(keypair != NULL);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  202|  3.36k|    memset(keypair, 0, sizeof(*keypair));
  203|  3.36k|    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  204|  3.36k|    ARG_CHECK(seckey32 != NULL);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  205|       |
  206|  3.36k|    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &sk, &pk, seckey32);
  207|  3.36k|    secp256k1_keypair_save(keypair, &sk, &pk);
  208|  3.36k|    secp256k1_memczero(keypair, sizeof(*keypair), !ret);
  209|       |
  210|  3.36k|    secp256k1_scalar_clear(&sk);
  211|  3.36k|    return ret;
  212|  3.36k|}
secp256k1_keypair_xonly_pub:
  234|  3.36k|int secp256k1_keypair_xonly_pub(const secp256k1_context* ctx, secp256k1_xonly_pubkey *pubkey, int *pk_parity, const secp256k1_keypair *keypair) {
  235|  3.36k|    secp256k1_ge pk;
  236|  3.36k|    int tmp;
  237|       |
  238|  3.36k|    VERIFY_CHECK(ctx != NULL);
  239|  3.36k|    ARG_CHECK(pubkey != NULL);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  240|  3.36k|    memset(pubkey, 0, sizeof(*pubkey));
  241|  3.36k|    ARG_CHECK(keypair != NULL);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  242|       |
  243|  3.36k|    if (!secp256k1_keypair_load(ctx, NULL, &pk, keypair)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 3.36k]
  ------------------
  244|      0|        return 0;
  245|      0|    }
  246|  3.36k|    tmp = secp256k1_extrakeys_ge_even_y(&pk);
  247|  3.36k|    if (pk_parity != NULL) {
  ------------------
  |  Branch (247:9): [True: 0, False: 3.36k]
  ------------------
  248|      0|        *pk_parity = tmp;
  249|      0|    }
  250|  3.36k|    secp256k1_xonly_pubkey_save(pubkey, &pk);
  251|       |
  252|  3.36k|    return 1;
  253|  3.36k|}
secp256k1.c:secp256k1_xonly_pubkey_save:
   18|  7.70k|static SECP256K1_INLINE void secp256k1_xonly_pubkey_save(secp256k1_xonly_pubkey *pubkey, secp256k1_ge *ge) {
   19|  7.70k|    secp256k1_pubkey_save((secp256k1_pubkey *) pubkey, ge);
   20|  7.70k|}
secp256k1.c:secp256k1_xonly_pubkey_load:
   14|  7.70k|static SECP256K1_INLINE int secp256k1_xonly_pubkey_load(const secp256k1_context* ctx, secp256k1_ge *ge, const secp256k1_xonly_pubkey *pubkey) {
   15|  7.70k|    return secp256k1_pubkey_load(ctx, ge, (const secp256k1_pubkey *) pubkey);
   16|  7.70k|}
secp256k1.c:secp256k1_extrakeys_ge_even_y:
   88|  3.36k|static int secp256k1_extrakeys_ge_even_y(secp256k1_ge *r) {
   89|  3.36k|    int y_parity = 0;
   90|  3.36k|    VERIFY_CHECK(!secp256k1_ge_is_infinity(r));
   91|       |
   92|  3.36k|    if (secp256k1_fe_is_odd(&r->y)) {
  ------------------
  |  |   85|  3.36k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
  |  Branch (92:9): [True: 1.63k, False: 1.72k]
  ------------------
   93|  1.63k|        secp256k1_fe_negate(&r->y, &r->y, 1);
  ------------------
  |  |  211|  1.63k|#define secp256k1_fe_negate(r, a, m) ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
  |  |  ------------------
  |  |  |  |   77|  1.63k|#define ASSERT_INT_CONST_AND_DO(expr, stmt) do { \
  |  |  |  |   78|  1.63k|    switch(42) { \
  |  |  |  |   79|      0|        /* C allows only integer constant expressions as case labels. */ \
  |  |  |  |   80|      0|        case /* ERROR: integer argument is not constant */ (expr): \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (80:9): [True: 0, False: 1.63k]
  |  |  |  |  ------------------
  |  |  |  |   81|      0|            break; \
  |  |  |  |   82|  1.63k|        default: ; \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (82:9): [True: 1.63k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   83|  1.63k|    } \
  |  |  |  |   84|  1.63k|    stmt; \
  |  |  |  |   85|  1.63k|} while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (85:9): [Folded, False: 1.63k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   94|  1.63k|        y_parity = 1;
   95|  1.63k|    }
   96|  3.36k|    return y_parity;
   97|  3.36k|}
secp256k1.c:secp256k1_keypair_save:
  156|  3.36k|static void secp256k1_keypair_save(secp256k1_keypair *keypair, const secp256k1_scalar *sk, secp256k1_ge *pk) {
  157|  3.36k|    secp256k1_scalar_get_b32(&keypair->data[0], sk);
  158|  3.36k|    secp256k1_pubkey_save((secp256k1_pubkey *)&keypair->data[32], pk);
  159|  3.36k|}
secp256k1.c:secp256k1_keypair_load:
  176|  6.72k|static int secp256k1_keypair_load(const secp256k1_context* ctx, secp256k1_scalar *sk, secp256k1_ge *pk, const secp256k1_keypair *keypair) {
  177|  6.72k|    int ret;
  178|  6.72k|    const secp256k1_pubkey *pubkey = (const secp256k1_pubkey *)&keypair->data[32];
  179|       |
  180|       |    /* Need to declassify the pubkey because pubkey_load ARG_CHECKs if it's
  181|       |     * invalid. */
  182|  6.72k|    secp256k1_declassify(ctx, pubkey, sizeof(*pubkey));
  183|  6.72k|    ret = secp256k1_pubkey_load(ctx, pk, pubkey);
  184|  6.72k|    if (sk != NULL) {
  ------------------
  |  Branch (184:9): [True: 3.36k, False: 3.36k]
  ------------------
  185|  3.36k|        ret = ret && secp256k1_keypair_seckey_load(ctx, sk, keypair);
  ------------------
  |  Branch (185:15): [True: 3.36k, False: 0]
  |  Branch (185:22): [True: 3.36k, False: 0]
  ------------------
  186|  3.36k|    }
  187|  6.72k|    if (!ret) {
  ------------------
  |  Branch (187:9): [True: 0, False: 6.72k]
  ------------------
  188|      0|        *pk = secp256k1_ge_const_g;
  189|      0|        if (sk != NULL) {
  ------------------
  |  Branch (189:13): [True: 0, False: 0]
  ------------------
  190|      0|            *sk = secp256k1_scalar_one;
  191|      0|        }
  192|      0|    }
  193|  6.72k|    return ret;
  194|  6.72k|}
secp256k1.c:secp256k1_keypair_seckey_load:
  162|  3.36k|static int secp256k1_keypair_seckey_load(const secp256k1_context* ctx, secp256k1_scalar *sk, const secp256k1_keypair *keypair) {
  163|  3.36k|    int ret;
  164|       |
  165|  3.36k|    ret = secp256k1_scalar_set_b32_seckey(sk, &keypair->data[0]);
  166|       |    /* We can declassify ret here because sk is only zero if a keypair function
  167|       |     * failed (which zeroes the keypair) and its return value is ignored. */
  168|  3.36k|    secp256k1_declassify(ctx, &ret, sizeof(ret));
  169|  3.36k|    ARG_CHECK(ret);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  170|  3.36k|    return ret;
  171|  3.36k|}

secp256k1_schnorrsig_sign32:
  199|  3.36k|int secp256k1_schnorrsig_sign32(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32) {
  200|       |    /* We cast away const from the passed aux_rand32 argument since we know the default nonce function does not modify it. */
  201|  3.36k|    return secp256k1_schnorrsig_sign_internal(ctx, sig64, msg32, 32, keypair, secp256k1_nonce_function_bip340, (unsigned char*)aux_rand32);
  202|  3.36k|}
secp256k1_schnorrsig_verify:
  223|  7.70k|int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey) {
  224|  7.70k|    secp256k1_scalar s;
  225|  7.70k|    secp256k1_scalar e;
  226|  7.70k|    secp256k1_gej rj;
  227|  7.70k|    secp256k1_ge pk;
  228|  7.70k|    secp256k1_gej pkj;
  229|  7.70k|    secp256k1_fe rx;
  230|  7.70k|    secp256k1_ge r;
  231|  7.70k|    unsigned char buf[32];
  232|  7.70k|    int overflow;
  233|       |
  234|  7.70k|    VERIFY_CHECK(ctx != NULL);
  235|  7.70k|    ARG_CHECK(sig64 != NULL);
  ------------------
  |  |   45|  7.70k|#define ARG_CHECK(cond) do { \
  |  |   46|  7.70k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  7.70k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 7.70k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  7.70k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 7.70k]
  |  |  ------------------
  ------------------
  236|  7.70k|    ARG_CHECK(msg != NULL || msglen == 0);
  ------------------
  |  |   45|  7.70k|#define ARG_CHECK(cond) do { \
  |  |   46|  7.70k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  7.70k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 7.70k]
  |  |  |  |  |  Branch (136:39): [True: 7.70k, False: 0]
  |  |  |  |  |  Branch (136:39): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  7.70k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 7.70k]
  |  |  ------------------
  ------------------
  237|  7.70k|    ARG_CHECK(pubkey != NULL);
  ------------------
  |  |   45|  7.70k|#define ARG_CHECK(cond) do { \
  |  |   46|  7.70k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  7.70k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 7.70k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  7.70k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 7.70k]
  |  |  ------------------
  ------------------
  238|       |
  239|  7.70k|    if (!secp256k1_fe_set_b32_limit(&rx, &sig64[0])) {
  ------------------
  |  |   88|  7.70k|#  define secp256k1_fe_set_b32_limit secp256k1_fe_impl_set_b32_limit
  ------------------
  |  Branch (239:9): [True: 0, False: 7.70k]
  ------------------
  240|      0|        return 0;
  241|      0|    }
  242|       |
  243|  7.70k|    secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);
  244|  7.70k|    if (overflow) {
  ------------------
  |  Branch (244:9): [True: 0, False: 7.70k]
  ------------------
  245|      0|        return 0;
  246|      0|    }
  247|       |
  248|  7.70k|    if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {
  ------------------
  |  Branch (248:9): [True: 0, False: 7.70k]
  ------------------
  249|      0|        return 0;
  250|      0|    }
  251|       |
  252|       |    /* Compute e. */
  253|  7.70k|    secp256k1_fe_get_b32(buf, &pk.x);
  ------------------
  |  |   89|  7.70k|#  define secp256k1_fe_get_b32 secp256k1_fe_impl_get_b32
  ------------------
  254|  7.70k|    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, buf);
  255|       |
  256|       |    /* Compute rj =  s*G + (-e)*pkj */
  257|  7.70k|    secp256k1_scalar_negate(&e, &e);
  258|  7.70k|    secp256k1_gej_set_ge(&pkj, &pk);
  259|  7.70k|    secp256k1_ecmult(&rj, &pkj, &e, &s);
  260|       |
  261|  7.70k|    secp256k1_ge_set_gej_var(&r, &rj);
  262|  7.70k|    if (secp256k1_ge_is_infinity(&r)) {
  ------------------
  |  Branch (262:9): [True: 0, False: 7.70k]
  ------------------
  263|      0|        return 0;
  264|      0|    }
  265|       |
  266|  7.70k|    secp256k1_fe_normalize_var(&r.y);
  ------------------
  |  |   80|  7.70k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  267|  7.70k|    return !secp256k1_fe_is_odd(&r.y) &&
  ------------------
  |  |   85|  7.70k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
  |  Branch (267:12): [True: 6.89k, False: 816]
  ------------------
  268|  6.89k|           secp256k1_fe_equal(&rx, &r.x);
  ------------------
  |  Branch (268:12): [True: 6.03k, False: 861]
  ------------------
  269|  7.70k|}
secp256k1.c:nonce_function_bip340:
   52|  3.36k|static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data) {
   53|  3.36k|    secp256k1_sha256 sha;
   54|  3.36k|    unsigned char masked_key[32];
   55|  3.36k|    int i;
   56|       |
   57|  3.36k|    if (algo == NULL) {
  ------------------
  |  Branch (57:9): [True: 0, False: 3.36k]
  ------------------
   58|      0|        return 0;
   59|      0|    }
   60|       |
   61|  3.36k|    if (data != NULL) {
  ------------------
  |  Branch (61:9): [True: 3.36k, False: 0]
  ------------------
   62|  3.36k|        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);
   63|  3.36k|        secp256k1_sha256_write(&sha, data, 32);
   64|  3.36k|        secp256k1_sha256_finalize(&sha, masked_key);
   65|   110k|        for (i = 0; i < 32; i++) {
  ------------------
  |  Branch (65:21): [True: 107k, False: 3.36k]
  ------------------
   66|   107k|            masked_key[i] ^= key32[i];
   67|   107k|        }
   68|  3.36k|    } else {
   69|       |        /* Precomputed TaggedHash("BIP0340/aux", 0x0000...00); */
   70|      0|        static const unsigned char ZERO_MASK[32] = {
   71|      0|              84, 241, 105, 207, 201, 226, 229, 114,
   72|      0|             116, 128,  68,  31, 144, 186,  37, 196,
   73|      0|             136, 244,  97, 199,  11,  94, 165, 220,
   74|      0|             170, 247, 175, 105, 39,  10, 165,  20
   75|      0|        };
   76|      0|        for (i = 0; i < 32; i++) {
  ------------------
  |  Branch (76:21): [True: 0, False: 0]
  ------------------
   77|      0|            masked_key[i] = key32[i] ^ ZERO_MASK[i];
   78|      0|        }
   79|      0|    }
   80|       |
   81|       |    /* Tag the hash with algo which is important to avoid nonce reuse across
   82|       |     * algorithms. If this nonce function is used in BIP-340 signing as defined
   83|       |     * in the spec, an optimized tagging implementation is used. */
   84|  3.36k|    if (algolen == sizeof(bip340_algo)
  ------------------
  |  Branch (84:9): [True: 3.36k, False: 0]
  ------------------
   85|  3.36k|            && secp256k1_memcmp_var(algo, bip340_algo, algolen) == 0) {
  ------------------
  |  Branch (85:16): [True: 3.36k, False: 0]
  ------------------
   86|  3.36k|        secp256k1_nonce_function_bip340_sha256_tagged(&sha);
   87|  3.36k|    } else {
   88|      0|        secp256k1_sha256_initialize_tagged(&sha, algo, algolen);
   89|      0|    }
   90|       |
   91|       |    /* Hash masked-key||pk||msg using the tagged hash as per the spec */
   92|  3.36k|    secp256k1_sha256_write(&sha, masked_key, 32);
   93|  3.36k|    secp256k1_sha256_write(&sha, xonly_pk32, 32);
   94|  3.36k|    secp256k1_sha256_write(&sha, msg, msglen);
   95|  3.36k|    secp256k1_sha256_finalize(&sha, nonce32);
   96|  3.36k|    secp256k1_sha256_clear(&sha);
   97|  3.36k|    secp256k1_memclear(masked_key, sizeof(masked_key));
   98|       |
   99|  3.36k|    return 1;
  100|  3.36k|}
secp256k1.c:secp256k1_nonce_function_bip340_sha256_tagged_aux:
   32|  3.36k|static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {
   33|  3.36k|    secp256k1_sha256_initialize(sha);
   34|  3.36k|    sha->s[0] = 0x24dd3219ul;
   35|  3.36k|    sha->s[1] = 0x4eba7e70ul;
   36|  3.36k|    sha->s[2] = 0xca0fabb9ul;
   37|  3.36k|    sha->s[3] = 0x0fa3166dul;
   38|  3.36k|    sha->s[4] = 0x3afbe4b1ul;
   39|  3.36k|    sha->s[5] = 0x4c44df97ul;
   40|  3.36k|    sha->s[6] = 0x4aac2739ul;
   41|  3.36k|    sha->s[7] = 0x249e850aul;
   42|       |
   43|  3.36k|    sha->bytes = 64;
   44|  3.36k|}
secp256k1.c:secp256k1_nonce_function_bip340_sha256_tagged:
   16|  3.36k|static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {
   17|  3.36k|    secp256k1_sha256_initialize(sha);
   18|  3.36k|    sha->s[0] = 0x46615b35ul;
   19|  3.36k|    sha->s[1] = 0xf4bfbff7ul;
   20|  3.36k|    sha->s[2] = 0x9f8dc671ul;
   21|  3.36k|    sha->s[3] = 0x83627ab3ul;
   22|  3.36k|    sha->s[4] = 0x60217180ul;
   23|  3.36k|    sha->s[5] = 0x57358661ul;
   24|  3.36k|    sha->s[6] = 0x21a29e54ul;
   25|  3.36k|    sha->s[7] = 0x68b07b4cul;
   26|       |
   27|  3.36k|    sha->bytes = 64;
   28|  3.36k|}
secp256k1.c:secp256k1_schnorrsig_sign_internal:
  135|  3.36k|static int secp256k1_schnorrsig_sign_internal(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {
  136|  3.36k|    secp256k1_scalar sk;
  137|  3.36k|    secp256k1_scalar e;
  138|  3.36k|    secp256k1_scalar k;
  139|  3.36k|    secp256k1_gej rj;
  140|  3.36k|    secp256k1_ge pk;
  141|  3.36k|    secp256k1_ge r;
  142|  3.36k|    unsigned char buf[32] = { 0 };
  143|  3.36k|    unsigned char pk_buf[32];
  144|  3.36k|    unsigned char seckey[32];
  145|  3.36k|    int ret = 1;
  146|       |
  147|  3.36k|    VERIFY_CHECK(ctx != NULL);
  148|  3.36k|    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  149|  3.36k|    ARG_CHECK(sig64 != NULL);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  150|  3.36k|    ARG_CHECK(msg != NULL || msglen == 0);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  |  Branch (136:39): [True: 3.36k, False: 0]
  |  |  |  |  |  Branch (136:39): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  151|  3.36k|    ARG_CHECK(keypair != NULL);
  ------------------
  |  |   45|  3.36k|#define ARG_CHECK(cond) do { \
  |  |   46|  3.36k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  3.36k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  3.36k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 3.36k]
  |  |  ------------------
  ------------------
  152|       |
  153|  3.36k|    if (noncefp == NULL) {
  ------------------
  |  Branch (153:9): [True: 0, False: 3.36k]
  ------------------
  154|      0|        noncefp = secp256k1_nonce_function_bip340;
  155|      0|    }
  156|       |
  157|  3.36k|    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);
  158|       |    /* Because we are signing for a x-only pubkey, the secret key is negated
  159|       |     * before signing if the point corresponding to the secret key does not
  160|       |     * have an even Y. */
  161|  3.36k|    if (secp256k1_fe_is_odd(&pk.y)) {
  ------------------
  |  |   85|  3.36k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
  |  Branch (161:9): [True: 1.63k, False: 1.72k]
  ------------------
  162|  1.63k|        secp256k1_scalar_negate(&sk, &sk);
  163|  1.63k|    }
  164|       |
  165|  3.36k|    secp256k1_scalar_get_b32(seckey, &sk);
  166|  3.36k|    secp256k1_fe_get_b32(pk_buf, &pk.x);
  ------------------
  |  |   89|  3.36k|#  define secp256k1_fe_get_b32 secp256k1_fe_impl_get_b32
  ------------------
  167|  3.36k|    ret &= !!noncefp(buf, msg, msglen, seckey, pk_buf, bip340_algo, sizeof(bip340_algo), ndata);
  168|  3.36k|    secp256k1_scalar_set_b32(&k, buf, NULL);
  169|  3.36k|    ret &= !secp256k1_scalar_is_zero(&k);
  170|  3.36k|    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);
  171|       |
  172|  3.36k|    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);
  173|  3.36k|    secp256k1_ge_set_gej(&r, &rj);
  174|       |
  175|       |    /* We declassify r to allow using it as a branch point. This is fine
  176|       |     * because r is not a secret. */
  177|  3.36k|    secp256k1_declassify(ctx, &r, sizeof(r));
  178|  3.36k|    secp256k1_fe_normalize_var(&r.y);
  ------------------
  |  |   80|  3.36k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  179|  3.36k|    if (secp256k1_fe_is_odd(&r.y)) {
  ------------------
  |  |   85|  3.36k|#  define secp256k1_fe_is_odd secp256k1_fe_impl_is_odd
  ------------------
  |  Branch (179:9): [True: 1.65k, False: 1.70k]
  ------------------
  180|  1.65k|        secp256k1_scalar_negate(&k, &k);
  181|  1.65k|    }
  182|  3.36k|    secp256k1_fe_normalize_var(&r.x);
  ------------------
  |  |   80|  3.36k|#  define secp256k1_fe_normalize_var secp256k1_fe_impl_normalize_var
  ------------------
  183|  3.36k|    secp256k1_fe_get_b32(&sig64[0], &r.x);
  ------------------
  |  |   89|  3.36k|#  define secp256k1_fe_get_b32 secp256k1_fe_impl_get_b32
  ------------------
  184|       |
  185|  3.36k|    secp256k1_schnorrsig_challenge(&e, &sig64[0], msg, msglen, pk_buf);
  186|  3.36k|    secp256k1_scalar_mul(&e, &e, &sk);
  187|  3.36k|    secp256k1_scalar_add(&e, &e, &k);
  188|  3.36k|    secp256k1_scalar_get_b32(&sig64[32], &e);
  189|       |
  190|  3.36k|    secp256k1_memczero(sig64, 64, !ret);
  191|  3.36k|    secp256k1_scalar_clear(&k);
  192|  3.36k|    secp256k1_scalar_clear(&sk);
  193|  3.36k|    secp256k1_memclear(seckey, sizeof(seckey));
  194|  3.36k|    secp256k1_gej_clear(&rj);
  195|       |
  196|  3.36k|    return ret;
  197|  3.36k|}
secp256k1.c:secp256k1_schnorrsig_challenge:
  120|  11.0k|{
  121|  11.0k|    unsigned char buf[32];
  122|  11.0k|    secp256k1_sha256 sha;
  123|       |
  124|       |    /* tagged hash(r.x, pk.x, msg) */
  125|  11.0k|    secp256k1_schnorrsig_sha256_tagged(&sha);
  126|  11.0k|    secp256k1_sha256_write(&sha, r32, 32);
  127|  11.0k|    secp256k1_sha256_write(&sha, pubkey32, 32);
  128|  11.0k|    secp256k1_sha256_write(&sha, msg, msglen);
  129|  11.0k|    secp256k1_sha256_finalize(&sha, buf);
  130|       |    /* Set scalar e to the challenge hash modulo the curve order as per
  131|       |     * BIP340. */
  132|       |    secp256k1_scalar_set_b32(e, buf, NULL);
  133|  11.0k|}
secp256k1.c:secp256k1_schnorrsig_sha256_tagged:
  106|  11.0k|static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {
  107|  11.0k|    secp256k1_sha256_initialize(sha);
  108|  11.0k|    sha->s[0] = 0x9cecba11ul;
  109|  11.0k|    sha->s[1] = 0x23925381ul;
  110|  11.0k|    sha->s[2] = 0x11679112ul;
  111|  11.0k|    sha->s[3] = 0xd1627e0ful;
  112|  11.0k|    sha->s[4] = 0x97c87550ul;
  113|  11.0k|    sha->s[5] = 0x003cc765ul;
  114|  11.0k|    sha->s[6] = 0x90f61164ul;
  115|  11.0k|    sha->s[7] = 0x33e9b66aul;
  116|  11.0k|    sha->bytes = 64;
  117|  11.0k|}

secp256k1.c:secp256k1_scalar_set_b32:
  144|   187k|static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *b32, int *overflow) {
  145|   187k|    int over;
  146|   187k|    r->d[0] = secp256k1_read_be64(&b32[24]);
  147|   187k|    r->d[1] = secp256k1_read_be64(&b32[16]);
  148|   187k|    r->d[2] = secp256k1_read_be64(&b32[8]);
  149|   187k|    r->d[3] = secp256k1_read_be64(&b32[0]);
  150|   187k|    over = secp256k1_scalar_reduce(r, secp256k1_scalar_check_overflow(r));
  151|   187k|    if (overflow) {
  ------------------
  |  Branch (151:9): [True: 173k, False: 14.4k]
  ------------------
  152|   173k|        *overflow = over;
  153|   173k|    }
  154|       |
  155|   187k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|   187k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  156|   187k|}
secp256k1.c:secp256k1_scalar_reduce:
   74|   437k|SECP256K1_INLINE static int secp256k1_scalar_reduce(secp256k1_scalar *r, unsigned int overflow) {
   75|   437k|    secp256k1_uint128 t;
   76|   437k|    VERIFY_CHECK(overflow <= 1);
   77|       |
   78|   437k|    secp256k1_u128_from_u64(&t, r->d[0]);
   79|   437k|    secp256k1_u128_accum_u64(&t, overflow * SECP256K1_N_C_0);
  ------------------
  |  |   22|   437k|#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)
  |  |  ------------------
  |  |  |  |   16|   437k|#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)
  |  |  ------------------
  ------------------
   80|   437k|    r->d[0] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
   81|   437k|    secp256k1_u128_accum_u64(&t, r->d[1]);
   82|   437k|    secp256k1_u128_accum_u64(&t, overflow * SECP256K1_N_C_1);
  ------------------
  |  |   23|   437k|#define SECP256K1_N_C_1 (~SECP256K1_N_1)
  |  |  ------------------
  |  |  |  |   17|   437k|#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)
  |  |  ------------------
  ------------------
   83|   437k|    r->d[1] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
   84|   437k|    secp256k1_u128_accum_u64(&t, r->d[2]);
   85|   437k|    secp256k1_u128_accum_u64(&t, overflow * SECP256K1_N_C_2);
  ------------------
  |  |   24|   437k|#define SECP256K1_N_C_2 (1)
  ------------------
   86|   437k|    r->d[2] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
   87|   437k|    secp256k1_u128_accum_u64(&t, r->d[3]);
   88|   437k|    r->d[3] = secp256k1_u128_to_u64(&t);
   89|       |
   90|   437k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|   437k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
   91|   437k|    return overflow;
   92|   437k|}
secp256k1.c:secp256k1_scalar_check_overflow:
   62|   437k|SECP256K1_INLINE static int secp256k1_scalar_check_overflow(const secp256k1_scalar *a) {
   63|   437k|    int yes = 0;
   64|   437k|    int no = 0;
   65|   437k|    no |= (a->d[3] < SECP256K1_N_3); /* No need for a > check. */
  ------------------
  |  |   19|   437k|#define SECP256K1_N_3 ((uint64_t)0xFFFFFFFFFFFFFFFFULL)
  ------------------
   66|   437k|    no |= (a->d[2] < SECP256K1_N_2);
  ------------------
  |  |   18|   437k|#define SECP256K1_N_2 ((uint64_t)0xFFFFFFFFFFFFFFFEULL)
  ------------------
   67|   437k|    yes |= (a->d[2] > SECP256K1_N_2) & ~no;
  ------------------
  |  |   18|   437k|#define SECP256K1_N_2 ((uint64_t)0xFFFFFFFFFFFFFFFEULL)
  ------------------
   68|   437k|    no |= (a->d[1] < SECP256K1_N_1);
  ------------------
  |  |   17|   437k|#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)
  ------------------
   69|   437k|    yes |= (a->d[1] > SECP256K1_N_1) & ~no;
  ------------------
  |  |   17|   437k|#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)
  ------------------
   70|   437k|    yes |= (a->d[0] >= SECP256K1_N_0) & ~no;
  ------------------
  |  |   16|   437k|#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)
  ------------------
   71|   437k|    return yes;
   72|   437k|}
secp256k1.c:secp256k1_scalar_get_b32:
  158|  33.6k|static void secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar* a) {
  159|  33.6k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|  33.6k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  160|       |
  161|  33.6k|    secp256k1_write_be64(&bin[0],  a->d[3]);
  162|  33.6k|    secp256k1_write_be64(&bin[8],  a->d[2]);
  163|  33.6k|    secp256k1_write_be64(&bin[16], a->d[1]);
  164|  33.6k|    secp256k1_write_be64(&bin[24], a->d[0]);
  165|  33.6k|}
secp256k1.c:secp256k1_scalar_negate:
  173|  39.1k|static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar *a) {
  174|  39.1k|    uint64_t nonzero = 0xFFFFFFFFFFFFFFFFULL * (secp256k1_scalar_is_zero(a) == 0);
  175|  39.1k|    secp256k1_uint128 t;
  176|  39.1k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|  39.1k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  177|       |
  178|  39.1k|    secp256k1_u128_from_u64(&t, ~a->d[0]);
  179|  39.1k|    secp256k1_u128_accum_u64(&t, SECP256K1_N_0 + 1);
  ------------------
  |  |   16|  39.1k|#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)
  ------------------
  180|  39.1k|    r->d[0] = secp256k1_u128_to_u64(&t) & nonzero; secp256k1_u128_rshift(&t, 64);
  181|  39.1k|    secp256k1_u128_accum_u64(&t, ~a->d[1]);
  182|  39.1k|    secp256k1_u128_accum_u64(&t, SECP256K1_N_1);
  ------------------
  |  |   17|  39.1k|#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)
  ------------------
  183|  39.1k|    r->d[1] = secp256k1_u128_to_u64(&t) & nonzero; secp256k1_u128_rshift(&t, 64);
  184|  39.1k|    secp256k1_u128_accum_u64(&t, ~a->d[2]);
  185|  39.1k|    secp256k1_u128_accum_u64(&t, SECP256K1_N_2);
  ------------------
  |  |   18|  39.1k|#define SECP256K1_N_2 ((uint64_t)0xFFFFFFFFFFFFFFFEULL)
  ------------------
  186|  39.1k|    r->d[2] = secp256k1_u128_to_u64(&t) & nonzero; secp256k1_u128_rshift(&t, 64);
  187|  39.1k|    secp256k1_u128_accum_u64(&t, ~a->d[3]);
  188|  39.1k|    secp256k1_u128_accum_u64(&t, SECP256K1_N_3);
  ------------------
  |  |   19|  39.1k|#define SECP256K1_N_3 ((uint64_t)0xFFFFFFFFFFFFFFFFULL)
  ------------------
  189|  39.1k|    r->d[3] = secp256k1_u128_to_u64(&t) & nonzero;
  190|       |
  191|  39.1k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|  39.1k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  192|  39.1k|}
secp256k1.c:secp256k1_scalar_get_bits_limb32:
   41|  2.62M|SECP256K1_INLINE static uint32_t secp256k1_scalar_get_bits_limb32(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {
   42|  2.62M|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|  2.62M|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
   43|  2.62M|    VERIFY_CHECK(count > 0 && count <= 32);
   44|  2.62M|    VERIFY_CHECK((offset + count - 1) >> 6 == offset >> 6);
   45|       |
   46|  2.62M|    return (a->d[offset >> 6] >> (offset & 0x3F)) & (0xFFFFFFFF >> (32 - count));
   47|  2.62M|}
secp256k1.c:secp256k1_scalar_cmov:
  911|   115k|static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag) {
  912|   115k|    uint64_t mask0, mask1;
  913|   115k|    volatile int vflag = flag;
  914|   115k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|   115k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  915|   115k|    SECP256K1_CHECKMEM_CHECK_VERIFY(r->d, sizeof(r->d));
  ------------------
  |  |   99|   115k|#define SECP256K1_CHECKMEM_CHECK_VERIFY(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|   115k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 115k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  916|       |
  917|   115k|    mask0 = vflag + ~((uint64_t)0);
  918|   115k|    mask1 = ~mask0;
  919|   115k|    r->d[0] = (r->d[0] & mask0) | (a->d[0] & mask1);
  920|   115k|    r->d[1] = (r->d[1] & mask0) | (a->d[1] & mask1);
  921|   115k|    r->d[2] = (r->d[2] & mask0) | (a->d[2] & mask1);
  922|   115k|    r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);
  923|       |
  924|   115k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|   115k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  925|   115k|}
secp256k1.c:secp256k1_scalar_half:
  194|  12.6k|static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {
  195|       |    /* Writing `/` for field division and `//` for integer division, we compute
  196|       |     *
  197|       |     *   a/2 = (a - (a&1))/2 + (a&1)/2
  198|       |     *       = (a >> 1) + (a&1 ?    1/2 : 0)
  199|       |     *       = (a >> 1) + (a&1 ? n//2+1 : 0),
  200|       |     *
  201|       |     * where n is the group order and in the last equality we have used 1/2 = n//2+1 (mod n).
  202|       |     * For n//2, we have the constants SECP256K1_N_H_0, ...
  203|       |     *
  204|       |     * This sum does not overflow. The most extreme case is a = -2, the largest odd scalar. Here:
  205|       |     * - the left summand is:  a >> 1 = (a - a&1)/2 = (n-2-1)//2           = (n-3)//2
  206|       |     * - the right summand is: a&1 ? n//2+1 : 0 = n//2+1 = (n-1)//2 + 2//2 = (n+1)//2
  207|       |     * Together they sum to (n-3)//2 + (n+1)//2 = (2n-2)//2 = n - 1, which is less than n.
  208|       |     */
  209|  12.6k|    uint64_t mask = -(uint64_t)(a->d[0] & 1U);
  210|  12.6k|    secp256k1_uint128 t;
  211|  12.6k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|  12.6k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  212|       |
  213|  12.6k|    secp256k1_u128_from_u64(&t, (a->d[0] >> 1) | (a->d[1] << 63));
  214|  12.6k|    secp256k1_u128_accum_u64(&t, (SECP256K1_N_H_0 + 1U) & mask);
  ------------------
  |  |   27|  12.6k|#define SECP256K1_N_H_0 ((uint64_t)0xDFE92F46681B20A0ULL)
  ------------------
  215|  12.6k|    r->d[0] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  216|  12.6k|    secp256k1_u128_accum_u64(&t, (a->d[1] >> 1) | (a->d[2] << 63));
  217|  12.6k|    secp256k1_u128_accum_u64(&t, SECP256K1_N_H_1 & mask);
  ------------------
  |  |   28|  12.6k|#define SECP256K1_N_H_1 ((uint64_t)0x5D576E7357A4501DULL)
  ------------------
  218|  12.6k|    r->d[1] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  219|  12.6k|    secp256k1_u128_accum_u64(&t, (a->d[2] >> 1) | (a->d[3] << 63));
  220|  12.6k|    secp256k1_u128_accum_u64(&t, SECP256K1_N_H_2 & mask);
  ------------------
  |  |   29|  12.6k|#define SECP256K1_N_H_2 ((uint64_t)0xFFFFFFFFFFFFFFFFULL)
  ------------------
  221|  12.6k|    r->d[2] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  222|  12.6k|    r->d[3] = secp256k1_u128_to_u64(&t) + (a->d[3] >> 1) + (SECP256K1_N_H_3 & mask);
  ------------------
  |  |   30|  12.6k|#define SECP256K1_N_H_3 ((uint64_t)0x7FFFFFFFFFFFFFFFULL)
  ------------------
  223|       |#ifdef VERIFY
  224|       |    /* The line above only computed the bottom 64 bits of r->d[3]; redo the computation
  225|       |     * in full 128 bits to make sure the top 64 bits are indeed zero. */
  226|       |    secp256k1_u128_accum_u64(&t, a->d[3] >> 1);
  227|       |    secp256k1_u128_accum_u64(&t, SECP256K1_N_H_3 & mask);
  228|       |    secp256k1_u128_rshift(&t, 64);
  229|       |    VERIFY_CHECK(secp256k1_u128_to_u64(&t) == 0);
  230|       |
  231|       |    SECP256K1_SCALAR_VERIFY(r);
  232|       |#endif
  233|  12.6k|}
secp256k1.c:secp256k1_scalar_mul_shift_var:
  889|  40.7k|SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b, unsigned int shift) {
  890|  40.7k|    uint64_t l[8];
  891|  40.7k|    unsigned int shiftlimbs;
  892|  40.7k|    unsigned int shiftlow;
  893|  40.7k|    unsigned int shifthigh;
  894|  40.7k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|  40.7k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  895|  40.7k|    SECP256K1_SCALAR_VERIFY(b);
  ------------------
  |  |  103|  40.7k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  896|  40.7k|    VERIFY_CHECK(shift >= 256);
  897|       |
  898|  40.7k|    secp256k1_scalar_mul_512(l, a, b);
  899|  40.7k|    shiftlimbs = shift >> 6;
  900|  40.7k|    shiftlow = shift & 0x3F;
  901|  40.7k|    shifthigh = 64 - shiftlow;
  902|  40.7k|    r->d[0] = shift < 512 ? (l[0 + shiftlimbs] >> shiftlow | (shift < 448 && shiftlow ? (l[1 + shiftlimbs] << shifthigh) : 0)) : 0;
  ------------------
  |  Branch (902:15): [True: 40.7k, False: 0]
  |  Branch (902:63): [True: 40.7k, False: 0]
  |  Branch (902:78): [True: 0, False: 40.7k]
  ------------------
  903|  40.7k|    r->d[1] = shift < 448 ? (l[1 + shiftlimbs] >> shiftlow | (shift < 384 && shiftlow ? (l[2 + shiftlimbs] << shifthigh) : 0)) : 0;
  ------------------
  |  Branch (903:15): [True: 40.7k, False: 0]
  |  Branch (903:63): [True: 0, False: 40.7k]
  |  Branch (903:78): [True: 0, False: 0]
  ------------------
  904|  40.7k|    r->d[2] = shift < 384 ? (l[2 + shiftlimbs] >> shiftlow | (shift < 320 && shiftlow ? (l[3 + shiftlimbs] << shifthigh) : 0)) : 0;
  ------------------
  |  Branch (904:15): [True: 0, False: 40.7k]
  |  Branch (904:63): [True: 0, False: 0]
  |  Branch (904:78): [True: 0, False: 0]
  ------------------
  905|  40.7k|    r->d[3] = shift < 320 ? (l[3 + shiftlimbs] >> shiftlow) : 0;
  ------------------
  |  Branch (905:15): [True: 0, False: 40.7k]
  ------------------
  906|  40.7k|    secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1);
  907|       |
  908|  40.7k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|  40.7k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  909|  40.7k|}
secp256k1.c:secp256k1_scalar_mul_512:
  678|   105k|static void secp256k1_scalar_mul_512(uint64_t *l8, const secp256k1_scalar *a, const secp256k1_scalar *b) {
  679|   105k|#ifdef USE_ASM_X86_64
  680|   105k|    const uint64_t *pb = b->d;
  681|   105k|    __asm__ __volatile__(
  682|       |    /* Preload */
  683|   105k|    "movq 0(%%rdi), %%r15\n"
  684|   105k|    "movq 8(%%rdi), %%rbx\n"
  685|   105k|    "movq 16(%%rdi), %%rcx\n"
  686|   105k|    "movq 0(%%rdx), %%r11\n"
  687|   105k|    "movq 8(%%rdx), %%r12\n"
  688|   105k|    "movq 16(%%rdx), %%r13\n"
  689|   105k|    "movq 24(%%rdx), %%r14\n"
  690|       |    /* (rax,rdx) = a0 * b0 */
  691|   105k|    "movq %%r15, %%rax\n"
  692|   105k|    "mulq %%r11\n"
  693|       |    /* Extract l8[0] */
  694|   105k|    "movq %%rax, 0(%%rsi)\n"
  695|       |    /* (r8,r9,r10) = (rdx) */
  696|   105k|    "movq %%rdx, %%r8\n"
  697|   105k|    "xorq %%r9, %%r9\n"
  698|   105k|    "xorq %%r10, %%r10\n"
  699|       |    /* (r8,r9,r10) += a0 * b1 */
  700|   105k|    "movq %%r15, %%rax\n"
  701|   105k|    "mulq %%r12\n"
  702|   105k|    "addq %%rax, %%r8\n"
  703|   105k|    "adcq %%rdx, %%r9\n"
  704|   105k|    "adcq $0, %%r10\n"
  705|       |    /* (r8,r9,r10) += a1 * b0 */
  706|   105k|    "movq %%rbx, %%rax\n"
  707|   105k|    "mulq %%r11\n"
  708|   105k|    "addq %%rax, %%r8\n"
  709|   105k|    "adcq %%rdx, %%r9\n"
  710|   105k|    "adcq $0, %%r10\n"
  711|       |    /* Extract l8[1] */
  712|   105k|    "movq %%r8, 8(%%rsi)\n"
  713|   105k|    "xorq %%r8, %%r8\n"
  714|       |    /* (r9,r10,r8) += a0 * b2 */
  715|   105k|    "movq %%r15, %%rax\n"
  716|   105k|    "mulq %%r13\n"
  717|   105k|    "addq %%rax, %%r9\n"
  718|   105k|    "adcq %%rdx, %%r10\n"
  719|   105k|    "adcq $0, %%r8\n"
  720|       |    /* (r9,r10,r8) += a1 * b1 */
  721|   105k|    "movq %%rbx, %%rax\n"
  722|   105k|    "mulq %%r12\n"
  723|   105k|    "addq %%rax, %%r9\n"
  724|   105k|    "adcq %%rdx, %%r10\n"
  725|   105k|    "adcq $0, %%r8\n"
  726|       |    /* (r9,r10,r8) += a2 * b0 */
  727|   105k|    "movq %%rcx, %%rax\n"
  728|   105k|    "mulq %%r11\n"
  729|   105k|    "addq %%rax, %%r9\n"
  730|   105k|    "adcq %%rdx, %%r10\n"
  731|   105k|    "adcq $0, %%r8\n"
  732|       |    /* Extract l8[2] */
  733|   105k|    "movq %%r9, 16(%%rsi)\n"
  734|   105k|    "xorq %%r9, %%r9\n"
  735|       |    /* (r10,r8,r9) += a0 * b3 */
  736|   105k|    "movq %%r15, %%rax\n"
  737|   105k|    "mulq %%r14\n"
  738|   105k|    "addq %%rax, %%r10\n"
  739|   105k|    "adcq %%rdx, %%r8\n"
  740|   105k|    "adcq $0, %%r9\n"
  741|       |    /* Preload a3 */
  742|   105k|    "movq 24(%%rdi), %%r15\n"
  743|       |    /* (r10,r8,r9) += a1 * b2 */
  744|   105k|    "movq %%rbx, %%rax\n"
  745|   105k|    "mulq %%r13\n"
  746|   105k|    "addq %%rax, %%r10\n"
  747|   105k|    "adcq %%rdx, %%r8\n"
  748|   105k|    "adcq $0, %%r9\n"
  749|       |    /* (r10,r8,r9) += a2 * b1 */
  750|   105k|    "movq %%rcx, %%rax\n"
  751|   105k|    "mulq %%r12\n"
  752|   105k|    "addq %%rax, %%r10\n"
  753|   105k|    "adcq %%rdx, %%r8\n"
  754|   105k|    "adcq $0, %%r9\n"
  755|       |    /* (r10,r8,r9) += a3 * b0 */
  756|   105k|    "movq %%r15, %%rax\n"
  757|   105k|    "mulq %%r11\n"
  758|   105k|    "addq %%rax, %%r10\n"
  759|   105k|    "adcq %%rdx, %%r8\n"
  760|   105k|    "adcq $0, %%r9\n"
  761|       |    /* Extract l8[3] */
  762|   105k|    "movq %%r10, 24(%%rsi)\n"
  763|   105k|    "xorq %%r10, %%r10\n"
  764|       |    /* (r8,r9,r10) += a1 * b3 */
  765|   105k|    "movq %%rbx, %%rax\n"
  766|   105k|    "mulq %%r14\n"
  767|   105k|    "addq %%rax, %%r8\n"
  768|   105k|    "adcq %%rdx, %%r9\n"
  769|   105k|    "adcq $0, %%r10\n"
  770|       |    /* (r8,r9,r10) += a2 * b2 */
  771|   105k|    "movq %%rcx, %%rax\n"
  772|   105k|    "mulq %%r13\n"
  773|   105k|    "addq %%rax, %%r8\n"
  774|   105k|    "adcq %%rdx, %%r9\n"
  775|   105k|    "adcq $0, %%r10\n"
  776|       |    /* (r8,r9,r10) += a3 * b1 */
  777|   105k|    "movq %%r15, %%rax\n"
  778|   105k|    "mulq %%r12\n"
  779|   105k|    "addq %%rax, %%r8\n"
  780|   105k|    "adcq %%rdx, %%r9\n"
  781|   105k|    "adcq $0, %%r10\n"
  782|       |    /* Extract l8[4] */
  783|   105k|    "movq %%r8, 32(%%rsi)\n"
  784|   105k|    "xorq %%r8, %%r8\n"
  785|       |    /* (r9,r10,r8) += a2 * b3 */
  786|   105k|    "movq %%rcx, %%rax\n"
  787|   105k|    "mulq %%r14\n"
  788|   105k|    "addq %%rax, %%r9\n"
  789|   105k|    "adcq %%rdx, %%r10\n"
  790|   105k|    "adcq $0, %%r8\n"
  791|       |    /* (r9,r10,r8) += a3 * b2 */
  792|   105k|    "movq %%r15, %%rax\n"
  793|   105k|    "mulq %%r13\n"
  794|   105k|    "addq %%rax, %%r9\n"
  795|   105k|    "adcq %%rdx, %%r10\n"
  796|   105k|    "adcq $0, %%r8\n"
  797|       |    /* Extract l8[5] */
  798|   105k|    "movq %%r9, 40(%%rsi)\n"
  799|       |    /* (r10,r8) += a3 * b3 */
  800|   105k|    "movq %%r15, %%rax\n"
  801|   105k|    "mulq %%r14\n"
  802|   105k|    "addq %%rax, %%r10\n"
  803|   105k|    "adcq %%rdx, %%r8\n"
  804|       |    /* Extract l8[6] */
  805|   105k|    "movq %%r10, 48(%%rsi)\n"
  806|       |    /* Extract l8[7] */
  807|   105k|    "movq %%r8, 56(%%rsi)\n"
  808|   105k|    : "+d"(pb)
  809|   105k|    : "S"(l8), "D"(a->d)
  810|   105k|    : "rax", "rbx", "rcx", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", "cc", "memory");
  811|       |
  812|   105k|    SECP256K1_CHECKMEM_MSAN_DEFINE(l8, sizeof(*l8) * 8);
  ------------------
  |  |   60|   105k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|   105k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 105k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  813|       |
  814|       |#else
  815|       |    /* 160 bit accumulator. */
  816|       |    uint64_t c0 = 0, c1 = 0;
  817|       |    uint32_t c2 = 0;
  818|       |
  819|       |    /* l8[0..7] = a[0..3] * b[0..3]. */
  820|       |    muladd_fast(a->d[0], b->d[0]);
  821|       |    extract_fast(l8[0]);
  822|       |    muladd(a->d[0], b->d[1]);
  823|       |    muladd(a->d[1], b->d[0]);
  824|       |    extract(l8[1]);
  825|       |    muladd(a->d[0], b->d[2]);
  826|       |    muladd(a->d[1], b->d[1]);
  827|       |    muladd(a->d[2], b->d[0]);
  828|       |    extract(l8[2]);
  829|       |    muladd(a->d[0], b->d[3]);
  830|       |    muladd(a->d[1], b->d[2]);
  831|       |    muladd(a->d[2], b->d[1]);
  832|       |    muladd(a->d[3], b->d[0]);
  833|       |    extract(l8[3]);
  834|       |    muladd(a->d[1], b->d[3]);
  835|       |    muladd(a->d[2], b->d[2]);
  836|       |    muladd(a->d[3], b->d[1]);
  837|       |    extract(l8[4]);
  838|       |    muladd(a->d[2], b->d[3]);
  839|       |    muladd(a->d[3], b->d[2]);
  840|       |    extract(l8[5]);
  841|       |    muladd_fast(a->d[3], b->d[3]);
  842|       |    extract_fast(l8[6]);
  843|       |    VERIFY_CHECK(c1 == 0);
  844|       |    l8[7] = c0;
  845|       |#endif
  846|   105k|}
secp256k1.c:secp256k1_scalar_cadd_bit:
  120|  40.7k|static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {
  121|  40.7k|    secp256k1_uint128 t;
  122|  40.7k|    volatile int vflag = flag;
  123|  40.7k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|  40.7k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  124|  40.7k|    VERIFY_CHECK(bit < 256);
  125|       |
  126|  40.7k|    bit += ((uint32_t) vflag - 1) & 0x100;  /* forcing (bit >> 6) > 3 makes this a noop */
  127|  40.7k|    secp256k1_u128_from_u64(&t, r->d[0]);
  128|  40.7k|    secp256k1_u128_accum_u64(&t, ((uint64_t)((bit >> 6) == 0)) << (bit & 0x3F));
  129|  40.7k|    r->d[0] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  130|  40.7k|    secp256k1_u128_accum_u64(&t, r->d[1]);
  131|  40.7k|    secp256k1_u128_accum_u64(&t, ((uint64_t)((bit >> 6) == 1)) << (bit & 0x3F));
  132|  40.7k|    r->d[1] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  133|  40.7k|    secp256k1_u128_accum_u64(&t, r->d[2]);
  134|  40.7k|    secp256k1_u128_accum_u64(&t, ((uint64_t)((bit >> 6) == 2)) << (bit & 0x3F));
  135|  40.7k|    r->d[2] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  136|  40.7k|    secp256k1_u128_accum_u64(&t, r->d[3]);
  137|  40.7k|    secp256k1_u128_accum_u64(&t, ((uint64_t)((bit >> 6) == 3)) << (bit & 0x3F));
  138|  40.7k|    r->d[3] = secp256k1_u128_to_u64(&t);
  139|       |
  140|  40.7k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|  40.7k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  141|  40.7k|    VERIFY_CHECK(secp256k1_u128_hi_u64(&t) == 0);
  142|  40.7k|}
secp256k1.c:secp256k1_scalar_get_bits_var:
   49|  1.12M|SECP256K1_INLINE static uint32_t secp256k1_scalar_get_bits_var(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {
   50|  1.12M|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|  1.12M|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
   51|  1.12M|    VERIFY_CHECK(count > 0 && count <= 32);
   52|  1.12M|    VERIFY_CHECK(offset + count <= 256);
   53|       |
   54|  1.12M|    if ((offset + count - 1) >> 6 == offset >> 6) {
  ------------------
  |  Branch (54:9): [True: 1.02M, False: 94.5k]
  ------------------
   55|  1.02M|        return secp256k1_scalar_get_bits_limb32(a, offset, count);
   56|  1.02M|    } else {
   57|  94.5k|        VERIFY_CHECK((offset >> 6) + 1 < 4);
   58|  94.5k|        return ((a->d[offset >> 6] >> (offset & 0x3F)) | (a->d[(offset >> 6) + 1] << (64 - (offset & 0x3F)))) & (0xFFFFFFFF >> (32 - count));
   59|  94.5k|    }
   60|  1.12M|}
secp256k1.c:secp256k1_scalar_split_128:
  866|  7.70k|static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *k) {
  867|  7.70k|    SECP256K1_SCALAR_VERIFY(k);
  ------------------
  |  |  103|  7.70k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  868|       |
  869|  7.70k|    r1->d[0] = k->d[0];
  870|  7.70k|    r1->d[1] = k->d[1];
  871|  7.70k|    r1->d[2] = 0;
  872|  7.70k|    r1->d[3] = 0;
  873|  7.70k|    r2->d[0] = k->d[2];
  874|  7.70k|    r2->d[1] = k->d[3];
  875|  7.70k|    r2->d[2] = 0;
  876|  7.70k|    r2->d[3] = 0;
  877|       |
  878|  7.70k|    SECP256K1_SCALAR_VERIFY(r1);
  ------------------
  |  |  103|  7.70k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  879|  7.70k|    SECP256K1_SCALAR_VERIFY(r2);
  ------------------
  |  |  103|  7.70k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  880|  7.70k|}
secp256k1.c:secp256k1_scalar_is_zero:
  167|   216k|SECP256K1_INLINE static int secp256k1_scalar_is_zero(const secp256k1_scalar *a) {
  168|   216k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|   216k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  169|       |
  170|   216k|    return (a->d[0] | a->d[1] | a->d[2] | a->d[3]) == 0;
  171|   216k|}
secp256k1.c:secp256k1_scalar_mul:
  855|  64.5k|static void secp256k1_scalar_mul(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {
  856|  64.5k|    uint64_t l[8];
  857|  64.5k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|  64.5k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  858|  64.5k|    SECP256K1_SCALAR_VERIFY(b);
  ------------------
  |  |  103|  64.5k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  859|       |
  860|  64.5k|    secp256k1_scalar_mul_512(l, a, b);
  861|  64.5k|    secp256k1_scalar_reduce_512(r, l);
  862|       |
  863|  64.5k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|  64.5k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  864|  64.5k|}
secp256k1.c:secp256k1_scalar_reduce_512:
  347|  64.5k|static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l) {
  348|  64.5k|#ifdef USE_ASM_X86_64
  349|       |    /* Reduce 512 bits into 385. */
  350|  64.5k|    uint64_t m0, m1, m2, m3, m4, m5, m6;
  351|  64.5k|    uint64_t p0, p1, p2, p3, p4;
  352|  64.5k|    uint64_t c;
  353|       |
  354|  64.5k|    __asm__ __volatile__(
  355|       |    /* Preload. */
  356|  64.5k|    "movq 32(%%rsi), %%r11\n"
  357|  64.5k|    "movq 40(%%rsi), %%r12\n"
  358|  64.5k|    "movq 48(%%rsi), %%r13\n"
  359|  64.5k|    "movq 56(%%rsi), %%r14\n"
  360|       |    /* Initialize r8,r9,r10 */
  361|  64.5k|    "movq 0(%%rsi), %%r8\n"
  362|  64.5k|    "xorq %%r9, %%r9\n"
  363|  64.5k|    "xorq %%r10, %%r10\n"
  364|       |    /* (r8,r9) += n0 * c0 */
  365|  64.5k|    "movq %8, %%rax\n"
  366|  64.5k|    "mulq %%r11\n"
  367|  64.5k|    "addq %%rax, %%r8\n"
  368|  64.5k|    "adcq %%rdx, %%r9\n"
  369|       |    /* extract m0 */
  370|  64.5k|    "movq %%r8, %q0\n"
  371|  64.5k|    "xorq %%r8, %%r8\n"
  372|       |    /* (r9,r10) += l1 */
  373|  64.5k|    "addq 8(%%rsi), %%r9\n"
  374|  64.5k|    "adcq $0, %%r10\n"
  375|       |    /* (r9,r10,r8) += n1 * c0 */
  376|  64.5k|    "movq %8, %%rax\n"
  377|  64.5k|    "mulq %%r12\n"
  378|  64.5k|    "addq %%rax, %%r9\n"
  379|  64.5k|    "adcq %%rdx, %%r10\n"
  380|  64.5k|    "adcq $0, %%r8\n"
  381|       |    /* (r9,r10,r8) += n0 * c1 */
  382|  64.5k|    "movq %9, %%rax\n"
  383|  64.5k|    "mulq %%r11\n"
  384|  64.5k|    "addq %%rax, %%r9\n"
  385|  64.5k|    "adcq %%rdx, %%r10\n"
  386|  64.5k|    "adcq $0, %%r8\n"
  387|       |    /* extract m1 */
  388|  64.5k|    "movq %%r9, %q1\n"
  389|  64.5k|    "xorq %%r9, %%r9\n"
  390|       |    /* (r10,r8,r9) += l2 */
  391|  64.5k|    "addq 16(%%rsi), %%r10\n"
  392|  64.5k|    "adcq $0, %%r8\n"
  393|  64.5k|    "adcq $0, %%r9\n"
  394|       |    /* (r10,r8,r9) += n2 * c0 */
  395|  64.5k|    "movq %8, %%rax\n"
  396|  64.5k|    "mulq %%r13\n"
  397|  64.5k|    "addq %%rax, %%r10\n"
  398|  64.5k|    "adcq %%rdx, %%r8\n"
  399|  64.5k|    "adcq $0, %%r9\n"
  400|       |    /* (r10,r8,r9) += n1 * c1 */
  401|  64.5k|    "movq %9, %%rax\n"
  402|  64.5k|    "mulq %%r12\n"
  403|  64.5k|    "addq %%rax, %%r10\n"
  404|  64.5k|    "adcq %%rdx, %%r8\n"
  405|  64.5k|    "adcq $0, %%r9\n"
  406|       |    /* (r10,r8,r9) += n0 */
  407|  64.5k|    "addq %%r11, %%r10\n"
  408|  64.5k|    "adcq $0, %%r8\n"
  409|  64.5k|    "adcq $0, %%r9\n"
  410|       |    /* extract m2 */
  411|  64.5k|    "movq %%r10, %q2\n"
  412|  64.5k|    "xorq %%r10, %%r10\n"
  413|       |    /* (r8,r9,r10) += l3 */
  414|  64.5k|    "addq 24(%%rsi), %%r8\n"
  415|  64.5k|    "adcq $0, %%r9\n"
  416|  64.5k|    "adcq $0, %%r10\n"
  417|       |    /* (r8,r9,r10) += n3 * c0 */
  418|  64.5k|    "movq %8, %%rax\n"
  419|  64.5k|    "mulq %%r14\n"
  420|  64.5k|    "addq %%rax, %%r8\n"
  421|  64.5k|    "adcq %%rdx, %%r9\n"
  422|  64.5k|    "adcq $0, %%r10\n"
  423|       |    /* (r8,r9,r10) += n2 * c1 */
  424|  64.5k|    "movq %9, %%rax\n"
  425|  64.5k|    "mulq %%r13\n"
  426|  64.5k|    "addq %%rax, %%r8\n"
  427|  64.5k|    "adcq %%rdx, %%r9\n"
  428|  64.5k|    "adcq $0, %%r10\n"
  429|       |    /* (r8,r9,r10) += n1 */
  430|  64.5k|    "addq %%r12, %%r8\n"
  431|  64.5k|    "adcq $0, %%r9\n"
  432|  64.5k|    "adcq $0, %%r10\n"
  433|       |    /* extract m3 */
  434|  64.5k|    "movq %%r8, %q3\n"
  435|  64.5k|    "xorq %%r8, %%r8\n"
  436|       |    /* (r9,r10,r8) += n3 * c1 */
  437|  64.5k|    "movq %9, %%rax\n"
  438|  64.5k|    "mulq %%r14\n"
  439|  64.5k|    "addq %%rax, %%r9\n"
  440|  64.5k|    "adcq %%rdx, %%r10\n"
  441|  64.5k|    "adcq $0, %%r8\n"
  442|       |    /* (r9,r10,r8) += n2 */
  443|  64.5k|    "addq %%r13, %%r9\n"
  444|  64.5k|    "adcq $0, %%r10\n"
  445|  64.5k|    "adcq $0, %%r8\n"
  446|       |    /* extract m4 */
  447|  64.5k|    "movq %%r9, %q4\n"
  448|       |    /* (r10,r8) += n3 */
  449|  64.5k|    "addq %%r14, %%r10\n"
  450|  64.5k|    "adcq $0, %%r8\n"
  451|       |    /* extract m5 */
  452|  64.5k|    "movq %%r10, %q5\n"
  453|       |    /* extract m6 */
  454|  64.5k|    "movq %%r8, %q6\n"
  455|  64.5k|    : "=&g"(m0), "=&g"(m1), "=&g"(m2), "=g"(m3), "=g"(m4), "=g"(m5), "=g"(m6)
  456|  64.5k|    : "S"(l), "i"(SECP256K1_N_C_0), "i"(SECP256K1_N_C_1)
  ------------------
  |  |   22|  64.5k|#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)
  |  |  ------------------
  |  |  |  |   16|  64.5k|#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)
  |  |  ------------------
  ------------------
                  : "S"(l), "i"(SECP256K1_N_C_0), "i"(SECP256K1_N_C_1)
  ------------------
  |  |   23|  64.5k|#define SECP256K1_N_C_1 (~SECP256K1_N_1)
  |  |  ------------------
  |  |  |  |   17|  64.5k|#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)
  |  |  ------------------
  ------------------
  457|  64.5k|    : "rax", "rdx", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "cc");
  458|       |
  459|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&m0, sizeof(m0));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  460|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&m1, sizeof(m1));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  461|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&m2, sizeof(m2));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  462|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&m3, sizeof(m3));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  463|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&m4, sizeof(m4));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  464|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&m5, sizeof(m5));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  465|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&m6, sizeof(m6));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  466|       |
  467|       |    /* Reduce 385 bits into 258. */
  468|  64.5k|    __asm__ __volatile__(
  469|       |    /* Preload */
  470|  64.5k|    "movq %q9, %%r11\n"
  471|  64.5k|    "movq %q10, %%r12\n"
  472|  64.5k|    "movq %q11, %%r13\n"
  473|       |    /* Initialize (r8,r9,r10) */
  474|  64.5k|    "movq %q5, %%r8\n"
  475|  64.5k|    "xorq %%r9, %%r9\n"
  476|  64.5k|    "xorq %%r10, %%r10\n"
  477|       |    /* (r8,r9) += m4 * c0 */
  478|  64.5k|    "movq %12, %%rax\n"
  479|  64.5k|    "mulq %%r11\n"
  480|  64.5k|    "addq %%rax, %%r8\n"
  481|  64.5k|    "adcq %%rdx, %%r9\n"
  482|       |    /* extract p0 */
  483|  64.5k|    "movq %%r8, %q0\n"
  484|  64.5k|    "xorq %%r8, %%r8\n"
  485|       |    /* (r9,r10) += m1 */
  486|  64.5k|    "addq %q6, %%r9\n"
  487|  64.5k|    "adcq $0, %%r10\n"
  488|       |    /* (r9,r10,r8) += m5 * c0 */
  489|  64.5k|    "movq %12, %%rax\n"
  490|  64.5k|    "mulq %%r12\n"
  491|  64.5k|    "addq %%rax, %%r9\n"
  492|  64.5k|    "adcq %%rdx, %%r10\n"
  493|  64.5k|    "adcq $0, %%r8\n"
  494|       |    /* (r9,r10,r8) += m4 * c1 */
  495|  64.5k|    "movq %13, %%rax\n"
  496|  64.5k|    "mulq %%r11\n"
  497|  64.5k|    "addq %%rax, %%r9\n"
  498|  64.5k|    "adcq %%rdx, %%r10\n"
  499|  64.5k|    "adcq $0, %%r8\n"
  500|       |    /* extract p1 */
  501|  64.5k|    "movq %%r9, %q1\n"
  502|  64.5k|    "xorq %%r9, %%r9\n"
  503|       |    /* (r10,r8,r9) += m2 */
  504|  64.5k|    "addq %q7, %%r10\n"
  505|  64.5k|    "adcq $0, %%r8\n"
  506|  64.5k|    "adcq $0, %%r9\n"
  507|       |    /* (r10,r8,r9) += m6 * c0 */
  508|  64.5k|    "movq %12, %%rax\n"
  509|  64.5k|    "mulq %%r13\n"
  510|  64.5k|    "addq %%rax, %%r10\n"
  511|  64.5k|    "adcq %%rdx, %%r8\n"
  512|  64.5k|    "adcq $0, %%r9\n"
  513|       |    /* (r10,r8,r9) += m5 * c1 */
  514|  64.5k|    "movq %13, %%rax\n"
  515|  64.5k|    "mulq %%r12\n"
  516|  64.5k|    "addq %%rax, %%r10\n"
  517|  64.5k|    "adcq %%rdx, %%r8\n"
  518|  64.5k|    "adcq $0, %%r9\n"
  519|       |    /* (r10,r8,r9) += m4 */
  520|  64.5k|    "addq %%r11, %%r10\n"
  521|  64.5k|    "adcq $0, %%r8\n"
  522|  64.5k|    "adcq $0, %%r9\n"
  523|       |    /* extract p2 */
  524|  64.5k|    "movq %%r10, %q2\n"
  525|       |    /* (r8,r9) += m3 */
  526|  64.5k|    "addq %q8, %%r8\n"
  527|  64.5k|    "adcq $0, %%r9\n"
  528|       |    /* (r8,r9) += m6 * c1 */
  529|  64.5k|    "movq %13, %%rax\n"
  530|  64.5k|    "mulq %%r13\n"
  531|  64.5k|    "addq %%rax, %%r8\n"
  532|  64.5k|    "adcq %%rdx, %%r9\n"
  533|       |    /* (r8,r9) += m5 */
  534|  64.5k|    "addq %%r12, %%r8\n"
  535|  64.5k|    "adcq $0, %%r9\n"
  536|       |    /* extract p3 */
  537|  64.5k|    "movq %%r8, %q3\n"
  538|       |    /* (r9) += m6 */
  539|  64.5k|    "addq %%r13, %%r9\n"
  540|       |    /* extract p4 */
  541|  64.5k|    "movq %%r9, %q4\n"
  542|  64.5k|    : "=&g"(p0), "=&g"(p1), "=&g"(p2), "=g"(p3), "=g"(p4)
  543|  64.5k|    : "g"(m0), "g"(m1), "g"(m2), "g"(m3), "g"(m4), "g"(m5), "g"(m6), "i"(SECP256K1_N_C_0), "i"(SECP256K1_N_C_1)
  ------------------
  |  |   22|  64.5k|#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)
  |  |  ------------------
  |  |  |  |   16|  64.5k|#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)
  |  |  ------------------
  ------------------
                  : "g"(m0), "g"(m1), "g"(m2), "g"(m3), "g"(m4), "g"(m5), "g"(m6), "i"(SECP256K1_N_C_0), "i"(SECP256K1_N_C_1)
  ------------------
  |  |   23|  64.5k|#define SECP256K1_N_C_1 (~SECP256K1_N_1)
  |  |  ------------------
  |  |  |  |   17|  64.5k|#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)
  |  |  ------------------
  ------------------
  544|  64.5k|    : "rax", "rdx", "r8", "r9", "r10", "r11", "r12", "r13", "cc");
  545|       |
  546|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&p0, sizeof(p0));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  547|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&p1, sizeof(p1));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  548|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&p2, sizeof(p2));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  549|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&p3, sizeof(p3));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  550|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&p4, sizeof(p4));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  551|       |
  552|       |    /* Reduce 258 bits into 256. */
  553|  64.5k|    __asm__ __volatile__(
  554|       |    /* Preload */
  555|  64.5k|    "movq %q5, %%r10\n"
  556|       |    /* (rax,rdx) = p4 * c0 */
  557|  64.5k|    "movq %7, %%rax\n"
  558|  64.5k|    "mulq %%r10\n"
  559|       |    /* (rax,rdx) += p0 */
  560|  64.5k|    "addq %q1, %%rax\n"
  561|  64.5k|    "adcq $0, %%rdx\n"
  562|       |    /* extract r0 */
  563|  64.5k|    "movq %%rax, 0(%q6)\n"
  564|       |    /* Move to (r8,r9) */
  565|  64.5k|    "movq %%rdx, %%r8\n"
  566|  64.5k|    "xorq %%r9, %%r9\n"
  567|       |    /* (r8,r9) += p1 */
  568|  64.5k|    "addq %q2, %%r8\n"
  569|  64.5k|    "adcq $0, %%r9\n"
  570|       |    /* (r8,r9) += p4 * c1 */
  571|  64.5k|    "movq %8, %%rax\n"
  572|  64.5k|    "mulq %%r10\n"
  573|  64.5k|    "addq %%rax, %%r8\n"
  574|  64.5k|    "adcq %%rdx, %%r9\n"
  575|       |    /* Extract r1 */
  576|  64.5k|    "movq %%r8, 8(%q6)\n"
  577|  64.5k|    "xorq %%r8, %%r8\n"
  578|       |    /* (r9,r8) += p4 */
  579|  64.5k|    "addq %%r10, %%r9\n"
  580|  64.5k|    "adcq $0, %%r8\n"
  581|       |    /* (r9,r8) += p2 */
  582|  64.5k|    "addq %q3, %%r9\n"
  583|  64.5k|    "adcq $0, %%r8\n"
  584|       |    /* Extract r2 */
  585|  64.5k|    "movq %%r9, 16(%q6)\n"
  586|  64.5k|    "xorq %%r9, %%r9\n"
  587|       |    /* (r8,r9) += p3 */
  588|  64.5k|    "addq %q4, %%r8\n"
  589|  64.5k|    "adcq $0, %%r9\n"
  590|       |    /* Extract r3 */
  591|  64.5k|    "movq %%r8, 24(%q6)\n"
  592|       |    /* Extract c */
  593|  64.5k|    "movq %%r9, %q0\n"
  594|  64.5k|    : "=g"(c)
  595|  64.5k|    : "g"(p0), "g"(p1), "g"(p2), "g"(p3), "g"(p4), "D"(r), "i"(SECP256K1_N_C_0), "i"(SECP256K1_N_C_1)
  ------------------
  |  |   22|  64.5k|#define SECP256K1_N_C_0 (~SECP256K1_N_0 + 1)
  |  |  ------------------
  |  |  |  |   16|  64.5k|#define SECP256K1_N_0 ((uint64_t)0xBFD25E8CD0364141ULL)
  |  |  ------------------
  ------------------
                  : "g"(p0), "g"(p1), "g"(p2), "g"(p3), "g"(p4), "D"(r), "i"(SECP256K1_N_C_0), "i"(SECP256K1_N_C_1)
  ------------------
  |  |   23|  64.5k|#define SECP256K1_N_C_1 (~SECP256K1_N_1)
  |  |  ------------------
  |  |  |  |   17|  64.5k|#define SECP256K1_N_1 ((uint64_t)0xBAAEDCE6AF48A03BULL)
  |  |  ------------------
  ------------------
  596|  64.5k|    : "rax", "rdx", "r8", "r9", "r10", "cc", "memory");
  597|       |
  598|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(r, sizeof(*r));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  599|  64.5k|    SECP256K1_CHECKMEM_MSAN_DEFINE(&c, sizeof(c));
  ------------------
  |  |   60|  64.5k|#  define SECP256K1_CHECKMEM_MSAN_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|  64.5k|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 64.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  600|       |
  601|       |#else
  602|       |    secp256k1_uint128 c128;
  603|       |    uint64_t c, c0, c1, c2;
  604|       |    uint64_t n0 = l[4], n1 = l[5], n2 = l[6], n3 = l[7];
  605|       |    uint64_t m0, m1, m2, m3, m4, m5;
  606|       |    uint32_t m6;
  607|       |    uint64_t p0, p1, p2, p3;
  608|       |    uint32_t p4;
  609|       |
  610|       |    /* Reduce 512 bits into 385. */
  611|       |    /* m[0..6] = l[0..3] + n[0..3] * SECP256K1_N_C. */
  612|       |    c0 = l[0]; c1 = 0; c2 = 0;
  613|       |    muladd_fast(n0, SECP256K1_N_C_0);
  614|       |    extract_fast(m0);
  615|       |    sumadd_fast(l[1]);
  616|       |    muladd(n1, SECP256K1_N_C_0);
  617|       |    muladd(n0, SECP256K1_N_C_1);
  618|       |    extract(m1);
  619|       |    sumadd(l[2]);
  620|       |    muladd(n2, SECP256K1_N_C_0);
  621|       |    muladd(n1, SECP256K1_N_C_1);
  622|       |    sumadd(n0);
  623|       |    extract(m2);
  624|       |    sumadd(l[3]);
  625|       |    muladd(n3, SECP256K1_N_C_0);
  626|       |    muladd(n2, SECP256K1_N_C_1);
  627|       |    sumadd(n1);
  628|       |    extract(m3);
  629|       |    muladd(n3, SECP256K1_N_C_1);
  630|       |    sumadd(n2);
  631|       |    extract(m4);
  632|       |    sumadd_fast(n3);
  633|       |    extract_fast(m5);
  634|       |    VERIFY_CHECK(c0 <= 1);
  635|       |    m6 = c0;
  636|       |
  637|       |    /* Reduce 385 bits into 258. */
  638|       |    /* p[0..4] = m[0..3] + m[4..6] * SECP256K1_N_C. */
  639|       |    c0 = m0; c1 = 0; c2 = 0;
  640|       |    muladd_fast(m4, SECP256K1_N_C_0);
  641|       |    extract_fast(p0);
  642|       |    sumadd_fast(m1);
  643|       |    muladd(m5, SECP256K1_N_C_0);
  644|       |    muladd(m4, SECP256K1_N_C_1);
  645|       |    extract(p1);
  646|       |    sumadd(m2);
  647|       |    muladd(m6, SECP256K1_N_C_0);
  648|       |    muladd(m5, SECP256K1_N_C_1);
  649|       |    sumadd(m4);
  650|       |    extract(p2);
  651|       |    sumadd_fast(m3);
  652|       |    muladd_fast(m6, SECP256K1_N_C_1);
  653|       |    sumadd_fast(m5);
  654|       |    extract_fast(p3);
  655|       |    p4 = c0 + m6;
  656|       |    VERIFY_CHECK(p4 <= 2);
  657|       |
  658|       |    /* Reduce 258 bits into 256. */
  659|       |    /* r[0..3] = p[0..3] + p[4] * SECP256K1_N_C. */
  660|       |    secp256k1_u128_from_u64(&c128, p0);
  661|       |    secp256k1_u128_accum_mul(&c128, SECP256K1_N_C_0, p4);
  662|       |    r->d[0] = secp256k1_u128_to_u64(&c128); secp256k1_u128_rshift(&c128, 64);
  663|       |    secp256k1_u128_accum_u64(&c128, p1);
  664|       |    secp256k1_u128_accum_mul(&c128, SECP256K1_N_C_1, p4);
  665|       |    r->d[1] = secp256k1_u128_to_u64(&c128); secp256k1_u128_rshift(&c128, 64);
  666|       |    secp256k1_u128_accum_u64(&c128, p2);
  667|       |    secp256k1_u128_accum_u64(&c128, p4);
  668|       |    r->d[2] = secp256k1_u128_to_u64(&c128); secp256k1_u128_rshift(&c128, 64);
  669|       |    secp256k1_u128_accum_u64(&c128, p3);
  670|       |    r->d[3] = secp256k1_u128_to_u64(&c128);
  671|       |    c = secp256k1_u128_hi_u64(&c128);
  672|       |#endif
  673|       |
  674|       |    /* Final reduction of r. */
  675|  64.5k|    secp256k1_scalar_reduce(r, c + secp256k1_scalar_check_overflow(r));
  676|  64.5k|}
secp256k1.c:secp256k1_scalar_add:
   94|   184k|static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {
   95|   184k|    int overflow;
   96|   184k|    secp256k1_uint128 t;
   97|   184k|    SECP256K1_SCALAR_VERIFY(a);
  ------------------
  |  |  103|   184k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
   98|   184k|    SECP256K1_SCALAR_VERIFY(b);
  ------------------
  |  |  103|   184k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
   99|       |
  100|   184k|    secp256k1_u128_from_u64(&t, a->d[0]);
  101|   184k|    secp256k1_u128_accum_u64(&t, b->d[0]);
  102|   184k|    r->d[0] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  103|   184k|    secp256k1_u128_accum_u64(&t, a->d[1]);
  104|   184k|    secp256k1_u128_accum_u64(&t, b->d[1]);
  105|   184k|    r->d[1] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  106|   184k|    secp256k1_u128_accum_u64(&t, a->d[2]);
  107|   184k|    secp256k1_u128_accum_u64(&t, b->d[2]);
  108|   184k|    r->d[2] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  109|   184k|    secp256k1_u128_accum_u64(&t, a->d[3]);
  110|   184k|    secp256k1_u128_accum_u64(&t, b->d[3]);
  111|   184k|    r->d[3] = secp256k1_u128_to_u64(&t); secp256k1_u128_rshift(&t, 64);
  112|   184k|    overflow = secp256k1_u128_to_u64(&t) + secp256k1_scalar_check_overflow(r);
  113|   184k|    VERIFY_CHECK(overflow == 0 || overflow == 1);
  114|   184k|    secp256k1_scalar_reduce(r, overflow);
  115|       |
  116|   184k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|   184k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  117|   184k|    return overflow;
  118|   184k|}

secp256k1.c:secp256k1_scalar_verify:
   42|  6.11M|static void secp256k1_scalar_verify(const secp256k1_scalar *r) {
   43|  6.11M|    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);
   44|       |
   45|  6.11M|    (void)r;
   46|  6.11M|}
secp256k1.c:secp256k1_scalar_set_b32_seckey:
   34|   129k|static int secp256k1_scalar_set_b32_seckey(secp256k1_scalar *r, const unsigned char *bin) {
   35|   129k|    int overflow;
   36|   129k|    secp256k1_scalar_set_b32(r, bin, &overflow);
   37|       |
   38|   129k|    SECP256K1_SCALAR_VERIFY(r);
  ------------------
  |  |  103|   129k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
   39|   129k|    return (!overflow) & (!secp256k1_scalar_is_zero(r));
   40|   129k|}
secp256k1.c:secp256k1_scalar_clear:
   30|   248k|SECP256K1_INLINE static void secp256k1_scalar_clear(secp256k1_scalar *r) {
   31|   248k|    secp256k1_memclear(r, sizeof(secp256k1_scalar));
   32|   248k|}
secp256k1.c:secp256k1_scalar_split_lambda:
  142|  20.3k|static void secp256k1_scalar_split_lambda(secp256k1_scalar * SECP256K1_RESTRICT r1, secp256k1_scalar * SECP256K1_RESTRICT r2, const secp256k1_scalar * SECP256K1_RESTRICT k) {
  143|  20.3k|    secp256k1_scalar c1, c2;
  144|  20.3k|    static const secp256k1_scalar minus_b1 = SECP256K1_SCALAR_CONST(
  ------------------
  |  |   17|  20.3k|#define SECP256K1_SCALAR_CONST(d7, d6, d5, d4, d3, d2, d1, d0) {{((uint64_t)(d1)) << 32 | (d0), ((uint64_t)(d3)) << 32 | (d2), ((uint64_t)(d5)) << 32 | (d4), ((uint64_t)(d7)) << 32 | (d6)}}
  ------------------
  145|  20.3k|        0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL,
  146|  20.3k|        0xE4437ED6UL, 0x010E8828UL, 0x6F547FA9UL, 0x0ABFE4C3UL
  147|  20.3k|    );
  148|  20.3k|    static const secp256k1_scalar minus_b2 = SECP256K1_SCALAR_CONST(
  ------------------
  |  |   17|  20.3k|#define SECP256K1_SCALAR_CONST(d7, d6, d5, d4, d3, d2, d1, d0) {{((uint64_t)(d1)) << 32 | (d0), ((uint64_t)(d3)) << 32 | (d2), ((uint64_t)(d5)) << 32 | (d4), ((uint64_t)(d7)) << 32 | (d6)}}
  ------------------
  149|  20.3k|        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFEUL,
  150|  20.3k|        0x8A280AC5UL, 0x0774346DUL, 0xD765CDA8UL, 0x3DB1562CUL
  151|  20.3k|    );
  152|  20.3k|    static const secp256k1_scalar g1 = SECP256K1_SCALAR_CONST(
  ------------------
  |  |   17|  20.3k|#define SECP256K1_SCALAR_CONST(d7, d6, d5, d4, d3, d2, d1, d0) {{((uint64_t)(d1)) << 32 | (d0), ((uint64_t)(d3)) << 32 | (d2), ((uint64_t)(d5)) << 32 | (d4), ((uint64_t)(d7)) << 32 | (d6)}}
  ------------------
  153|  20.3k|        0x3086D221UL, 0xA7D46BCDUL, 0xE86C90E4UL, 0x9284EB15UL,
  154|  20.3k|        0x3DAA8A14UL, 0x71E8CA7FUL, 0xE893209AUL, 0x45DBB031UL
  155|  20.3k|    );
  156|  20.3k|    static const secp256k1_scalar g2 = SECP256K1_SCALAR_CONST(
  ------------------
  |  |   17|  20.3k|#define SECP256K1_SCALAR_CONST(d7, d6, d5, d4, d3, d2, d1, d0) {{((uint64_t)(d1)) << 32 | (d0), ((uint64_t)(d3)) << 32 | (d2), ((uint64_t)(d5)) << 32 | (d4), ((uint64_t)(d7)) << 32 | (d6)}}
  ------------------
  157|  20.3k|        0xE4437ED6UL, 0x010E8828UL, 0x6F547FA9UL, 0x0ABFE4C4UL,
  158|  20.3k|        0x221208ACUL, 0x9DF506C6UL, 0x1571B4AEUL, 0x8AC47F71UL
  159|  20.3k|    );
  160|  20.3k|    SECP256K1_SCALAR_VERIFY(k);
  ------------------
  |  |  103|  20.3k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  161|  20.3k|    VERIFY_CHECK(r1 != k);
  162|  20.3k|    VERIFY_CHECK(r2 != k);
  163|  20.3k|    VERIFY_CHECK(r1 != r2);
  164|       |
  165|       |    /* these _var calls are constant time since the shift amount is constant */
  166|  20.3k|    secp256k1_scalar_mul_shift_var(&c1, k, &g1, 384);
  167|  20.3k|    secp256k1_scalar_mul_shift_var(&c2, k, &g2, 384);
  168|  20.3k|    secp256k1_scalar_mul(&c1, &c1, &minus_b1);
  169|  20.3k|    secp256k1_scalar_mul(&c2, &c2, &minus_b2);
  170|  20.3k|    secp256k1_scalar_add(r2, &c1, &c2);
  171|  20.3k|    secp256k1_scalar_mul(r1, r2, &secp256k1_const_lambda);
  172|  20.3k|    secp256k1_scalar_negate(r1, r1);
  173|  20.3k|    secp256k1_scalar_add(r1, r1, k);
  174|       |
  175|  20.3k|    SECP256K1_SCALAR_VERIFY(r1);
  ------------------
  |  |  103|  20.3k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  176|  20.3k|    SECP256K1_SCALAR_VERIFY(r2);
  ------------------
  |  |  103|  20.3k|#define SECP256K1_SCALAR_VERIFY(r) secp256k1_scalar_verify(r)
  ------------------
  177|       |#ifdef VERIFY
  178|       |    secp256k1_scalar_split_lambda_verify(r1, r2, k);
  179|       |#endif
  180|  20.3k|}

secp256k1_context_preallocated_destroy:
  176|      2|void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {
  177|      2|    ARG_CHECK_VOID(ctx == NULL || secp256k1_context_is_proper(ctx));
  ------------------
  |  |   52|      2|#define ARG_CHECK_VOID(cond) do { \
  |  |   53|      2|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|      4|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 2]
  |  |  |  |  |  Branch (136:39): [True: 0, False: 2]
  |  |  |  |  |  Branch (136:39): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   54|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   55|      0|        return; \
  |  |   56|      0|    } \
  |  |   57|      2|} while(0)
  |  |  ------------------
  |  |  |  Branch (57:9): [Folded, False: 2]
  |  |  ------------------
  ------------------
  178|       |
  179|       |    /* Defined as noop */
  180|      2|    if (ctx == NULL) {
  ------------------
  |  Branch (180:9): [True: 0, False: 2]
  ------------------
  181|      0|        return;
  182|      0|    }
  183|       |
  184|      2|    secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);
  185|      2|}
secp256k1_context_destroy:
  187|      2|void secp256k1_context_destroy(secp256k1_context* ctx) {
  188|      2|    ARG_CHECK_VOID(ctx == NULL || secp256k1_context_is_proper(ctx));
  ------------------
  |  |   52|      2|#define ARG_CHECK_VOID(cond) do { \
  |  |   53|      2|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|      4|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 2]
  |  |  |  |  |  Branch (136:39): [True: 0, False: 2]
  |  |  |  |  |  Branch (136:39): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   54|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   55|      0|        return; \
  |  |   56|      0|    } \
  |  |   57|      2|} while(0)
  |  |  ------------------
  |  |  |  Branch (57:9): [Folded, False: 2]
  |  |  ------------------
  ------------------
  189|       |
  190|       |    /* Defined as noop */
  191|      2|    if (ctx == NULL) {
  ------------------
  |  Branch (191:9): [True: 0, False: 2]
  ------------------
  192|      0|        return;
  193|      0|    }
  194|       |
  195|      2|    secp256k1_context_preallocated_destroy(ctx);
  196|      2|    free(ctx);
  197|      2|}
secp256k1_ec_pubkey_serialize:
  268|  61.5k|int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *output, size_t *outputlen, const secp256k1_pubkey* pubkey, unsigned int flags) {
  269|  61.5k|    secp256k1_ge Q;
  270|  61.5k|    size_t len;
  271|  61.5k|    int ret = 0;
  272|       |
  273|  61.5k|    VERIFY_CHECK(ctx != NULL);
  274|  61.5k|    ARG_CHECK(outputlen != NULL);
  ------------------
  |  |   45|  61.5k|#define ARG_CHECK(cond) do { \
  |  |   46|  61.5k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  61.5k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 61.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  61.5k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 61.5k]
  |  |  ------------------
  ------------------
  275|  61.5k|    ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33u : 65u));
  ------------------
  |  |   45|  61.5k|#define ARG_CHECK(cond) do { \
  |  |   46|  61.5k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|   123k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 61.5k]
  |  |  |  |  |  Branch (136:39): [True: 61.5k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  61.5k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 61.5k]
  |  |  ------------------
  ------------------
  276|  61.5k|    len = *outputlen;
  277|  61.5k|    *outputlen = 0;
  278|  61.5k|    ARG_CHECK(output != NULL);
  ------------------
  |  |   45|  61.5k|#define ARG_CHECK(cond) do { \
  |  |   46|  61.5k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  61.5k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 61.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  61.5k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 61.5k]
  |  |  ------------------
  ------------------
  279|  61.5k|    memset(output, 0, len);
  280|  61.5k|    ARG_CHECK(pubkey != NULL);
  ------------------
  |  |   45|  61.5k|#define ARG_CHECK(cond) do { \
  |  |   46|  61.5k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  61.5k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 61.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  61.5k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 61.5k]
  |  |  ------------------
  ------------------
  281|  61.5k|    ARG_CHECK((flags & SECP256K1_FLAGS_TYPE_MASK) == SECP256K1_FLAGS_TYPE_COMPRESSION);
  ------------------
  |  |   45|  61.5k|#define ARG_CHECK(cond) do { \
  |  |   46|  61.5k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  61.5k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 61.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  61.5k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 61.5k]
  |  |  ------------------
  ------------------
  282|  61.5k|    if (secp256k1_pubkey_load(ctx, &Q, pubkey)) {
  ------------------
  |  Branch (282:9): [True: 61.5k, False: 0]
  ------------------
  283|  61.5k|        ret = secp256k1_eckey_pubkey_serialize(&Q, output, &len, !!(flags & SECP256K1_FLAGS_BIT_COMPRESSION));
  ------------------
  |  |  210|  61.5k|#define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)
  ------------------
  284|  61.5k|        if (ret) {
  ------------------
  |  Branch (284:13): [True: 61.5k, False: 0]
  ------------------
  285|  61.5k|            *outputlen = len;
  286|  61.5k|        }
  287|  61.5k|    }
  288|  61.5k|    return ret;
  289|  61.5k|}
secp256k1_ec_seckey_verify:
  580|  26.8k|int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char *seckey) {
  581|  26.8k|    secp256k1_scalar sec;
  582|  26.8k|    int ret;
  583|  26.8k|    VERIFY_CHECK(ctx != NULL);
  584|  26.8k|    ARG_CHECK(seckey != NULL);
  ------------------
  |  |   45|  26.8k|#define ARG_CHECK(cond) do { \
  |  |   46|  26.8k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  26.8k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 26.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  26.8k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 26.8k]
  |  |  ------------------
  ------------------
  585|       |
  586|  26.8k|    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);
  587|  26.8k|    secp256k1_scalar_clear(&sec);
  588|  26.8k|    return ret;
  589|  26.8k|}
secp256k1_ec_pubkey_create:
  604|  59.0k|int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey) {
  605|  59.0k|    secp256k1_ge p;
  606|  59.0k|    secp256k1_scalar seckey_scalar;
  607|  59.0k|    int ret = 0;
  608|  59.0k|    VERIFY_CHECK(ctx != NULL);
  609|  59.0k|    ARG_CHECK(pubkey != NULL);
  ------------------
  |  |   45|  59.0k|#define ARG_CHECK(cond) do { \
  |  |   46|  59.0k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  59.0k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 59.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  59.0k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 59.0k]
  |  |  ------------------
  ------------------
  610|  59.0k|    memset(pubkey, 0, sizeof(*pubkey));
  611|  59.0k|    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));
  ------------------
  |  |   45|  59.0k|#define ARG_CHECK(cond) do { \
  |  |   46|  59.0k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  59.0k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 59.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  59.0k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 59.0k]
  |  |  ------------------
  ------------------
  612|  59.0k|    ARG_CHECK(seckey != NULL);
  ------------------
  |  |   45|  59.0k|#define ARG_CHECK(cond) do { \
  |  |   46|  59.0k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  59.0k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 59.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  59.0k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 59.0k]
  |  |  ------------------
  ------------------
  613|       |
  614|  59.0k|    ret = secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &seckey_scalar, &p, seckey);
  615|  59.0k|    secp256k1_pubkey_save(pubkey, &p);
  616|  59.0k|    secp256k1_memczero(pubkey, sizeof(*pubkey), !ret);
  617|       |
  618|  59.0k|    secp256k1_scalar_clear(&seckey_scalar);
  619|  59.0k|    return ret;
  620|  59.0k|}
secp256k1_ec_seckey_tweak_add:
  664|  23.5k|int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak32) {
  665|  23.5k|    secp256k1_scalar sec;
  666|  23.5k|    int ret = 0;
  667|  23.5k|    VERIFY_CHECK(ctx != NULL);
  668|  23.5k|    ARG_CHECK(seckey != NULL);
  ------------------
  |  |   45|  23.5k|#define ARG_CHECK(cond) do { \
  |  |   46|  23.5k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  23.5k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 23.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  23.5k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 23.5k]
  |  |  ------------------
  ------------------
  669|  23.5k|    ARG_CHECK(tweak32 != NULL);
  ------------------
  |  |   45|  23.5k|#define ARG_CHECK(cond) do { \
  |  |   46|  23.5k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  23.5k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 23.5k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  23.5k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 23.5k]
  |  |  ------------------
  ------------------
  670|       |
  671|  23.5k|    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);
  672|  23.5k|    ret &= secp256k1_ec_seckey_tweak_add_helper(&sec, tweak32);
  673|  23.5k|    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);
  674|  23.5k|    secp256k1_scalar_get_b32(seckey, &sec);
  675|       |
  676|  23.5k|    secp256k1_scalar_clear(&sec);
  677|  23.5k|    return ret;
  678|  23.5k|}
secp256k1.c:secp256k1_context_is_proper:
   82|      4|static int secp256k1_context_is_proper(const secp256k1_context* ctx) {
   83|      4|    return secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx);
   84|      4|}
secp256k1.c:secp256k1_pubkey_save:
  246|  72.6k|static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {
  247|  72.6k|    secp256k1_ge_to_bytes(pubkey->data, ge);
  248|  72.6k|}
secp256k1.c:secp256k1_pubkey_load:
  240|  76.0k|static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {
  241|  76.0k|    secp256k1_ge_from_bytes(ge, pubkey->data);
  242|  76.0k|    ARG_CHECK(!secp256k1_fe_is_zero(&ge->x));
  ------------------
  |  |   45|  76.0k|#define ARG_CHECK(cond) do { \
  |  |   46|  76.0k|    if (EXPECT(!(cond), 0)) { \
  |  |  ------------------
  |  |  |  |  136|  76.0k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (136:21): [True: 0, False: 76.0k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   47|      0|        secp256k1_callback_call(&ctx->illegal_callback, #cond); \
  |  |   48|      0|        return 0; \
  |  |   49|      0|    } \
  |  |   50|  76.0k|} while(0)
  |  |  ------------------
  |  |  |  Branch (50:9): [Folded, False: 76.0k]
  |  |  ------------------
  ------------------
  243|  76.0k|    return 1;
  244|  76.0k|}
secp256k1.c:secp256k1_ec_pubkey_create_helper:
  591|  75.8k|static int secp256k1_ec_pubkey_create_helper(const secp256k1_ecmult_gen_context *ecmult_gen_ctx, secp256k1_scalar *seckey_scalar, secp256k1_ge *p, const unsigned char *seckey) {
  592|  75.8k|    secp256k1_gej pj;
  593|  75.8k|    int ret;
  594|       |
  595|  75.8k|    ret = secp256k1_scalar_set_b32_seckey(seckey_scalar, seckey);
  596|  75.8k|    secp256k1_scalar_cmov(seckey_scalar, &secp256k1_scalar_one, !ret);
  597|       |
  598|  75.8k|    secp256k1_ecmult_gen(ecmult_gen_ctx, &pj, seckey_scalar);
  599|  75.8k|    secp256k1_ge_set_gej(p, &pj);
  600|  75.8k|    secp256k1_gej_clear(&pj);
  601|  75.8k|    return ret;
  602|  75.8k|}
secp256k1.c:secp256k1_ec_seckey_tweak_add_helper:
  653|  23.5k|static int secp256k1_ec_seckey_tweak_add_helper(secp256k1_scalar *sec, const unsigned char *tweak32) {
  654|  23.5k|    secp256k1_scalar term;
  655|  23.5k|    int overflow = 0;
  656|  23.5k|    int ret = 0;
  657|       |
  658|  23.5k|    secp256k1_scalar_set_b32(&term, tweak32, &overflow);
  659|  23.5k|    ret = (!overflow) & secp256k1_eckey_privkey_tweak_add(sec, &term);
  660|  23.5k|    secp256k1_scalar_clear(&term);
  661|  23.5k|    return ret;
  662|  23.5k|}
secp256k1.c:secp256k1_declassify:
  236|  40.3k|static SECP256K1_INLINE void secp256k1_declassify(const secp256k1_context* ctx, const void *p, size_t len) {
  237|  40.3k|    if (EXPECT(ctx->declassify, 0)) SECP256K1_CHECKMEM_DEFINE(p, len);
  ------------------
  |  |  136|  40.3k|#define EXPECT(x,c) __builtin_expect((x),(c))
  |  |  ------------------
  |  |  |  Branch (136:21): [True: 0, False: 40.3k]
  |  |  ------------------
  ------------------
                  if (EXPECT(ctx->declassify, 0)) SECP256K1_CHECKMEM_DEFINE(p, len);
  ------------------
  |  |   91|      0|#  define SECP256K1_CHECKMEM_DEFINE(p, len) SECP256K1_CHECKMEM_NOOP((p), (len))
  |  |  ------------------
  |  |  |  |   42|      0|#define SECP256K1_CHECKMEM_NOOP(p, len) do { (void)(p); (void)(len); } while(0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (42:78): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  238|  40.3k|}

secp256k1.c:secp256k1_memcmp_var:
  255|  3.36k|static SECP256K1_INLINE int secp256k1_memcmp_var(const void *s1, const void *s2, size_t n) {
  256|  3.36k|    const unsigned char *p1 = s1, *p2 = s2;
  257|  3.36k|    size_t i;
  258|       |
  259|  47.0k|    for (i = 0; i < n; i++) {
  ------------------
  |  Branch (259:17): [True: 43.6k, False: 3.36k]
  ------------------
  260|  43.6k|        int diff = p1[i] - p2[i];
  261|  43.6k|        if (diff != 0) {
  ------------------
  |  Branch (261:13): [True: 0, False: 43.6k]
  ------------------
  262|      0|            return diff;
  263|      0|        }
  264|  43.6k|    }
  265|  3.36k|    return 0;
  266|  3.36k|}
secp256k1.c:secp256k1_read_be64:
  416|   751k|SECP256K1_INLINE static uint64_t secp256k1_read_be64(const unsigned char* p) {
  417|   751k|    return (uint64_t)p[0] << 56 |
  418|   751k|           (uint64_t)p[1] << 48 |
  419|   751k|           (uint64_t)p[2] << 40 |
  420|   751k|           (uint64_t)p[3] << 32 |
  421|   751k|           (uint64_t)p[4] << 24 |
  422|   751k|           (uint64_t)p[5] << 16 |
  423|   751k|           (uint64_t)p[6] << 8  |
  424|   751k|           (uint64_t)p[7];
  425|   751k|}
secp256k1.c:secp256k1_ctz64_var:
  382|  24.7M|static SECP256K1_INLINE int secp256k1_ctz64_var(uint64_t x) {
  383|  24.7M|    VERIFY_CHECK(x != 0);
  384|  24.7M|#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))
  385|       |    /* If the unsigned long type is sufficient to represent the largest uint64_t, consider __builtin_ctzl. */
  386|  24.7M|    if (((unsigned long)UINT64_MAX) == UINT64_MAX) {
  ------------------
  |  Branch (386:9): [True: 24.7M, Folded]
  ------------------
  387|  24.7M|        return __builtin_ctzl(x);
  388|  24.7M|    }
  389|      0|#endif
  390|      0|#if (__has_builtin(__builtin_ctzll) || SECP256K1_GNUC_PREREQ(3,4))
  391|       |    /* Otherwise consider __builtin_ctzll (the unsigned long long type is always at least 64 bits). */
  392|      0|    return __builtin_ctzll(x);
  393|       |#else
  394|       |    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */
  395|       |    return secp256k1_ctz64_var_debruijn(x);
  396|       |#endif
  397|  24.7M|}
secp256k1.c:secp256k1_rotr32:
  440|  20.4M|SECP256K1_INLINE static uint32_t secp256k1_rotr32(const uint32_t x, const unsigned int by) {
  441|       |#if defined(_MSC_VER)
  442|       |    return _rotr(x, by);  /* needs <stdlib.h> */
  443|       |#else
  444|       |    /* Reduce rotation amount to avoid UB when shifting. */
  445|  20.4M|    const unsigned int mask = CHAR_BIT * sizeof(x) - 1;
  446|       |    /* Turned into a rot instruction by GCC and clang. */
  447|  20.4M|    return (x >> (by & mask)) | (x << ((-by) & mask));
  448|  20.4M|#endif
  449|  20.4M|}
secp256k1.c:secp256k1_memczero:
  208|  79.1k|static SECP256K1_INLINE void secp256k1_memczero(void *s, size_t len, int flag) {
  209|  79.1k|    unsigned char *p = (unsigned char *)s;
  210|       |    /* Access flag with a volatile-qualified lvalue.
  211|       |       This prevents clang from figuring out (after inlining) that flag can
  212|       |       take only be 0 or 1, which leads to variable time code. */
  213|  79.1k|    volatile int vflag = flag;
  214|  79.1k|    unsigned char mask = -(unsigned char) vflag;
  215|  5.25M|    while (len) {
  ------------------
  |  Branch (215:12): [True: 5.17M, False: 79.1k]
  ------------------
  216|  5.17M|        *p &= ~mask;
  217|  5.17M|        p++;
  218|  5.17M|        len--;
  219|  5.17M|    }
  220|  79.1k|}
secp256k1.c:secp256k1_read_be32:
  400|  2.31M|SECP256K1_INLINE static uint32_t secp256k1_read_be32(const unsigned char* p) {
  401|  2.31M|    return (uint32_t)p[0] << 24 |
  402|  2.31M|           (uint32_t)p[1] << 16 |
  403|  2.31M|           (uint32_t)p[2] << 8  |
  404|  2.31M|           (uint32_t)p[3];
  405|  2.31M|}
secp256k1.c:secp256k1_write_be32:
  408|   915k|SECP256K1_INLINE static void secp256k1_write_be32(unsigned char* p, uint32_t x) {
  409|   915k|    p[3] = x;
  410|   915k|    p[2] = x >>  8;
  411|   915k|    p[1] = x >> 16;
  412|   915k|    p[0] = x >> 24;
  413|   915k|}
secp256k1.c:secp256k1_write_be64:
  428|   134k|SECP256K1_INLINE static void secp256k1_write_be64(unsigned char* p, uint64_t x) {
  429|   134k|    p[7] = x;
  430|   134k|    p[6] = x >>  8;
  431|   134k|    p[5] = x >> 16;
  432|   134k|    p[4] = x >> 24;
  433|   134k|    p[3] = x >> 32;
  434|   134k|    p[2] = x >> 40;
  435|   134k|    p[1] = x >> 48;
  436|   134k|    p[0] = x >> 56;
  437|   134k|}
secp256k1.c:secp256k1_memclear:
  223|   692k|static SECP256K1_INLINE void secp256k1_memclear(void *ptr, size_t len) {
  224|       |#if defined(_MSC_VER)
  225|       |    /* SecureZeroMemory is guaranteed not to be optimized out by MSVC. */
  226|       |    SecureZeroMemory(ptr, len);
  227|       |#elif defined(__GNUC__)
  228|       |    /* We use a memory barrier that scares the compiler away from optimizing out the memset.
  229|       |     *
  230|       |     * Quoting Adam Langley <agl@google.com> in commit ad1907fe73334d6c696c8539646c21b11178f20f
  231|       |     * in BoringSSL (ISC License):
  232|       |     *    As best as we can tell, this is sufficient to break any optimisations that
  233|       |     *    might try to eliminate "superfluous" memsets.
  234|       |     * This method is used in memzero_explicit() the Linux kernel, too. Its advantage is that it
  235|       |     * is pretty efficient, because the compiler can still implement the memset() efficiently,
  236|       |     * just not remove it entirely. See "Dead Store Elimination (Still) Considered Harmful" by
  237|       |     * Yang et al. (USENIX Security 2017) for more background.
  238|       |     */
  239|   692k|    memset(ptr, 0, len);
  240|   692k|    __asm__ __volatile__("" : : "r"(ptr) : "memory");
  241|       |#else
  242|       |    void *(*volatile const volatile_memset)(void *, int, size_t) = memset;
  243|       |    volatile_memset(ptr, 0, len);
  244|       |#endif
  245|       |#ifdef VERIFY
  246|       |    SECP256K1_CHECKMEM_UNDEFINE(ptr, len);
  247|       |#endif
  248|   692k|}

_Z9SerializeI10DataStreamEvRT_t:
  249|  11.0k|template <typename Stream> void Serialize(Stream& s, uint16_t a)  { ser_writedata16(s, a); }
_Z15ser_writedata16I10DataStreamEvRT_t:
   59|  11.0k|{
   60|  11.0k|    obj = htole16_internal(obj);
   61|  11.0k|    s.write(std::as_bytes(std::span{&obj, 1}));
   62|  11.0k|}
_Z9SerializeI10DataStreamEvRT_j:
  251|  22.1k|template <typename Stream> void Serialize(Stream& s, uint32_t a)  { ser_writedata32(s, a); }
_Z15ser_writedata32I10DataStreamEvRT_j:
   64|  22.1k|{
   65|  22.1k|    obj = htole32_internal(obj);
   66|  22.1k|    s.write(std::as_bytes(std::span{&obj, 1}));
   67|  22.1k|}
_Z9SerializeI10DataStream11XOnlyPubKeyQ12SerializableIT0_T_EEvRS3_RKS2_:
  744|  7.70k|{
  745|  7.70k|    a.Serialize(os);
  746|  7.70k|}
_ZNK11XOnlyPubKey9SerializeI10DataStreamEEvRT_:
  211|  7.70k|    {                                                                                               \
  212|  7.70k|        static_assert(std::is_same_v<const cls&, decltype(*this)>, "Serialize type mismatch");      \
  213|  7.70k|        Ser(s, *this);                                                                              \
  214|  7.70k|    }                                                                                               \
_ZN11XOnlyPubKey3SerI10DataStreamEEvRT_RKS_:
  167|  7.70k|    static void Ser(Stream& s, const cls& obj) { SerializationOps(obj, s, ActionSerialize{}); } \
_ZN15ActionSerialize16SerReadWriteManyI10DataStreamJ7uint256EEEvRT_DpRKT0_:
 1004|  7.70k|    {
 1005|  7.70k|        ::SerializeMany(s, args...);
 1006|  7.70k|    }
_Z13SerializeManyI10DataStreamJ7uint256EEvRT_DpRKT0_:
  986|  7.70k|{
  987|  7.70k|    (::Serialize(s, args), ...);
  988|  7.70k|}
_Z9SerializeI10DataStream7uint256Q12SerializableIT0_T_EEvRS3_RKS2_:
  744|  7.70k|{
  745|  7.70k|    a.Serialize(os);
  746|  7.70k|}
_Z9SerializeI10DataStreamTk9BasicByteKhLm32EEvRT_NSt3__14spanIT0_XT1_EEE:
  257|  7.70k|template <typename Stream, BasicByte B, size_t N> void Serialize(Stream& s, std::span<B, N> span)      { s.write(std::as_bytes(span)); }
_Z9SerializeI10HashWriterTk9BasicByteKSt4byteEvRT_NSt3__14spanIT0_Lm18446744073709551615EEE:
  258|  32.0k|template <typename Stream, BasicByte B>           void Serialize(Stream& s, std::span<B> span)         { s.write(std::as_bytes(span)); }
_Z9SerializeI10DataStream24Sv2SignatureNoiseMessageQ12SerializableIT0_T_EEvRS3_RKS2_:
  744|  3.36k|{
  745|  3.36k|    a.Serialize(os);
  746|  3.36k|}
_Z9SerializeI10DataStreamTk9BasicBytehLm64EEvRT_RKNSt3__15arrayIT0_XT1_EEE:
  256|  3.36k|template <typename Stream, BasicByte B, size_t N> void Serialize(Stream& s, const std::array<B, N>& a) { s.write(MakeByteSpan(a)); }
_Z11UnserializeI10DataStreamR24Sv2SignatureNoiseMessageQ14UnserializableIT0_T_EEvRS4_OS3_:
  753|  2.56k|{
  754|  2.56k|    a.Unserialize(is);
  755|  2.56k|}
_Z11UnserializeI10DataStreamEvRT_Rt:
  265|  2.56k|template <typename Stream> void Unserialize(Stream& s, uint16_t& a)  { a = ser_readdata16(s); }
_Z14ser_readdata16I10DataStreamEtRT_:
   85|  2.56k|{
   86|  2.56k|    uint16_t obj;
   87|  2.56k|    s.read(std::as_writable_bytes(std::span{&obj, 1}));
   88|  2.56k|    return le16toh_internal(obj);
   89|  2.56k|}
_Z11UnserializeI10DataStreamEvRT_Rj:
  267|  5.12k|template <typename Stream> void Unserialize(Stream& s, uint32_t& a)  { a = ser_readdata32(s); }
_Z14ser_readdata32I10DataStreamEjRT_:
   91|  5.12k|{
   92|  5.12k|    uint32_t obj;
   93|  5.12k|    s.read(std::as_writable_bytes(std::span{&obj, 1}));
   94|  5.12k|    return le32toh_internal(obj);
   95|  5.12k|}
_Z11UnserializeI10DataStreamTk9BasicBytehLm64EEvRT_RNSt3__15arrayIT0_XT1_EEE:
  272|  2.56k|template <typename Stream, BasicByte B, size_t N> void Unserialize(Stream& s, std::array<B, N>& a)  { s.read(MakeWritableByteSpan(a)); }
_Z9SerializeI10HashWriter7uint256Q12SerializableIT0_T_EEvRS3_RKS2_:
  744|  32.0k|{
  745|  32.0k|    a.Serialize(os);
  746|  32.0k|}
_Z9SerializeI10HashWriterTk9BasicByteKhLm32EEvRT_NSt3__14spanIT0_XT1_EEE:
  257|  32.0k|template <typename Stream, BasicByte B, size_t N> void Serialize(Stream& s, std::span<B, N> span)      { s.write(std::as_bytes(span)); }

_Z12MakeByteSpanI7uint256EDaRKT_:
   85|  29.4k|{
   86|  29.4k|    return std::as_bytes(std::span{v});
   87|  29.4k|}
_Z13MakeUCharSpanINSt3__14spanIKSt4byteLm18446744073709551615EEEEDTcl13UCharSpanCasttlS1_fp_EEERKT_:
  111|  1.48k|template <typename V> constexpr auto MakeUCharSpan(const V& v) -> decltype(UCharSpanCast(std::span{v})) { return UCharSpanCast(std::span{v}); }
_Z13UCharSpanCastIKSt4byteLm18446744073709551615EEDaNSt3__14spanIT_XT0_EEE:
  108|  1.48k|template <typename T, size_t N> constexpr auto UCharSpanCast(std::span<T, N> s) { return std::span<std::remove_pointer_t<decltype(UCharCast(s.data()))>, N>{UCharCast(s.data()), s.size()}; }
_Z12MakeByteSpanINSt3__15arrayIhLm32EEEEDaRKT_:
   85|  83.7k|{
   86|  83.7k|    return std::as_bytes(std::span{v});
   87|  83.7k|}
_Z12MakeByteSpanINSt3__15arrayIhLm64EEEEDaRKT_:
   85|  3.36k|{
   86|  3.36k|    return std::as_bytes(std::span{v});
   87|  3.36k|}
_Z20MakeWritableByteSpanIRNSt3__15arrayIhLm64EEEEDaOT_:
   90|  2.56k|{
   91|  2.56k|    return std::as_writable_bytes(std::span{std::forward<V>(v)});
   92|  2.56k|}
_Z13UCharSpanCastIKhLm18446744073709551615EEDaNSt3__14spanIT_XT0_EEE:
  108|  23.5k|template <typename T, size_t N> constexpr auto UCharSpanCast(std::span<T, N> s) { return std::span<std::remove_pointer_t<decltype(UCharCast(s.data()))>, N>{UCharCast(s.data()), s.size()}; }
_Z13MakeUCharSpanINSt3__14spanIKhLm18446744073709551615EEEEDTcl13UCharSpanCasttlS1_fp_EEERKT_:
  111|  23.5k|template <typename V> constexpr auto MakeUCharSpan(const V& v) -> decltype(UCharSpanCast(std::span{v})) { return UCharSpanCast(std::span{v}); }
_Z9UCharCastPh:
   96|  3.36k|inline unsigned char* UCharCast(unsigned char* c) { return c; }
_Z9UCharCastPKh:
  100|  23.5k|inline const unsigned char* UCharCast(const unsigned char* c) { return c; }
_Z9UCharCastPSt4byte:
   98|   151k|inline unsigned char* UCharCast(std::byte* c) { return reinterpret_cast<unsigned char*>(c); }
_Z9UCharCastPKSt4byte:
  102|   755k|inline const unsigned char* UCharCast(const std::byte* c) { return reinterpret_cast<const unsigned char*>(c); }

_ZN10DataStreamC2ENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  149|  2.56k|    explicit DataStream(std::span<const value_type> sp) : vch(sp.data(), sp.data() + sp.size()) {}
_ZN10DataStream5beginEv:
  161|  15.4k|    iterator begin()                                 { return vch.begin() + m_read_pos; }
_ZN10DataStream3endEv:
  163|  7.70k|    iterator end()                                   { return vch.end(); }
_ZNK10DataStream4sizeEv:
  164|  6.72k|    size_type size() const                           { return vch.size() - m_read_pos; }
_ZN10DataStream4dataEv:
  171|  3.36k|    value_type* data()                               { return vch.data() + m_read_pos; }
_ZN10DataStream4readENSt3__14spanISt4byteLm18446744073709551615EEE:
  202|  10.2k|    {
  203|  10.2k|        if (dst.size() == 0) return;
  ------------------
  |  Branch (203:13): [True: 0, False: 10.2k]
  ------------------
  204|       |
  205|       |        // Read from the beginning of the buffer
  206|  10.2k|        auto next_read_pos{CheckedAdd(m_read_pos, dst.size())};
  207|  10.2k|        if (!next_read_pos.has_value() || next_read_pos.value() > vch.size()) {
  ------------------
  |  Branch (207:13): [True: 0, False: 10.2k]
  |  Branch (207:43): [True: 0, False: 10.2k]
  ------------------
  208|      0|            throw std::ios_base::failure("DataStream::read(): end of data");
  209|      0|        }
  210|  10.2k|        memcpy(dst.data(), &vch[m_read_pos], dst.size());
  211|  10.2k|        if (next_read_pos.value() == vch.size()) {
  ------------------
  |  Branch (211:13): [True: 2.56k, False: 7.68k]
  ------------------
  212|  2.56k|            m_read_pos = 0;
  213|  2.56k|            vch.clear();
  214|  2.56k|            return;
  215|  2.56k|        }
  216|  7.68k|        m_read_pos = next_read_pos.value();
  217|  7.68k|    }
_ZN10DataStream5writeENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  235|  44.2k|    {
  236|       |        // Write to the end of the buffer
  237|  44.2k|        vch.insert(vch.end(), src.begin(), src.end());
  238|  44.2k|    }
_ZN10DataStreamC2Ev:
  147|  11.0k|    explicit DataStream() = default;
_ZN10DataStreamlsItEERS_RKT_:
  242|  11.0k|    {
  243|  11.0k|        ::Serialize(*this, obj);
  244|  11.0k|        return (*this);
  245|  11.0k|    }
_ZN10DataStreamlsIjEERS_RKT_:
  242|  22.1k|    {
  243|  22.1k|        ::Serialize(*this, obj);
  244|  22.1k|        return (*this);
  245|  22.1k|    }
_ZN10DataStreamlsI11XOnlyPubKeyEERS_RKT_:
  242|  7.70k|    {
  243|  7.70k|        ::Serialize(*this, obj);
  244|  7.70k|        return (*this);
  245|  7.70k|    }
_ZN10DataStreamlsINSt3__14spanIKhLm32EEEEERS_RKT_:
  242|  7.70k|    {
  243|  7.70k|        ::Serialize(*this, obj);
  244|  7.70k|        return (*this);
  245|  7.70k|    }
_ZN10DataStreamlsI24Sv2SignatureNoiseMessageEERS_RKT_:
  242|  3.36k|    {
  243|  3.36k|        ::Serialize(*this, obj);
  244|  3.36k|        return (*this);
  245|  3.36k|    }
_ZN10DataStreamlsINSt3__15arrayIhLm64EEEEERS_RKT_:
  242|  3.36k|    {
  243|  3.36k|        ::Serialize(*this, obj);
  244|  3.36k|        return (*this);
  245|  3.36k|    }
_ZN10DataStreamrsIR24Sv2SignatureNoiseMessageEERS_OT_:
  249|  2.56k|    {
  250|  2.56k|        ::Unserialize(*this, obj);
  251|  2.56k|        return (*this);
  252|  2.56k|    }
_ZN10DataStreamrsIRtEERS_OT_:
  249|  2.56k|    {
  250|  2.56k|        ::Unserialize(*this, obj);
  251|  2.56k|        return (*this);
  252|  2.56k|    }
_ZN10DataStreamrsIRjEERS_OT_:
  249|  5.12k|    {
  250|  5.12k|        ::Unserialize(*this, obj);
  251|  5.12k|        return (*this);
  252|  5.12k|    }
_ZN10DataStreamrsIRNSt3__15arrayIhLm64EEEEERS_OT_:
  249|  2.56k|    {
  250|  2.56k|        ::Unserialize(*this, obj);
  251|  2.56k|        return (*this);
  252|  2.56k|    }

_Z18make_secure_uniqueINSt3__15arrayIhLm32EEEJEENS0_10unique_ptrIT_19SecureUniqueDeleterIS4_EEEDpOT0_:
   72|  43.6k|{
   73|  43.6k|    T* p = secure_allocator<T>().allocate(1);
   74|       |
   75|       |    // initialize in place, and return as secure_unique_ptr
   76|  43.6k|    try {
   77|  43.6k|        return secure_unique_ptr<T>(new (p) T(std::forward<Args>(as)...));
   78|  43.6k|    } catch (...) {
   79|      0|        secure_allocator<T>().deallocate(p, 1);
   80|      0|        throw;
   81|      0|    }
   82|  43.6k|}
_ZN16secure_allocatorINSt3__15arrayIhLm32EEEE8allocateEm:
   28|  43.6k|    {
   29|  43.6k|        T* allocation = static_cast<T*>(LockedPoolManager::Instance().alloc(sizeof(T) * n));
   30|  43.6k|        if (!allocation) {
  ------------------
  |  Branch (30:13): [True: 0, False: 43.6k]
  ------------------
   31|      0|            throw std::bad_alloc();
   32|      0|        }
   33|  43.6k|        return allocation;
   34|  43.6k|    }
_ZN16secure_allocatorINSt3__15arrayIhLm32EEEE10deallocateEPS2_m:
   37|  43.6k|    {
   38|  43.6k|        if (p != nullptr) {
  ------------------
  |  Branch (38:13): [True: 43.6k, False: 0]
  ------------------
   39|  43.6k|            memory_cleanse(p, sizeof(T) * n);
   40|  43.6k|        }
   41|  43.6k|        LockedPoolManager::Instance().free(p);
   42|  43.6k|    }
_ZN19SecureUniqueDeleterINSt3__15arrayIhLm32EEEEclEPS2_:
   62|  43.6k|    void operator()(T* t) noexcept {
   63|  43.6k|        secure_allocator<T>().deallocate(t, 1);
   64|  43.6k|    }
_Z18make_secure_uniqueINSt3__15arrayIhLm96EEEJEENS0_10unique_ptrIT_19SecureUniqueDeleterIS4_EEEDpOT0_:
   72|  3.36k|{
   73|  3.36k|    T* p = secure_allocator<T>().allocate(1);
   74|       |
   75|       |    // initialize in place, and return as secure_unique_ptr
   76|  3.36k|    try {
   77|  3.36k|        return secure_unique_ptr<T>(new (p) T(std::forward<Args>(as)...));
   78|  3.36k|    } catch (...) {
   79|      0|        secure_allocator<T>().deallocate(p, 1);
   80|      0|        throw;
   81|      0|    }
   82|  3.36k|}
_ZN16secure_allocatorINSt3__15arrayIhLm96EEEE8allocateEm:
   28|  3.36k|    {
   29|  3.36k|        T* allocation = static_cast<T*>(LockedPoolManager::Instance().alloc(sizeof(T) * n));
   30|  3.36k|        if (!allocation) {
  ------------------
  |  Branch (30:13): [True: 0, False: 3.36k]
  ------------------
   31|      0|            throw std::bad_alloc();
   32|      0|        }
   33|  3.36k|        return allocation;
   34|  3.36k|    }
_ZN16secure_allocatorINSt3__15arrayIhLm96EEEE10deallocateEPS2_m:
   37|  3.36k|    {
   38|  3.36k|        if (p != nullptr) {
  ------------------
  |  Branch (38:13): [True: 3.36k, False: 0]
  ------------------
   39|  3.36k|            memory_cleanse(p, sizeof(T) * n);
   40|  3.36k|        }
   41|  3.36k|        LockedPoolManager::Instance().free(p);
   42|  3.36k|    }
_ZN19SecureUniqueDeleterINSt3__15arrayIhLm96EEEEclEPS2_:
   62|  3.36k|    void operator()(T* t) noexcept {
   63|  3.36k|        secure_allocator<T>().deallocate(t, 1);
   64|  3.36k|    }
_ZN16secure_allocatorIhE8allocateEm:
   28|  26.8k|    {
   29|  26.8k|        T* allocation = static_cast<T*>(LockedPoolManager::Instance().alloc(sizeof(T) * n));
   30|  26.8k|        if (!allocation) {
  ------------------
  |  Branch (30:13): [True: 0, False: 26.8k]
  ------------------
   31|      0|            throw std::bad_alloc();
   32|      0|        }
   33|  26.8k|        return allocation;
   34|  26.8k|    }
_ZN16secure_allocatorIhE10deallocateEPhm:
   37|  26.8k|    {
   38|  26.8k|        if (p != nullptr) {
  ------------------
  |  Branch (38:13): [True: 26.8k, False: 0]
  ------------------
   39|  26.8k|            memory_cleanse(p, sizeof(T) * n);
   40|  26.8k|        }
   41|  26.8k|        LockedPoolManager::Instance().free(p);
   42|  26.8k|    }
random.cpp:_ZN16secure_allocatorIN12_GLOBAL__N_18RNGStateEE10deallocateEPS1_m:
   37|      2|    {
   38|      2|        if (p != nullptr) {
  ------------------
  |  Branch (38:13): [True: 2, False: 0]
  ------------------
   39|      2|            memory_cleanse(p, sizeof(T) * n);
   40|      2|        }
   41|      2|        LockedPoolManager::Instance().free(p);
   42|      2|    }

_ZN25zero_after_free_allocatorISt4byteE10deallocateEPS0_m:
   30|  46.8k|    {
   31|  46.8k|        if (p != nullptr)
  ------------------
  |  Branch (31:13): [True: 46.8k, False: 0]
  ------------------
   32|  46.8k|            memory_cleanse(p, sizeof(T) * n);
   33|  46.8k|        std::allocator<T>{}.deallocate(p, n);
   34|  46.8k|    }
_ZN25zero_after_free_allocatorISt4byteE8allocateEm:
   25|  46.8k|    {
   26|  46.8k|        return std::allocator<T>{}.allocate(n);
   27|  46.8k|    }

_Z14memory_cleansePvm:
   15|   308k|{
   16|       |#if defined(WIN32)
   17|       |    /* SecureZeroMemory is guaranteed not to be optimized out. */
   18|       |    SecureZeroMemory(ptr, len);
   19|       |#else
   20|   308k|    std::memset(ptr, 0, len);
   21|       |
   22|       |    /* Memory barrier that scares the compiler away from optimizing out the memset.
   23|       |     *
   24|       |     * Quoting Adam Langley <agl@google.com> in commit ad1907fe73334d6c696c8539646c21b11178f20f
   25|       |     * in BoringSSL (ISC License):
   26|       |     *    As best as we can tell, this is sufficient to break any optimisations that
   27|       |     *    might try to eliminate "superfluous" memsets.
   28|       |     * This method is used in memzero_explicit() the Linux kernel, too. Its advantage is that it
   29|       |     * is pretty efficient because the compiler can still implement the memset() efficiently,
   30|       |     * just not remove it entirely. See "Dead Store Elimination (Still) Considered Harmful" by
   31|       |     * Yang et al. (USENIX Security 2017) for more background.
   32|       |     */
   33|   308k|    __asm__ __volatile__("" : : "r"(ptr) : "memory");
   34|   308k|#endif
   35|   308k|}

_ZN5ArenaD2Ev:
   48|      2|Arena::~Arena() = default;
_ZN5Arena5allocEm:
   51|  73.9k|{
   52|       |    // Round to next multiple of alignment
   53|  73.9k|    size = align_up(size, alignment);
   54|       |
   55|       |    // Don't handle zero-sized chunks
   56|  73.9k|    if (size == 0)
  ------------------
  |  Branch (56:9): [True: 0, False: 73.9k]
  ------------------
   57|      0|        return nullptr;
   58|       |
   59|       |    // Pick a large enough free-chunk. Returns an iterator pointing to the first element that is not less than key.
   60|       |    // This allocation strategy is best-fit. According to "Dynamic Storage Allocation: A Survey and Critical Review",
   61|       |    // Wilson et. al. 1995, https://www.scs.stanford.edu/14wi-cs140/sched/readings/wilson.pdf, best-fit and first-fit
   62|       |    // policies seem to work well in practice.
   63|  73.9k|    auto size_ptr_it = size_to_free_chunk.lower_bound(size);
   64|  73.9k|    if (size_ptr_it == size_to_free_chunk.end())
  ------------------
  |  Branch (64:9): [True: 0, False: 73.9k]
  ------------------
   65|      0|        return nullptr;
   66|       |
   67|       |    // Create the used-chunk, taking its space from the end of the free-chunk
   68|  73.9k|    const size_t size_remaining = size_ptr_it->first - size;
   69|  73.9k|    char* const free_chunk = static_cast<char*>(size_ptr_it->second);
   70|  73.9k|    auto allocated = chunks_used.emplace(free_chunk + size_remaining, size).first;
   71|  73.9k|    chunks_free_end.erase(free_chunk + size_ptr_it->first);
   72|  73.9k|    if (size_ptr_it->first == size) {
  ------------------
  |  Branch (72:9): [True: 6.72k, False: 67.2k]
  ------------------
   73|       |        // whole chunk is used up
   74|  6.72k|        chunks_free.erase(size_ptr_it->second);
   75|  67.2k|    } else {
   76|       |        // still some memory left in the chunk
   77|  67.2k|        auto it_remaining = size_to_free_chunk.emplace(size_remaining, size_ptr_it->second);
   78|  67.2k|        chunks_free[size_ptr_it->second] = it_remaining;
   79|  67.2k|        chunks_free_end.emplace(free_chunk + size_remaining, it_remaining);
   80|  67.2k|    }
   81|  73.9k|    size_to_free_chunk.erase(size_ptr_it);
   82|       |
   83|  73.9k|    return allocated->first;
   84|  73.9k|}
_ZN5Arena4freeEPv:
   87|  73.9k|{
   88|       |    // Freeing the nullptr pointer is OK.
   89|  73.9k|    if (ptr == nullptr) {
  ------------------
  |  Branch (89:9): [True: 0, False: 73.9k]
  ------------------
   90|      0|        return;
   91|      0|    }
   92|       |
   93|       |    // Remove chunk from used map
   94|  73.9k|    auto i = chunks_used.find(ptr);
   95|  73.9k|    if (i == chunks_used.end()) {
  ------------------
  |  Branch (95:9): [True: 0, False: 73.9k]
  ------------------
   96|      0|        throw std::runtime_error("Arena: invalid or double free");
   97|      0|    }
   98|  73.9k|    auto freed = std::make_pair(static_cast<char*>(i->first), i->second);
   99|  73.9k|    chunks_used.erase(i);
  100|       |
  101|       |    // coalesce freed with previous chunk
  102|  73.9k|    auto prev = chunks_free_end.find(freed.first);
  103|  73.9k|    if (prev != chunks_free_end.end()) {
  ------------------
  |  Branch (103:9): [True: 62.7k, False: 11.1k]
  ------------------
  104|  62.7k|        freed.first -= prev->second->first;
  105|  62.7k|        freed.second += prev->second->first;
  106|  62.7k|        size_to_free_chunk.erase(prev->second);
  107|  62.7k|        chunks_free_end.erase(prev);
  108|  62.7k|    }
  109|       |
  110|       |    // coalesce freed with chunk after freed
  111|  73.9k|    auto next = chunks_free.find(freed.first + freed.second);
  112|  73.9k|    if (next != chunks_free.end()) {
  ------------------
  |  Branch (112:9): [True: 4.43k, False: 69.4k]
  ------------------
  113|  4.43k|        freed.second += next->second->first;
  114|  4.43k|        size_to_free_chunk.erase(next->second);
  115|  4.43k|        chunks_free.erase(next);
  116|  4.43k|    }
  117|       |
  118|       |    // Add/set space with coalesced free chunk
  119|  73.9k|    auto it = size_to_free_chunk.emplace(freed.second, freed.first);
  120|  73.9k|    chunks_free[freed.first] = it;
  121|  73.9k|    chunks_free_end[freed.first + freed.second] = it;
  122|  73.9k|}
_ZN24PosixLockedPageAllocator10FreeLockedEPvm:
  254|      2|{
  255|      2|    len = align_up(len, page_size);
  256|      2|    memory_cleanse(addr, len);
  257|      2|    munlock(addr, len);
  258|      2|    munmap(addr, len);
  259|      2|}
_ZN10LockedPoolD2Ev:
  282|      2|LockedPool::~LockedPool() = default;
_ZN10LockedPool5allocEm:
  285|  73.9k|{
  286|  73.9k|    std::lock_guard<std::mutex> lock(mutex);
  287|       |
  288|       |    // Don't handle impossible sizes
  289|  73.9k|    if (size == 0 || size > ARENA_SIZE)
  ------------------
  |  Branch (289:9): [True: 0, False: 73.9k]
  |  Branch (289:22): [True: 0, False: 73.9k]
  ------------------
  290|      0|        return nullptr;
  291|       |
  292|       |    // Try allocating from each current arena
  293|  73.9k|    for (auto &arena: arenas) {
  ------------------
  |  Branch (293:21): [True: 73.9k, False: 0]
  ------------------
  294|  73.9k|        void *addr = arena.alloc(size);
  295|  73.9k|        if (addr) {
  ------------------
  |  Branch (295:13): [True: 73.9k, False: 0]
  ------------------
  296|  73.9k|            return addr;
  297|  73.9k|        }
  298|  73.9k|    }
  299|       |    // If that fails, create a new one
  300|      0|    if (new_arena(ARENA_SIZE, ARENA_ALIGN)) {
  ------------------
  |  Branch (300:9): [True: 0, False: 0]
  ------------------
  301|      0|        return arenas.back().alloc(size);
  302|      0|    }
  303|      0|    return nullptr;
  304|      0|}
_ZN10LockedPool4freeEPv:
  307|  73.9k|{
  308|  73.9k|    std::lock_guard<std::mutex> lock(mutex);
  309|       |    // TODO we can do better than this linear search by keeping a map of arena
  310|       |    // extents to arena, and looking up the address.
  311|  73.9k|    for (auto &arena: arenas) {
  ------------------
  |  Branch (311:21): [True: 73.9k, False: 0]
  ------------------
  312|  73.9k|        if (arena.addressInArena(ptr)) {
  ------------------
  |  Branch (312:13): [True: 73.9k, False: 0]
  ------------------
  313|  73.9k|            arena.free(ptr);
  314|  73.9k|            return;
  315|  73.9k|        }
  316|  73.9k|    }
  317|      0|    throw std::runtime_error("LockedPool: invalid address not pointing to any arena");
  318|  73.9k|}
_ZN10LockedPool15LockedPageArenaD2Ev:
  369|      2|{
  370|      2|    allocator->FreeLocked(base, size);
  371|      2|}
lockedpool.cpp:_ZL8align_upmm:
   32|  73.9k|{
   33|  73.9k|    return (x + align - 1) & ~(align - 1);
   34|  73.9k|}

_ZN17LockedPoolManager8InstanceEv:
  223|   147k|    {
  224|   147k|        static std::once_flag init_flag;
  225|   147k|        std::call_once(init_flag, LockedPoolManager::CreateInstance);
  226|   147k|        return *LockedPoolManager::_instance;
  227|   147k|    }
_ZNK5Arena14addressInArenaEPv:
   90|  73.9k|    bool addressInArena(void *ptr) const { return ptr >= base && ptr < end; }
  ------------------
  |  Branch (90:51): [True: 73.9k, False: 0]
  |  Branch (90:66): [True: 73.9k, False: 0]
  ------------------
_ZN19LockedPageAllocatorD2Ev:
   22|      2|    virtual ~LockedPageAllocator() = default;

_ZN24Sv2SignatureNoiseMessageC2EtjjRK11XOnlyPubKeyRK4CKey:
   14|  3.36k|Sv2SignatureNoiseMessage::Sv2SignatureNoiseMessage(uint16_t version, uint32_t valid_from, uint32_t valid_to, const XOnlyPubKey& static_key, const CKey& authority_key) : m_version{version}, m_valid_from{valid_from}, m_valid_to{valid_to}, m_static_key{static_key}
   15|  3.36k|{
   16|  3.36k|    SignSchnorr(authority_key, m_sig);
   17|  3.36k|}
_ZN24Sv2SignatureNoiseMessage7GetHashEv:
   20|  7.70k|{
   21|  7.70k|    DataStream ss{};
   22|  7.70k|    ss << m_version
   23|  7.70k|       << m_valid_from
   24|  7.70k|       << m_valid_to
   25|  7.70k|       << m_static_key;
   26|       |
   27|  7.70k|    LogTrace(BCLog::SV2, "Certificate hashed data: %s\n", HexStr(ss));
  ------------------
  |  |  264|  7.70k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  7.70k|    do {                                                              \
  |  |  |  |  257|  7.70k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 7.70k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  7.70k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 7.70k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   28|       |
   29|  7.70k|    CSHA256 hasher;
   30|  7.70k|    hasher.Write(reinterpret_cast<unsigned char*>(&(*ss.begin())), ss.end() - ss.begin());
   31|       |
   32|  7.70k|    uint256 hash_output;
   33|  7.70k|    hasher.Finalize(hash_output.begin());
   34|  7.70k|    return hash_output;
   35|  7.70k|}
_ZN24Sv2SignatureNoiseMessage8ValidateE11XOnlyPubKey:
   38|  7.82k|{
   39|  7.82k|    if (m_version > 0) {
  ------------------
  |  Branch (39:9): [True: 627, False: 7.19k]
  ------------------
   40|    627|        LogTrace(BCLog::SV2, "Invalid certificate version: %d\n", m_version);
  ------------------
  |  |  264|    627|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|    627|    do {                                                              \
  |  |  |  |  257|    627|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 627]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|    627|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 627]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   41|    627|        return false;
   42|    627|    }
   43|  7.19k|    auto now{GetTime<std::chrono::seconds>()};
   44|  7.19k|    if (std::chrono::seconds{m_valid_from} > now) {
  ------------------
  |  Branch (44:9): [True: 331, False: 6.86k]
  ------------------
   45|    331|        LogTrace(BCLog::SV2, "Certificate valid from is in the future: %d\n", m_valid_from);
  ------------------
  |  |  264|    331|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|    331|    do {                                                              \
  |  |  |  |  257|    331|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 331]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|    331|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 331]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   46|    331|        return false;
   47|    331|    }
   48|  6.86k|    if (std::chrono::seconds{m_valid_to} < now) {
  ------------------
  |  Branch (48:9): [True: 2.51k, False: 4.34k]
  ------------------
   49|  2.51k|        LogTrace(BCLog::SV2, "Certificate expired: %d\n", m_valid_to);
  ------------------
  |  |  264|  2.51k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.51k|    do {                                                              \
  |  |  |  |  257|  2.51k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.51k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.51k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.51k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   50|  2.51k|        return false;
   51|  2.51k|    }
   52|       |
   53|  4.34k|    if (!authority_key.VerifySchnorr(this->GetHash(), m_sig)) {
  ------------------
  |  Branch (53:9): [True: 1.67k, False: 2.67k]
  ------------------
   54|  1.67k|        LogTrace(BCLog::SV2, "Certificate signature is invalid\n");
  ------------------
  |  |  264|  1.67k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  1.67k|    do {                                                              \
  |  |  |  |  257|  1.67k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 1.67k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  1.67k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 1.67k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   55|  1.67k|        return false;
   56|  1.67k|    }
   57|  2.67k|    return true;
   58|  4.34k|}
_ZN24Sv2SignatureNoiseMessage11SignSchnorrERK4CKeyNSt3__14spanIhLm18446744073709551615EEE:
   61|  3.36k|{
   62|  3.36k|    authority_key.SignSchnorr(this->GetHash(), sig, nullptr, {});
   63|  3.36k|}
_ZN14Sv2CipherStateC2EONSt3__15arrayIhLm32EEE:
   65|  16.9k|Sv2CipherState::Sv2CipherState(NoiseHash&& key) : m_key(std::move(key)) {};
_ZN14Sv2CipherState13DecryptWithAdENSt3__14spanIKSt4byteLm18446744073709551615EEENS1_IS2_Lm18446744073709551615EEES5_:
   68|  41.4k|{
   69|  41.4k|    Assume(Sv2Cipher::EncryptedMessageSize(plain.size()) == ciphertext.size());
  ------------------
  |  |  118|  41.4k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
   70|       |
   71|  41.4k|    if (m_nonce == UINT64_MAX) {
  ------------------
  |  Branch (71:9): [True: 0, False: 41.4k]
  ------------------
   72|       |        // This nonce value is reserved, see chapter 5.1 of the Noise paper.
   73|      0|        LogTrace(BCLog::SV2, "Nonce exceeds maximum value\n");
  ------------------
  |  |  264|      0|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|      0|    do {                                                              \
  |  |  |  |  257|      0|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   74|      0|        return false;
   75|      0|    }
   76|  41.4k|    AEADChaCha20Poly1305::Nonce96 nonce = {0, m_nonce};
   77|  41.4k|    auto key = MakeByteSpan(m_key);
   78|  41.4k|    AEADChaCha20Poly1305 aead{key};
   79|  41.4k|    if (!aead.Decrypt(ciphertext, associated_data, nonce, plain)) {
  ------------------
  |  Branch (79:9): [True: 1.32k, False: 40.1k]
  ------------------
   80|  1.32k|        LogTrace(BCLog::SV2, "Message decryption failed\n");
  ------------------
  |  |  264|  1.32k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  1.32k|    do {                                                              \
  |  |  |  |  257|  1.32k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 1.32k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  1.32k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 1.32k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   81|  1.32k|        return false;
   82|  1.32k|    }
   83|       |    // Only increase nonce if decryption succeeded
   84|  40.1k|    m_nonce++;
   85|  40.1k|    return true;
   86|  41.4k|}
_ZN14Sv2CipherState13EncryptWithAdENSt3__14spanIKSt4byteLm18446744073709551615EEES4_NS1_IS2_Lm18446744073709551615EEE:
   89|  42.2k|{
   90|  42.2k|    Assume(Sv2Cipher::EncryptedMessageSize(plain.size()) == ciphertext.size());
  ------------------
  |  |  118|  42.2k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
   91|       |
   92|  42.2k|    if (m_nonce == UINT64_MAX) {
  ------------------
  |  Branch (92:9): [True: 0, False: 42.2k]
  ------------------
   93|       |        // This nonce value is reserved, see chapter 5.1 of the Noise paper.
   94|      0|        LogTrace(BCLog::SV2, "Nonce exceeds maximum value\n");
  ------------------
  |  |  264|      0|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|      0|    do {                                                              \
  |  |  |  |  257|      0|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|      0|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   95|      0|        return false;
   96|      0|    }
   97|  42.2k|    AEADChaCha20Poly1305::Nonce96 nonce = {0, m_nonce++};
   98|  42.2k|    auto key = MakeByteSpan(m_key);
   99|  42.2k|    AEADChaCha20Poly1305 aead{key};
  100|  42.2k|    aead.Encrypt(plain, associated_data, nonce, ciphertext);
  101|  42.2k|    return true;
  102|  42.2k|}
_ZN14Sv2CipherState14EncryptMessageENSt3__14spanIKSt4byteLm18446744073709551615EEENS1_IS2_Lm18446744073709551615EEE:
  105|  41.0k|{
  106|  41.0k|    Assume(ciphertext.size() == Sv2Cipher::EncryptedMessageSize(plain.size()));
  ------------------
  |  |  118|  41.0k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  107|       |
  108|  41.0k|    std::vector<std::byte> ad; // No associated data
  109|       |
  110|  41.0k|    constexpr size_t max_chunk_size = NOISE_MAX_CHUNK_SIZE - Poly1305::TAGLEN;
  111|  41.0k|    size_t num_chunks = (plain.size() + max_chunk_size - 1) / max_chunk_size;
  112|  41.0k|    if (num_chunks > 1) {
  ------------------
  |  Branch (112:9): [True: 4.31k, False: 36.7k]
  ------------------
  113|  4.31k|        LogTrace(BCLog::SV2,
  ------------------
  |  |  264|  4.31k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  4.31k|    do {                                                              \
  |  |  |  |  257|  4.31k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 4.31k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  4.31k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 4.31k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  114|  4.31k|                 "Split into %d chunks (max %d bytes)\n",
  115|  4.31k|                 num_chunks, max_chunk_size);
  116|  4.31k|    }
  117|       |
  118|       |    // Copy input bytes into output buffer
  119|  41.0k|    const std::vector<std::byte> padding(Poly1305::TAGLEN, std::byte(0));
  120|  76.6k|    for (size_t i = 0; i < num_chunks; ++i) {
  ------------------
  |  Branch (120:24): [True: 35.5k, False: 41.0k]
  ------------------
  121|  35.5k|        size_t chunk_start = i * max_chunk_size;
  122|  35.5k|        size_t chunk_end = std::min(chunk_start + max_chunk_size, plain.size());
  123|  35.5k|        size_t chunk_size = chunk_end - chunk_start;
  124|  35.5k|        const auto encrypted_chunk_start = ciphertext.begin() + i * NOISE_MAX_CHUNK_SIZE;
  125|  35.5k|        std::copy(plain.begin() + chunk_start, plain.begin() + chunk_start + chunk_size, encrypted_chunk_start);
  126|  35.5k|        std::copy(padding.begin(), padding.end(), encrypted_chunk_start + chunk_size);
  127|  35.5k|    }
  128|       |
  129|       |    // Encrypt each chunk
  130|  41.0k|    size_t bytes_written = 0;
  131|  76.6k|    for (size_t i = 0; i < num_chunks; ++i) {
  ------------------
  |  Branch (131:24): [True: 35.5k, False: 41.0k]
  ------------------
  132|  35.5k|        size_t chunk_size = std::min(ciphertext.size() - bytes_written, NOISE_MAX_CHUNK_SIZE);
  133|  35.5k|        std::span<std::byte> chunk = ciphertext.subspan(bytes_written, chunk_size);
  134|  35.5k|        std::span<std::byte> chunk_plain = ciphertext.subspan(bytes_written, chunk_size - Poly1305::TAGLEN);
  135|  35.5k|        if (!EncryptWithAd(ad, chunk_plain, chunk)) {
  ------------------
  |  Branch (135:13): [True: 0, False: 35.5k]
  ------------------
  136|      0|            return false;
  137|      0|        }
  138|  35.5k|        bytes_written += chunk.size();
  139|  35.5k|    }
  140|       |
  141|  41.0k|    Assume(bytes_written == ciphertext.size());
  ------------------
  |  |  118|  41.0k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  142|  41.0k|    return true;
  143|  41.0k|}
_ZN14Sv2CipherState14DecryptMessageENSt3__14spanISt4byteLm18446744073709551615EEES3_:
  146|  41.0k|{
  147|  41.0k|    Assume(Sv2Cipher::EncryptedMessageSize(plain.size()) == ciphertext.size());
  ------------------
  |  |  118|  41.0k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  148|       |
  149|  41.0k|    size_t processed = 0;
  150|  41.0k|    size_t plain_position = 0;
  151|  41.0k|    std::vector<std::byte> ad; // No associated data
  152|       |
  153|  76.0k|    while (processed < ciphertext.size()) {
  ------------------
  |  Branch (153:12): [True: 35.5k, False: 40.5k]
  ------------------
  154|  35.5k|        size_t chunk_size = std::min(ciphertext.size() - processed, NOISE_MAX_CHUNK_SIZE);
  155|  35.5k|        std::span<std::byte> chunk_cipher = ciphertext.subspan(processed, chunk_size);
  156|  35.5k|        std::span<std::byte> chunk_plain = plain.subspan(plain_position, chunk_size - Poly1305::TAGLEN);
  157|  35.5k|        if (!DecryptWithAd(ad, chunk_cipher, chunk_plain)) return false;
  ------------------
  |  Branch (157:13): [True: 528, False: 34.9k]
  ------------------
  158|  34.9k|        processed += chunk_size;
  159|  34.9k|        plain_position += chunk_size - Poly1305::TAGLEN;
  160|  34.9k|    }
  161|       |
  162|  40.5k|    return true;
  163|  41.0k|}
_ZN17Sv2SymmetricState7MixHashENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  166|  32.0k|{
  167|  32.0k|    m_hash_output = (HashWriter{} << m_hash_output << input).GetSHA256();
  168|  32.0k|}
_ZN17Sv2SymmetricState6MixKeyENSt3__14spanIKSt4byteLm18446744073709551615EEE:
  171|  12.6k|{
  172|  12.6k|    NoiseHash out0;
  173|  12.6k|    NoiseHash out1;
  174|  12.6k|    HKDF2(input_key_material, out0, out1);
  175|  12.6k|    m_chaining_key = std::move(out0);
  176|  12.6k|    m_cipher_state = Sv2CipherState{std::move(out1)};
  177|  12.6k|}
_ZN17Sv2SymmetricState14LogChainingKeyEv:
  185|  12.6k|{
  186|  12.6k|    LogTrace(BCLog::SV2, "Chaining key: %s\n", GetChainingKey());
  ------------------
  |  |  264|  12.6k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  12.6k|    do {                                                              \
  |  |  |  |  257|  12.6k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 12.6k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  12.6k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 12.6k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  187|  12.6k|}
_ZN17Sv2SymmetricState5HKDF2ENSt3__14spanIKSt4byteLm18446744073709551615EEERNS0_5arrayIhLm32EEES7_:
  190|  14.8k|{
  191|  14.8k|    NoiseHash tmp_key;
  192|  14.8k|    CHMAC_SHA256 tmp_mac(m_chaining_key.data(), m_chaining_key.size());
  193|  14.8k|    tmp_mac.Write(UCharCast(input_key_material.data()), input_key_material.size());
  194|  14.8k|    tmp_mac.Finalize(tmp_key.data());
  195|       |
  196|  14.8k|    CHMAC_SHA256 out0_mac(tmp_key.data(), tmp_key.size());
  197|  14.8k|    uint8_t one[1]{0x1};
  198|  14.8k|    out0_mac.Write(one, 1);
  199|  14.8k|    out0_mac.Finalize(out0.data());
  200|       |
  201|  14.8k|    std::vector<uint8_t> in1;
  202|  14.8k|    in1.reserve(HASHLEN + 1);
  203|  14.8k|    std::copy(out0.begin(), out0.end(), std::back_inserter(in1));
  204|  14.8k|    in1.push_back(0x02);
  205|       |
  206|  14.8k|    CHMAC_SHA256 out1_mac(tmp_key.data(), tmp_key.size());
  207|  14.8k|    out1_mac.Write(&in1[0], in1.size());
  208|  14.8k|    out1_mac.Finalize(out1.data());
  209|  14.8k|}
_ZN17Sv2SymmetricState14EncryptAndHashENSt3__14spanIKSt4byteLm18446744073709551615EEENS1_IS2_Lm18446744073709551615EEE:
  212|  6.72k|{
  213|  6.72k|    Assume(Sv2Cipher::EncryptedMessageSize(plain.size()) == ciphertext.size());
  ------------------
  |  |  118|  6.72k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  214|       |
  215|  6.72k|    if (!m_cipher_state.EncryptWithAd(MakeByteSpan(m_hash_output), plain, ciphertext)) {
  ------------------
  |  Branch (215:9): [True: 0, False: 6.72k]
  ------------------
  216|      0|        return false;
  217|      0|    }
  218|  6.72k|    MixHash(ciphertext);
  219|  6.72k|    return true;
  220|  6.72k|}
_ZN17Sv2SymmetricState14DecryptAndHashENSt3__14spanISt4byteLm18446744073709551615EEES3_:
  223|  5.96k|{
  224|  5.96k|    Assume(Sv2Cipher::EncryptedMessageSize(plain.size()) == ciphertext.size());
  ------------------
  |  |  118|  5.96k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  225|       |
  226|       |    // The handshake requires mix hashing the cipher text NOT the decrypted
  227|       |    // plaintext.
  228|  5.96k|    std::vector<std::byte> ciphertext_copy;
  229|  5.96k|    ciphertext_copy.assign(ciphertext.begin(), ciphertext.end());
  230|       |
  231|  5.96k|    bool res = m_cipher_state.DecryptWithAd(MakeByteSpan(m_hash_output), ciphertext, plain);
  232|  5.96k|    if (!res) return false;
  ------------------
  |  Branch (232:9): [True: 800, False: 5.16k]
  ------------------
  233|  5.16k|    MixHash(ciphertext_copy);
  234|  5.16k|    return true;
  235|  5.96k|}
_ZN17Sv2SymmetricState5SplitEv:
  238|  2.15k|{
  239|  2.15k|    NoiseHash send_key;
  240|  2.15k|    NoiseHash recv_key;
  241|  2.15k|    HKDF2({}, send_key, recv_key);
  242|  2.15k|    return {Sv2CipherState{std::move(send_key)}, Sv2CipherState{std::move(recv_key)}};
  243|  2.15k|}
_ZN17Sv2SymmetricState13GetHashOutputEv:
  246|  2.15k|{
  247|  2.15k|    return m_hash_output;
  248|  2.15k|}
_ZN17Sv2HandshakeState15SetEphemeralKeyEO4CKey:
  251|  6.72k|{
  252|  6.72k|    m_ephemeral_key = key;
  253|  6.72k|    m_ephemeral_ellswift_pk = m_ephemeral_key.EllSwiftCreate(MakeByteSpan(GetRandHash()));
  254|  6.72k|};
_ZN17Sv2HandshakeState19WriteMsgEphemeralPKENSt3__14spanISt4byteLm18446744073709551615EEE:
  264|  3.36k|{
  265|  3.36k|    if (msg.size() < ELLSWIFT_PUB_KEY_SIZE) {
  ------------------
  |  Branch (265:9): [True: 0, False: 3.36k]
  ------------------
  266|      0|        throw std::runtime_error(strprintf("Invalid message size: %d bytes < %d", msg.size(), ELLSWIFT_PUB_KEY_SIZE));
  ------------------
  |  | 1172|      0|#define strprintf tfm::format
  ------------------
  267|      0|    }
  268|       |
  269|  3.36k|    if (!m_ephemeral_key.IsValid()) {
  ------------------
  |  Branch (269:9): [True: 0, False: 3.36k]
  ------------------
  270|      0|        GenerateEphemeralKey();
  271|      0|    }
  272|       |
  273|  3.36k|    LogTrace(BCLog::SV2, "Write our ephemeral key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  274|  3.36k|    std::copy(m_ephemeral_ellswift_pk.begin(), m_ephemeral_ellswift_pk.end(), msg.begin());
  275|       |
  276|  3.36k|    m_symmetric_state.MixHash(msg.subspan(0, ELLSWIFT_PUB_KEY_SIZE));
  277|  3.36k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  278|       |
  279|  3.36k|    std::vector<std::byte> empty;
  280|  3.36k|    m_symmetric_state.MixHash(empty);
  281|  3.36k|}
_ZN17Sv2HandshakeState18ReadMsgEphemeralPKENSt3__14spanISt4byteLm18446744073709551615EEE:
  284|  3.36k|{
  285|  3.36k|    LogTrace(BCLog::SV2, "Read their ephemeral key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  286|  3.36k|    Assume(msg.size() == ELLSWIFT_PUB_KEY_SIZE);
  ------------------
  |  |  118|  3.36k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  287|  3.36k|    m_remote_ephemeral_ellswift_pk = EllSwiftPubKey(msg);
  288|       |
  289|  3.36k|    m_symmetric_state.MixHash(msg.subspan(0, ELLSWIFT_PUB_KEY_SIZE));
  290|  3.36k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  291|       |
  292|  3.36k|    std::vector<std::byte> empty;
  293|  3.36k|    m_symmetric_state.MixHash(empty);
  294|  3.36k|}
_ZN17Sv2HandshakeState10WriteMsgESENSt3__14spanISt4byteLm18446744073709551615EEE:
  297|  3.36k|{
  298|  3.36k|    if (msg.size() < HANDSHAKE_STEP2_SIZE) {
  ------------------
  |  Branch (298:9): [True: 0, False: 3.36k]
  ------------------
  299|      0|        throw std::runtime_error(strprintf("Invalid message size: %d bytes < %d", msg.size(), HANDSHAKE_STEP2_SIZE));
  ------------------
  |  | 1172|      0|#define strprintf tfm::format
  ------------------
  300|      0|    }
  301|       |
  302|  3.36k|    ssize_t bytes_written = 0;
  303|       |
  304|  3.36k|    if (!m_ephemeral_key.IsValid()) {
  ------------------
  |  Branch (304:9): [True: 0, False: 3.36k]
  ------------------
  305|      0|        GenerateEphemeralKey();
  306|      0|    }
  307|       |
  308|       |    // Send our ephemeral pk.
  309|  3.36k|    LogTrace(BCLog::SV2, "Write our ephemeral key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  310|  3.36k|    std::copy(m_ephemeral_ellswift_pk.begin(), m_ephemeral_ellswift_pk.end(), msg.begin());
  311|       |
  312|  3.36k|    m_symmetric_state.MixHash(msg.subspan(0, ELLSWIFT_PUB_KEY_SIZE));
  313|  3.36k|    bytes_written += ELLSWIFT_PUB_KEY_SIZE;
  314|       |
  315|  3.36k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  316|       |
  317|  3.36k|    LogTrace(BCLog::SV2, "Perform ECDH with the remote ephemeral key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  318|  3.36k|    ECDHSecret ecdh_secret{m_ephemeral_key.ComputeBIP324ECDHSecret(m_remote_ephemeral_ellswift_pk,
  319|  3.36k|                                                                   m_ephemeral_ellswift_pk,
  320|  3.36k|                                                                   /*initiating=*/false)};
  321|       |
  322|  3.36k|    LogTrace(BCLog::SV2, "Mix key with ECDH result: ephemeral ours -- remote ephemeral\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  323|  3.36k|    m_symmetric_state.MixKey(ecdh_secret);
  324|  3.36k|    m_symmetric_state.LogChainingKey();
  325|       |
  326|       |    // Send our static pk.
  327|  3.36k|    LogTrace(BCLog::SV2, "Encrypt and write our static key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  328|       |
  329|  3.36k|    if (!m_symmetric_state.EncryptAndHash(m_static_ellswift_pk, msg.subspan(ELLSWIFT_PUB_KEY_SIZE, ELLSWIFT_PUB_KEY_SIZE + Poly1305::TAGLEN))) {
  ------------------
  |  Branch (329:9): [True: 0, False: 3.36k]
  ------------------
  330|       |        // This should never happen
  331|      0|        Assume(false);
  ------------------
  |  |  118|      0|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  332|      0|        throw std::runtime_error("Failed to encrypt our ephemeral key\n");
  333|      0|    }
  334|       |
  335|  3.36k|    bytes_written += ELLSWIFT_PUB_KEY_SIZE + Poly1305::TAGLEN;
  336|       |
  337|  3.36k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  338|       |
  339|  3.36k|    LogTrace(BCLog::SV2, "Perform ECDH between our static and remote ephemeral key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  340|  3.36k|    ECDHSecret ecdh_static_secret{m_static_key.ComputeBIP324ECDHSecret(m_remote_ephemeral_ellswift_pk,
  341|  3.36k|                                                                       m_static_ellswift_pk,
  342|  3.36k|                                                                       /*initiating=*/false)};
  343|  3.36k|    LogTrace(BCLog::SV2, "ECDH result: %s\n", HexStr(ecdh_static_secret));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  344|       |
  345|  3.36k|    LogTrace(BCLog::SV2, "Mix key with ECDH result: static ours -- remote ephemeral\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  346|  3.36k|    m_symmetric_state.MixKey(ecdh_static_secret);
  347|  3.36k|    m_symmetric_state.LogChainingKey();
  348|       |
  349|       |    // Serialize our digital signature noise message and encrypt.
  350|  3.36k|    DataStream ss{};
  351|  3.36k|    Assume(m_certificate);
  ------------------
  |  |  118|  3.36k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  352|  3.36k|    ss << m_certificate.value();
  353|  3.36k|    Assume(ss.size() == Sv2SignatureNoiseMessage::SIZE);
  ------------------
  |  |  118|  3.36k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  354|       |
  355|  3.36k|    LogTrace(BCLog::SV2, "Encrypt certificate: %s\n", HexStr(ss));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  356|  3.36k|    if (!m_symmetric_state.EncryptAndHash(ss, msg.subspan(bytes_written, Sv2SignatureNoiseMessage::SIZE + Poly1305::TAGLEN))) {
  ------------------
  |  Branch (356:9): [True: 0, False: 3.36k]
  ------------------
  357|       |        // This should never happen
  358|      0|        Assume(false);
  ------------------
  |  |  118|      0|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  359|      0|        throw std::runtime_error("Failed to encrypt our certificate\n");
  360|      0|    }
  361|       |
  362|  3.36k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  363|       |
  364|  3.36k|    bytes_written += Sv2SignatureNoiseMessage::SIZE + Poly1305::TAGLEN;
  365|  3.36k|    Assume(bytes_written == HANDSHAKE_STEP2_SIZE);
  ------------------
  |  |  118|  3.36k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  366|  3.36k|}
_ZN17Sv2HandshakeState9ReadMsgESENSt3__14spanISt4byteLm18446744073709551615EEE:
  369|  3.36k|{
  370|  3.36k|    Assume(msg.size() == HANDSHAKE_STEP2_SIZE);
  ------------------
  |  |  118|  3.36k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  371|  3.36k|    ssize_t bytes_read = 0;
  372|       |
  373|       |    // Read the remote ephemeral key from the msg and decrypt.
  374|  3.36k|    LogTrace(BCLog::SV2, "Read remote ephemeral key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  375|  3.36k|    m_remote_ephemeral_ellswift_pk = EllSwiftPubKey(msg.subspan(0, ELLSWIFT_PUB_KEY_SIZE));
  376|  3.36k|    bytes_read += ELLSWIFT_PUB_KEY_SIZE;
  377|       |
  378|  3.36k|    m_symmetric_state.MixHash(m_remote_ephemeral_ellswift_pk);
  379|  3.36k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  380|       |
  381|  3.36k|    LogTrace(BCLog::SV2, "Perform ECDH with the remote ephemeral key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  382|  3.36k|    ECDHSecret ecdh_secret{m_ephemeral_key.ComputeBIP324ECDHSecret(m_remote_ephemeral_ellswift_pk,
  383|  3.36k|                                                                   m_ephemeral_ellswift_pk,
  384|  3.36k|                                                                   /*initiating=*/true)};
  385|       |
  386|  3.36k|    LogTrace(BCLog::SV2, "Mix key with ECDH result: ephemeral ours -- remote ephemeral\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  387|  3.36k|    m_symmetric_state.MixKey(ecdh_secret);
  388|  3.36k|    m_symmetric_state.LogChainingKey();
  389|       |
  390|  3.36k|    LogTrace(BCLog::SV2, "Decrypt remote static key\n");
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  391|  3.36k|    std::array<std::byte, ELLSWIFT_PUB_KEY_SIZE> remote_static_key_bytes;
  392|  3.36k|    bool res = m_symmetric_state.DecryptAndHash(msg.subspan(ELLSWIFT_PUB_KEY_SIZE, ELLSWIFT_PUB_KEY_SIZE + Poly1305::TAGLEN), remote_static_key_bytes);
  393|  3.36k|    if (!res) return false;
  ------------------
  |  Branch (393:9): [True: 760, False: 2.60k]
  ------------------
  394|  2.60k|    bytes_read += ELLSWIFT_PUB_KEY_SIZE + Poly1305::TAGLEN;
  395|       |
  396|  2.60k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  2.60k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.60k|    do {                                                              \
  |  |  |  |  257|  2.60k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.60k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.60k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.60k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  397|       |
  398|       |    // Load remote static key from the decryted msg
  399|  2.60k|    m_remote_static_ellswift_pk = EllSwiftPubKey(remote_static_key_bytes);
  400|       |
  401|  2.60k|    LogTrace(BCLog::SV2, "Perform ECDH on the remote static key\n");
  ------------------
  |  |  264|  2.60k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.60k|    do {                                                              \
  |  |  |  |  257|  2.60k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.60k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.60k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.60k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  402|  2.60k|    ECDHSecret ecdh_static_secret{m_ephemeral_key.ComputeBIP324ECDHSecret(m_remote_static_ellswift_pk,
  403|  2.60k|                                                                          m_ephemeral_ellswift_pk,
  404|  2.60k|                                                                          /*initiating=*/true)};
  405|  2.60k|    LogTrace(BCLog::SV2, "ECDH result: %s\n", HexStr(ecdh_static_secret));
  ------------------
  |  |  264|  2.60k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.60k|    do {                                                              \
  |  |  |  |  257|  2.60k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.60k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.60k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.60k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  406|       |
  407|  2.60k|    LogTrace(BCLog::SV2, "Mix key with ECDH result: ephemeral ours -- remote static\n");
  ------------------
  |  |  264|  2.60k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.60k|    do {                                                              \
  |  |  |  |  257|  2.60k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.60k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.60k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.60k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  408|  2.60k|    m_symmetric_state.MixKey(ecdh_static_secret);
  409|  2.60k|    m_symmetric_state.LogChainingKey();
  410|       |
  411|  2.60k|    LogTrace(BCLog::SV2, "Decrypt remote certificate\n");
  ------------------
  |  |  264|  2.60k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.60k|    do {                                                              \
  |  |  |  |  257|  2.60k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.60k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.60k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.60k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  412|  2.60k|    std::array<std::byte, Sv2SignatureNoiseMessage::SIZE> remote_cert_bytes;
  413|  2.60k|    res = m_symmetric_state.DecryptAndHash(msg.subspan(bytes_read, Sv2SignatureNoiseMessage::SIZE + Poly1305::TAGLEN), remote_cert_bytes);
  414|  2.60k|    if (!res) return false;
  ------------------
  |  Branch (414:9): [True: 40, False: 2.56k]
  ------------------
  415|  2.56k|    bytes_read += (Sv2SignatureNoiseMessage::SIZE + Poly1305::TAGLEN);
  416|  2.56k|    LogTrace(BCLog::SV2, "Mix hash: %s\n", HexStr(m_symmetric_state.GetHashOutput()));
  ------------------
  |  |  264|  2.56k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.56k|    do {                                                              \
  |  |  |  |  257|  2.56k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.56k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.56k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.56k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  417|       |
  418|  2.56k|    LogTrace(BCLog::SV2, "Validate remote certificate\n");
  ------------------
  |  |  264|  2.56k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  2.56k|    do {                                                              \
  |  |  |  |  257|  2.56k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 2.56k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  2.56k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 2.56k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  419|  2.56k|    DataStream ss_cert(remote_cert_bytes);
  420|  2.56k|    Sv2SignatureNoiseMessage cert;
  421|  2.56k|    ss_cert >> cert;
  422|  2.56k|    cert.m_static_key = XOnlyPubKey(m_remote_static_ellswift_pk.Decode());
  423|  2.56k|    Assume(m_authority_pubkey);
  ------------------
  |  |  118|  2.56k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  424|  2.56k|    if (!cert.Validate(m_authority_pubkey.value())) {
  ------------------
  |  Branch (424:9): [True: 1.48k, False: 1.07k]
  ------------------
  425|       |        // We initiated the connection, so it's safe to unconditionally log this:
  426|  1.48k|        LogWarning("Invalid certificate: %s\n", HexStr(remote_cert_bytes));
  ------------------
  |  |  241|  1.48k|#define LogWarning(...) LogPrintLevel_(BCLog::LogFlags::ALL, BCLog::Level::Warning, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  235|  1.48k|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  ------------------
  ------------------
  427|  1.48k|        return false;
  428|  1.48k|    }
  429|       |
  430|  1.07k|    Assume(bytes_read == HANDSHAKE_STEP2_SIZE);
  ------------------
  |  |  118|  1.07k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  431|  1.07k|    return true;
  432|  2.56k|}
_ZN17Sv2HandshakeState19SplitSymmetricStateEv:
  435|  2.15k|{
  436|  2.15k|    return m_symmetric_state.Split();
  437|  2.15k|}
_ZN17Sv2HandshakeState13GetHashOutputEv:
  440|  2.15k|{
  441|  2.15k|    return m_symmetric_state.GetHashOutput();
  442|  2.15k|}
_ZN9Sv2Cipher15FinishHandshakeEv:
  463|  2.15k|{
  464|  2.15k|    Assume(m_handshake_state);
  ------------------
  |  |  118|  2.15k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  465|       |
  466|  2.15k|    auto cipher_state{m_handshake_state->SplitSymmetricState()};
  467|       |
  468|  2.15k|    m_hash = m_handshake_state->GetHashOutput();
  469|       |
  470|  2.15k|    m_cs1 = std::move(cipher_state[0]);
  471|  2.15k|    m_cs2 = std::move(cipher_state[1]);
  472|       |
  473|  2.15k|    m_handshake_state.reset();
  474|  2.15k|}
_ZN9Sv2Cipher20EncryptedMessageSizeEm:
  477|   301k|{
  478|   301k|    constexpr size_t chunk_size = NOISE_MAX_CHUNK_SIZE - Poly1305::TAGLEN;
  479|   301k|    const size_t num_chunks = (msg_len + chunk_size - 1) / chunk_size;
  480|   301k|    return msg_len + (num_chunks * Poly1305::TAGLEN);
  481|   301k|}
_ZN9Sv2Cipher14DecryptMessageENSt3__14spanISt4byteLm18446744073709551615EEES3_:
  484|  41.0k|{
  485|  41.0k|    Assume(EncryptedMessageSize(plain.size()) == ciphertext.size());
  ------------------
  |  |  118|  41.0k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  486|       |
  487|  41.0k|    if (m_initiator) {
  ------------------
  |  Branch (487:9): [True: 37.8k, False: 3.24k]
  ------------------
  488|  37.8k|        return m_cs2.DecryptMessage(ciphertext, plain);
  489|  37.8k|    } else {
  490|  3.24k|        return m_cs1.DecryptMessage(ciphertext, plain);
  491|  3.24k|    }
  492|  41.0k|}
_ZN9Sv2Cipher14EncryptMessageENSt3__14spanIKSt4byteLm18446744073709551615EEENS1_IS2_Lm18446744073709551615EEE:
  495|  41.0k|{
  496|  41.0k|    Assume(output.size() == Sv2Cipher::EncryptedMessageSize(input.size()));
  ------------------
  |  |  118|  41.0k|#define Assume(val) inline_assertion_check<false>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
  497|       |
  498|  41.0k|    if (m_initiator) {
  ------------------
  |  Branch (498:9): [True: 3.24k, False: 37.8k]
  ------------------
  499|  3.24k|        return m_cs1.EncryptMessage(input, output);
  500|  37.8k|    } else {
  501|  37.8k|        return m_cs2.EncryptMessage(input, output);
  502|  37.8k|    }
  503|  41.0k|}

_ZN9Sv2CipherC2EbNSt3__110unique_ptrI17Sv2HandshakeStateNS0_14default_deleteIS2_EEEE:
  271|  2.15k|    Sv2Cipher(bool initiator, std::unique_ptr<Sv2HandshakeState> handshake_state) : m_initiator{initiator}, m_handshake_state{std::move(handshake_state)} {};
_ZN17Sv2SymmetricStateC2Ev:
  155|  6.72k|    Sv2SymmetricState() : m_chaining_key{PROTOCOL_NAME_HASH} {}
_ZN17Sv2HandshakeStateC2EO4CKey11XOnlyPubKey:
  202|  3.36k|                      XOnlyPubKey authority_pubkey) : m_static_key{static_key},
  203|  3.36k|                                                        m_authority_pubkey{authority_pubkey}
  204|  3.36k|    {
  205|  3.36k|        m_static_ellswift_pk = static_key.EllSwiftCreate(MakeByteSpan(GetRandHash()));
  206|  3.36k|    };
_ZN17Sv2HandshakeStateC2EO4CKeyO24Sv2SignatureNoiseMessage:
  212|  3.36k|                      Sv2SignatureNoiseMessage&& certificate) : m_static_key{static_key},
  213|  3.36k|                                                                m_certificate{certificate}
  214|  3.36k|    {
  215|  3.36k|        m_static_ellswift_pk = static_key.EllSwiftCreate(MakeByteSpan(GetRandHash()));
  216|  3.36k|    };
_ZN24Sv2SignatureNoiseMessageC2Ev:
   52|  5.92k|    Sv2SignatureNoiseMessage() = default;
_ZN14Sv2CipherStateC2Ev:
   90|  11.0k|    Sv2CipherState() = default;
_ZNK24Sv2SignatureNoiseMessage9SerializeI10DataStreamEEvRT_:
   63|  3.36k|    {
   64|  3.36k|        s << m_version
   65|  3.36k|          << m_valid_from
   66|  3.36k|          << m_valid_to
   67|  3.36k|          << m_sig;
   68|  3.36k|    }
_ZN24Sv2SignatureNoiseMessage11UnserializeI10DataStreamEEvRT_:
   71|  2.56k|    {
   72|  2.56k|        s >> m_version
   73|  2.56k|          >> m_valid_from
   74|  2.56k|          >> m_valid_to
   75|  2.56k|          >> m_sig;
   76|  2.56k|    }

_ZN14AnnotatedMixinINSt3__115recursive_mutexEED2Ev:
   89|      2|    ~AnnotatedMixin() {
   90|      2|        DeleteLock((void*)this);
   91|      2|    }
_Z13LeaveCriticalv:
   71|  16.8k|inline void LeaveCritical() {}
_Z17MaybeCheckNotHeldR14AnnotatedMixinINSt3__15mutexEE:
  249|  16.8k|inline Mutex& MaybeCheckNotHeld(Mutex& cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) LOCK_RETURNED(cs) { return cs; }
_Z10DeleteLockPv:
   77|      6|inline void DeleteLock(void* cs) {}
_ZN14AnnotatedMixinINSt3__15mutexEED2Ev:
   89|      4|    ~AnnotatedMixin() {
   90|      4|        DeleteLock((void*)this);
   91|      4|    }
_ZN10UniqueLockI14AnnotatedMixinINSt3__15mutexEEEC2ERS3_PKcS7_ib:
  172|  16.8k|    UniqueLock(MutexType& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : Base(mutexIn, std::defer_lock)
  173|  16.8k|    {
  174|  16.8k|        if (fTry)
  ------------------
  |  Branch (174:13): [True: 0, False: 16.8k]
  ------------------
  175|      0|            TryEnter(pszName, pszFile, nLine);
  176|  16.8k|        else
  177|  16.8k|            Enter(pszName, pszFile, nLine);
  178|  16.8k|    }
_Z13EnterCriticalINSt3__15mutexEEvPKcS3_iPT_b:
   70|  16.8k|inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, MutexType* cs, bool fTry = false) {}
_ZN10UniqueLockI14AnnotatedMixinINSt3__15mutexEEE5EnterEPKcS6_i:
  152|  16.8k|    {
  153|  16.8k|        EnterCritical(pszName, pszFile, nLine, Base::mutex());
  154|       |#ifdef DEBUG_LOCKCONTENTION
  155|       |        if (Base::try_lock()) return;
  156|       |        LOG_TIME_MICROS_WITH_CATEGORY(strprintf("lock contention %s, %s:%d", pszName, pszFile, nLine), BCLog::LOCK);
  157|       |#endif
  158|  16.8k|        Base::lock();
  159|  16.8k|    }
_ZN10UniqueLockI14AnnotatedMixinINSt3__15mutexEEED2Ev:
  192|  16.8k|    {
  193|  16.8k|        if (Base::owns_lock())
  ------------------
  |  Branch (193:13): [True: 16.8k, False: 0]
  ------------------
  194|  16.8k|            LeaveCritical();
  195|  16.8k|    }

_ZN18FuzzedDataProvider11ConsumeBoolEv:
  289|  90.7k|inline bool FuzzedDataProvider::ConsumeBool() {
  290|  90.7k|  return 1 & ConsumeIntegral<uint8_t>();
  291|  90.7k|}
_ZN18FuzzedDataProvider15ConsumeIntegralIhEET_v:
  195|  90.7k|template <typename T> T FuzzedDataProvider::ConsumeIntegral() {
  196|  90.7k|  return ConsumeIntegralInRange(std::numeric_limits<T>::min(),
  197|  90.7k|                                std::numeric_limits<T>::max());
  198|  90.7k|}
_ZN18FuzzedDataProvider22ConsumeIntegralInRangeIhEET_S1_S1_:
  205|  90.7k|T FuzzedDataProvider::ConsumeIntegralInRange(T min, T max) {
  206|  90.7k|  static_assert(std::is_integral_v<T>, "An integral type is required.");
  207|  90.7k|  static_assert(sizeof(T) <= sizeof(uint64_t), "Unsupported integral type.");
  208|       |
  209|  90.7k|  if (min > max)
  ------------------
  |  Branch (209:7): [True: 0, False: 90.7k]
  ------------------
  210|      0|    abort();
  211|       |
  212|       |  // Use the biggest type possible to hold the range and the result.
  213|  90.7k|  uint64_t range = static_cast<uint64_t>(max) - static_cast<uint64_t>(min);
  214|  90.7k|  uint64_t result = 0;
  215|  90.7k|  size_t offset = 0;
  216|       |
  217|   173k|  while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&
  ------------------
  |  Branch (217:10): [True: 90.7k, False: 82.3k]
  |  Branch (217:43): [True: 90.7k, False: 0]
  ------------------
  218|  90.7k|         remaining_bytes_ != 0) {
  ------------------
  |  Branch (218:10): [True: 82.3k, False: 8.33k]
  ------------------
  219|       |    // Pull bytes off the end of the seed data. Experimentally, this seems to
  220|       |    // allow the fuzzer to more easily explore the input space. This makes
  221|       |    // sense, since it works by modifying inputs that caused new code to run,
  222|       |    // and this data is often used to encode length of data read by
  223|       |    // |ConsumeBytes|. Separating out read lengths makes it easier modify the
  224|       |    // contents of the data that is actually read.
  225|  82.3k|    --remaining_bytes_;
  226|  82.3k|    result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];
  227|  82.3k|    offset += CHAR_BIT;
  228|  82.3k|  }
  229|       |
  230|       |  // Avoid division by 0, in case |range + 1| results in overflow.
  231|  90.7k|  if (range != std::numeric_limits<decltype(range)>::max())
  ------------------
  |  Branch (231:7): [True: 90.7k, False: 0]
  ------------------
  232|  90.7k|    result = result % (range + 1);
  233|       |
  234|  90.7k|  return static_cast<T>(static_cast<uint64_t>(min) + result);
  235|  90.7k|}
_ZN18FuzzedDataProviderC2EPKhm:
   37|  3.36k|      : data_ptr_(data), remaining_bytes_(size) {}
_ZN18FuzzedDataProvider15remaining_bytesEv:
   85|  41.6k|  size_t remaining_bytes() { return remaining_bytes_; }
_ZN18FuzzedDataProvider22ConsumeIntegralInRangeIjEET_S1_S1_:
  205|  48.9k|T FuzzedDataProvider::ConsumeIntegralInRange(T min, T max) {
  206|  48.9k|  static_assert(std::is_integral_v<T>, "An integral type is required.");
  207|  48.9k|  static_assert(sizeof(T) <= sizeof(uint64_t), "Unsupported integral type.");
  208|       |
  209|  48.9k|  if (min > max)
  ------------------
  |  Branch (209:7): [True: 0, False: 48.9k]
  ------------------
  210|      0|    abort();
  211|       |
  212|       |  // Use the biggest type possible to hold the range and the result.
  213|  48.9k|  uint64_t range = static_cast<uint64_t>(max) - static_cast<uint64_t>(min);
  214|  48.9k|  uint64_t result = 0;
  215|  48.9k|  size_t offset = 0;
  216|       |
  217|   186k|  while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&
  ------------------
  |  Branch (217:10): [True: 183k, False: 2.65k]
  |  Branch (217:43): [True: 141k, False: 42.5k]
  ------------------
  218|   141k|         remaining_bytes_ != 0) {
  ------------------
  |  Branch (218:10): [True: 137k, False: 3.72k]
  ------------------
  219|       |    // Pull bytes off the end of the seed data. Experimentally, this seems to
  220|       |    // allow the fuzzer to more easily explore the input space. This makes
  221|       |    // sense, since it works by modifying inputs that caused new code to run,
  222|       |    // and this data is often used to encode length of data read by
  223|       |    // |ConsumeBytes|. Separating out read lengths makes it easier modify the
  224|       |    // contents of the data that is actually read.
  225|   137k|    --remaining_bytes_;
  226|   137k|    result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];
  227|   137k|    offset += CHAR_BIT;
  228|   137k|  }
  229|       |
  230|       |  // Avoid division by 0, in case |range + 1| results in overflow.
  231|  48.9k|  if (range != std::numeric_limits<decltype(range)>::max())
  ------------------
  |  Branch (231:7): [True: 48.9k, False: 0]
  ------------------
  232|  48.9k|    result = result % (range + 1);
  233|       |
  234|  48.9k|  return static_cast<T>(static_cast<uint64_t>(min) + result);
  235|  48.9k|}
_ZN18FuzzedDataProvider12ConsumeBytesISt4byteEENSt3__16vectorIT_NS2_9allocatorIS4_EEEEm:
  109|  3.36k|std::vector<T> FuzzedDataProvider::ConsumeBytes(size_t num_bytes) {
  110|  3.36k|  num_bytes = std::min(num_bytes, remaining_bytes_);
  111|  3.36k|  return ConsumeBytes<T>(num_bytes, num_bytes);
  112|  3.36k|}
_ZN18FuzzedDataProvider12ConsumeBytesISt4byteEENSt3__16vectorIT_NS2_9allocatorIS4_EEEEmm:
  353|  3.36k|std::vector<T> FuzzedDataProvider::ConsumeBytes(size_t size, size_t num_bytes) {
  354|  3.36k|  static_assert(sizeof(T) == sizeof(uint8_t), "Incompatible data type.");
  355|       |
  356|       |  // The point of using the size-based constructor below is to increase the
  357|       |  // odds of having a vector object with capacity being equal to the length.
  358|       |  // That part is always implementation specific, but at least both libc++ and
  359|       |  // libstdc++ allocate the requested number of bytes in that constructor,
  360|       |  // which seems to be a natural choice for other implementations as well.
  361|       |  // To increase the odds even more, we also call |shrink_to_fit| below.
  362|  3.36k|  std::vector<T> result(size);
  363|  3.36k|  if (size == 0) {
  ------------------
  |  Branch (363:7): [True: 0, False: 3.36k]
  ------------------
  364|      0|    if (num_bytes != 0)
  ------------------
  |  Branch (364:9): [True: 0, False: 0]
  ------------------
  365|      0|      abort();
  366|      0|    return result;
  367|      0|  }
  368|       |
  369|  3.36k|  CopyAndAdvance(result.data(), num_bytes);
  370|       |
  371|       |  // Even though |shrink_to_fit| is also implementation specific, we expect it
  372|       |  // to provide an additional assurance in case vector's constructor allocated
  373|       |  // a buffer which is larger than the actual amount of data we put inside it.
  374|  3.36k|  result.shrink_to_fit();
  375|  3.36k|  return result;
  376|  3.36k|}
_ZN18FuzzedDataProvider14CopyAndAdvanceEPvm:
  339|  3.36k|                                               size_t num_bytes) {
  340|  3.36k|  std::memcpy(destination, data_ptr_, num_bytes);
  341|  3.36k|  Advance(num_bytes);
  342|  3.36k|}
_ZN18FuzzedDataProvider7AdvanceEm:
  344|  3.36k|inline void FuzzedDataProvider::Advance(size_t num_bytes) {
  345|  3.36k|  if (num_bytes > remaining_bytes_)
  ------------------
  |  Branch (345:7): [True: 0, False: 3.36k]
  ------------------
  346|      0|    abort();
  347|       |
  348|  3.36k|  data_ptr_ += num_bytes;
  349|  3.36k|  remaining_bytes_ -= num_bytes;
  350|  3.36k|}
_ZN18FuzzedDataProvider15ConsumeIntegralItEET_v:
  195|  1.83k|template <typename T> T FuzzedDataProvider::ConsumeIntegral() {
  196|  1.83k|  return ConsumeIntegralInRange(std::numeric_limits<T>::min(),
  197|  1.83k|                                std::numeric_limits<T>::max());
  198|  1.83k|}
_ZN18FuzzedDataProvider22ConsumeIntegralInRangeItEET_S1_S1_:
  205|  1.83k|T FuzzedDataProvider::ConsumeIntegralInRange(T min, T max) {
  206|  1.83k|  static_assert(std::is_integral_v<T>, "An integral type is required.");
  207|  1.83k|  static_assert(sizeof(T) <= sizeof(uint64_t), "Unsupported integral type.");
  208|       |
  209|  1.83k|  if (min > max)
  ------------------
  |  Branch (209:7): [True: 0, False: 1.83k]
  ------------------
  210|      0|    abort();
  211|       |
  212|       |  // Use the biggest type possible to hold the range and the result.
  213|  1.83k|  uint64_t range = static_cast<uint64_t>(max) - static_cast<uint64_t>(min);
  214|  1.83k|  uint64_t result = 0;
  215|  1.83k|  size_t offset = 0;
  216|       |
  217|  3.10k|  while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&
  ------------------
  |  Branch (217:10): [True: 2.47k, False: 628]
  |  Branch (217:43): [True: 2.47k, False: 0]
  ------------------
  218|  2.47k|         remaining_bytes_ != 0) {
  ------------------
  |  Branch (218:10): [True: 1.27k, False: 1.20k]
  ------------------
  219|       |    // Pull bytes off the end of the seed data. Experimentally, this seems to
  220|       |    // allow the fuzzer to more easily explore the input space. This makes
  221|       |    // sense, since it works by modifying inputs that caused new code to run,
  222|       |    // and this data is often used to encode length of data read by
  223|       |    // |ConsumeBytes|. Separating out read lengths makes it easier modify the
  224|       |    // contents of the data that is actually read.
  225|  1.27k|    --remaining_bytes_;
  226|  1.27k|    result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];
  227|  1.27k|    offset += CHAR_BIT;
  228|  1.27k|  }
  229|       |
  230|       |  // Avoid division by 0, in case |range + 1| results in overflow.
  231|  1.83k|  if (range != std::numeric_limits<decltype(range)>::max())
  ------------------
  |  Branch (231:7): [True: 1.83k, False: 0]
  ------------------
  232|  1.83k|    result = result % (range + 1);
  233|       |
  234|  1.83k|  return static_cast<T>(static_cast<uint64_t>(min) + result);
  235|  1.83k|}
_ZN18FuzzedDataProvider15ConsumeIntegralImEET_v:
  195|  1.07k|template <typename T> T FuzzedDataProvider::ConsumeIntegral() {
  196|  1.07k|  return ConsumeIntegralInRange(std::numeric_limits<T>::min(),
  197|  1.07k|                                std::numeric_limits<T>::max());
  198|  1.07k|}
_ZN18FuzzedDataProvider22ConsumeIntegralInRangeImEET_S1_S1_:
  205|  1.07k|T FuzzedDataProvider::ConsumeIntegralInRange(T min, T max) {
  206|  1.07k|  static_assert(std::is_integral_v<T>, "An integral type is required.");
  207|  1.07k|  static_assert(sizeof(T) <= sizeof(uint64_t), "Unsupported integral type.");
  208|       |
  209|  1.07k|  if (min > max)
  ------------------
  |  Branch (209:7): [True: 0, False: 1.07k]
  ------------------
  210|      0|    abort();
  211|       |
  212|       |  // Use the biggest type possible to hold the range and the result.
  213|  1.07k|  uint64_t range = static_cast<uint64_t>(max) - static_cast<uint64_t>(min);
  214|  1.07k|  uint64_t result = 0;
  215|  1.07k|  size_t offset = 0;
  216|       |
  217|  8.66k|  while (offset < sizeof(T) * CHAR_BIT && (range >> offset) > 0 &&
  ------------------
  |  Branch (217:10): [True: 7.75k, False: 915]
  |  Branch (217:43): [True: 7.75k, False: 0]
  ------------------
  218|  7.75k|         remaining_bytes_ != 0) {
  ------------------
  |  Branch (218:10): [True: 7.59k, False: 164]
  ------------------
  219|       |    // Pull bytes off the end of the seed data. Experimentally, this seems to
  220|       |    // allow the fuzzer to more easily explore the input space. This makes
  221|       |    // sense, since it works by modifying inputs that caused new code to run,
  222|       |    // and this data is often used to encode length of data read by
  223|       |    // |ConsumeBytes|. Separating out read lengths makes it easier modify the
  224|       |    // contents of the data that is actually read.
  225|  7.59k|    --remaining_bytes_;
  226|  7.59k|    result = (result << CHAR_BIT) | data_ptr_[remaining_bytes_];
  227|  7.59k|    offset += CHAR_BIT;
  228|  7.59k|  }
  229|       |
  230|       |  // Avoid division by 0, in case |range + 1| results in overflow.
  231|  1.07k|  if (range != std::numeric_limits<decltype(range)>::max())
  ------------------
  |  Branch (231:7): [True: 0, False: 1.07k]
  ------------------
  232|      0|    result = result % (range + 1);
  233|       |
  234|  1.07k|  return static_cast<T>(static_cast<uint64_t>(min) + result);
  235|  1.07k|}

_ZN12CheckGlobalsC2Ev:
   56|  3.36k|CheckGlobals::CheckGlobals() : m_impl(std::make_unique<CheckGlobalsImpl>()) {}
_ZN12CheckGlobalsD2Ev:
   57|  3.36k|CheckGlobals::~CheckGlobals() = default;
_ZN16CheckGlobalsImplC2Ev:
   17|  3.36k|    {
   18|  3.36k|        g_used_g_prng = false;
   19|  3.36k|        g_seeded_g_prng_zero = false;
   20|  3.36k|        g_used_system_time = false;
   21|  3.36k|        SetMockTime(0s);
   22|  3.36k|    }
_ZN16CheckGlobalsImplD2Ev:
   24|  3.36k|    {
   25|  3.36k|        if (g_used_g_prng && !g_seeded_g_prng_zero) {
  ------------------
  |  Branch (25:13): [True: 3.36k, False: 0]
  |  Branch (25:30): [True: 0, False: 3.36k]
  ------------------
   26|      0|            std::cerr << "\n\n"
   27|      0|                         "The current fuzz target used the global random state.\n\n"
   28|       |
   29|      0|                         "This is acceptable, but requires the fuzz target to call \n"
   30|      0|                         "SeedRandomStateForTest(SeedRand::ZEROS) in the first line \n"
   31|      0|                         "of the FUZZ_TARGET function.\n\n"
   32|       |
   33|      0|                         "An alternative solution would be to avoid any use of globals.\n\n"
   34|       |
   35|      0|                         "Without a solution, fuzz instability and non-determinism can lead \n"
   36|      0|                         "to non-reproducible bugs or inefficient fuzzing.\n\n"
   37|      0|                      << std::endl;
   38|      0|            std::abort(); // Abort, because AFL may try to recover from a std::exit
   39|      0|        }
   40|       |
   41|  3.36k|        if (g_used_system_time) {
  ------------------
  |  Branch (41:13): [True: 0, False: 3.36k]
  ------------------
   42|      0|            std::cerr << "\n\n"
   43|      0|                         "The current fuzz target accessed system time.\n\n"
   44|       |
   45|      0|                         "This is acceptable, but requires the fuzz target to call \n"
   46|      0|                         "SetMockTime() at the beginning of processing the fuzz input.\n\n"
   47|       |
   48|      0|                         "Without setting mock time, time-dependent behavior can lead \n"
   49|      0|                         "to non-reproducible bugs or inefficient fuzzing.\n\n"
   50|      0|                      << std::endl;
   51|      0|            std::abort();
   52|      0|        }
   53|  3.36k|    }

LLVMFuzzerTestOneInput:
  229|  3.36k|{
  230|  3.36k|    test_one_input({data, size});
  231|  3.36k|    return 0;
  232|  3.36k|}
fuzz.cpp:_ZL14test_one_inputNSt3__14spanIKhLm18446744073709551615EEE:
   95|  3.36k|{
   96|  3.36k|    (*Assert(g_test_one_input))(buffer);
  ------------------
  |  |  106|  3.36k|#define Assert(val) inline_assertion_check<true>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
   97|  3.36k|}

_Z11MaybeDamageR18FuzzedDataProviderRNSt3__16vectorISt4byteNS1_9allocatorIS3_EEEE:
   64|  47.7k|{
   65|  47.7k|    if (transport.size() == 0) return false;
  ------------------
  |  Branch (65:9): [True: 9.79k, False: 37.9k]
  ------------------
   66|       |
   67|       |    // Optionally damage 1 bit in the ciphertext.
   68|  37.9k|    const bool damage = provider.ConsumeBool();
   69|  37.9k|    if (damage) {
  ------------------
  |  Branch (69:9): [True: 1.66k, False: 36.3k]
  ------------------
   70|  1.66k|        unsigned damage_bit = provider.ConsumeIntegralInRange<unsigned>(0,
   71|  1.66k|                                                                        transport.size() * 8U - 1U);
   72|  1.66k|        unsigned damage_pos = damage_bit >> 3;
   73|  1.66k|        LogTrace(BCLog::SV2, "Damage byte %d of %d\n", damage_pos, transport.size());
  ------------------
  |  |  264|  1.66k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  1.66k|    do {                                                              \
  |  |  |  |  257|  1.66k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 1.66k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  1.66k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 1.66k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
   74|  1.66k|        std::byte damage_val{(uint8_t)(1U << (damage_bit & 7))};
   75|  1.66k|        transport.at(damage_pos) ^= damage_val;
   76|  1.66k|    }
   77|  37.9k|    return damage;
   78|  47.7k|}
_Z38sv2_noise_cipher_roundtrip_fuzz_targetNSt3__14spanIKhLm18446744073709551615EEE:
   81|  3.36k|{
   82|  3.36k|    const CheckGlobals check_globals{};
   83|  3.36k|    SeedRandomStateForTest(SeedRand::ZEROS);
   84|       |    // Test that Sv2Noise's encryption and decryption agree.
   85|       |
   86|       |    // To conserve fuzzer entropy, deterministically generate Alice and Bob keys.
   87|  3.36k|    FuzzedDataProvider provider(buffer.data(), buffer.size());
   88|  3.36k|    auto seed_ent = provider.ConsumeBytes<std::byte>(32);
   89|  3.36k|    seed_ent.resize(32);
   90|  3.36k|    CExtKey seed;
   91|  3.36k|    seed.SetSeed(seed_ent);
   92|       |
   93|  3.36k|    CExtKey tmp;
   94|  3.36k|    if (!seed.Derive(tmp, 0)) return;
  ------------------
  |  Branch (94:9): [True: 0, False: 3.36k]
  ------------------
   95|  3.36k|    CKey alice_authority_key{tmp.key};
   96|       |
   97|  3.36k|    if (!seed.Derive(tmp, 1)) return;
  ------------------
  |  Branch (97:9): [True: 0, False: 3.36k]
  ------------------
   98|  3.36k|    CKey alice_static_key{tmp.key};
   99|       |
  100|  3.36k|    if (!seed.Derive(tmp, 2)) return;
  ------------------
  |  Branch (100:9): [True: 0, False: 3.36k]
  ------------------
  101|  3.36k|    CKey alice_ephemeral_key{tmp.key};
  102|       |
  103|  3.36k|    if (!seed.Derive(tmp, 10)) return;
  ------------------
  |  Branch (103:9): [True: 0, False: 3.36k]
  ------------------
  104|  3.36k|    CKey bob_authority_key{tmp.key};
  105|       |
  106|  3.36k|    if (!seed.Derive(tmp, 11)) return;
  ------------------
  |  Branch (106:9): [True: 0, False: 3.36k]
  ------------------
  107|  3.36k|    CKey bob_static_key{tmp.key};
  108|       |
  109|  3.36k|    if (!seed.Derive(tmp, 12)) return;
  ------------------
  |  Branch (109:9): [True: 0, False: 3.36k]
  ------------------
  110|  3.36k|    CKey bob_ephemeral_key{tmp.key};
  111|       |
  112|  3.36k|    if (!seed.Derive(tmp, 13)) return;
  ------------------
  |  Branch (112:9): [True: 0, False: 3.36k]
  ------------------
  113|  3.36k|    CKey malory_authority_key{tmp.key};
  114|       |
  115|  3.36k|    const bool use_fixture_times = provider.ConsumeBool();
  116|  3.36k|    const bool sign_with_expected_authority = use_fixture_times ? true : provider.ConsumeBool();
  ------------------
  |  Branch (116:47): [True: 1.27k, False: 2.08k]
  ------------------
  117|       |
  118|  3.36k|    uint32_t now{0};
  119|  3.36k|    uint32_t valid_from{0};
  120|  3.36k|    uint32_t valid_to{0};
  121|  3.36k|    uint16_t version{0};
  122|       |
  123|  3.36k|    Sv2SignatureNoiseMessage bob_certificate;
  124|       |
  125|  3.36k|    if (use_fixture_times) {
  ------------------
  |  Branch (125:9): [True: 1.27k, False: 2.08k]
  ------------------
  126|  1.27k|        SetMockTime(TEST_GENESIS_TIME);
  127|  1.27k|        bob_certificate = MakeSkewTolerantCertificate(bob_static_key, bob_authority_key, now, valid_from, valid_to);
  128|  2.08k|    } else {
  129|  2.08k|        now = provider.ConsumeIntegralInRange<uint32_t>(10000U, UINT32_MAX);
  130|  2.08k|        uint32_t past = provider.ConsumeIntegralInRange<uint32_t>(0, now);
  131|  2.08k|        uint32_t future = provider.ConsumeIntegralInRange<uint32_t>(now, UINT32_MAX);
  132|  2.08k|        valid_from = provider.ConsumeBool() ? past : future;
  ------------------
  |  Branch (132:22): [True: 374, False: 1.71k]
  ------------------
  133|  2.08k|        valid_to = provider.ConsumeBool() ? future : past;
  ------------------
  |  Branch (133:20): [True: 479, False: 1.60k]
  ------------------
  134|  2.08k|        version = provider.ConsumeBool() ? 0 : provider.ConsumeIntegral<uint16_t>();
  ------------------
  |  Branch (134:19): [True: 252, False: 1.83k]
  ------------------
  135|       |
  136|  2.08k|        const CKey& signing_authority_key = sign_with_expected_authority ? bob_authority_key : malory_authority_key;
  ------------------
  |  Branch (136:45): [True: 627, False: 1.45k]
  ------------------
  137|  2.08k|        bob_certificate = Sv2SignatureNoiseMessage(version, valid_from, valid_to,
  138|  2.08k|                                                   XOnlyPubKey(bob_static_key.GetPubKey()), signing_authority_key);
  139|  2.08k|    }
  140|       |
  141|  3.36k|    SetMockTime(std::chrono::seconds{now});
  142|       |
  143|  3.36k|    const bool certificate_valid_for_expected = bob_certificate.Validate(XOnlyPubKey(bob_authority_key.GetPubKey()));
  144|  3.36k|    bool expected_valid = sign_with_expected_authority && version == 0 && (valid_from <= now) && (valid_to >= now);
  ------------------
  |  Branch (144:27): [True: 1.90k, False: 1.45k]
  |  Branch (144:59): [True: 1.77k, False: 128]
  |  Branch (144:75): [True: 1.68k, False: 93]
  |  Branch (144:98): [True: 1.59k, False: 89]
  ------------------
  145|  3.36k|    if (use_fixture_times) {
  ------------------
  |  Branch (145:9): [True: 1.27k, False: 2.08k]
  ------------------
  146|  1.27k|        expected_valid = true;
  147|  1.27k|        version = 0;
  148|  1.27k|    }
  149|  3.36k|    assert(certificate_valid_for_expected == expected_valid);
  ------------------
  |  Branch (149:5): [True: 3.36k, False: 0]
  ------------------
  150|  3.36k|    bool valid_certificate = certificate_valid_for_expected;
  151|       |
  152|  3.36k|    if (sign_with_expected_authority) {
  ------------------
  |  Branch (152:9): [True: 1.90k, False: 1.45k]
  ------------------
  153|  1.90k|        const bool alternate_valid = bob_certificate.Validate(XOnlyPubKey(malory_authority_key.GetPubKey()));
  154|  1.90k|        assert(!alternate_valid);
  ------------------
  |  Branch (154:9): [True: 1.90k, False: 0]
  ------------------
  155|  1.90k|    }
  156|       |
  157|  3.36k|    LogTrace(BCLog::SV2,
  ------------------
  |  |  264|  3.36k|#define LogTrace(category, ...) LogPrintLevel(category, BCLog::Level::Trace, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  256|  3.36k|    do {                                                              \
  |  |  |  |  257|  3.36k|        if (LogAcceptCategory((category), (level))) {                 \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (257:13): [True: 0, False: 3.36k]
  |  |  |  |  ------------------
  |  |  |  |  258|      0|            LogPrintLevel_(category, level, __VA_ARGS__);             \
  |  |  |  |  ------------------
  |  |  |  |  |  |  235|      0|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  |  |  ------------------
  |  |  |  |  259|      0|        }                                                             \
  |  |  |  |  260|  3.36k|    } while (0)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (260:14): [Folded, False: 3.36k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  158|  3.36k|             "Certificate scenario fixture=%d, version=%u, now=%u, valid_from=%u, valid_to=%u, signed_expected=%d, valid=%d\n",
  159|  3.36k|             use_fixture_times,
  160|  3.36k|             version,
  161|  3.36k|             now,
  162|  3.36k|             valid_from,
  163|  3.36k|             valid_to,
  164|  3.36k|             sign_with_expected_authority,
  165|  3.36k|             valid_certificate);
  166|       |
  167|       |    // Alice's static is not used in the test
  168|       |    // Alice needs to verify Bob's certificate, so we pass his authority key
  169|  3.36k|    auto alice_handshake = std::make_unique<Sv2HandshakeState>(std::move(alice_static_key), XOnlyPubKey(bob_authority_key.GetPubKey()));
  170|  3.36k|    alice_handshake->SetEphemeralKey(std::move(alice_ephemeral_key));
  171|       |    // Bob is the responder and does not receive (or verify) Alice's certificate,
  172|       |    // so we don't pass her authority key.
  173|  3.36k|    auto bob_handshake = std::make_unique<Sv2HandshakeState>(std::move(bob_static_key), std::move(bob_certificate));
  174|  3.36k|    bob_handshake->SetEphemeralKey(std::move(bob_ephemeral_key));
  175|       |
  176|       |    // Handshake Act 1: e ->
  177|       |
  178|  3.36k|    std::vector<std::byte> transport;
  179|  3.36k|    transport.resize(Sv2HandshakeState::ELLSWIFT_PUB_KEY_SIZE);
  180|       |    // Alice generates her ephemeral public key and write it into the buffer:
  181|  3.36k|    alice_handshake->WriteMsgEphemeralPK(transport);
  182|       |
  183|  3.36k|    bool damage_e = MaybeDamage(provider, transport);
  184|       |
  185|       |    // Bob reads the ephemeral key ()
  186|       |    // With EllSwift encoding this step can't fail
  187|  3.36k|    bob_handshake->ReadMsgEphemeralPK(transport);
  188|  3.36k|    ClearShrink(transport);
  189|       |
  190|       |    // Handshake Act 2: <- e, ee, s, es, SIGNATURE_NOISE_MESSAGE
  191|  3.36k|    transport.resize(Sv2HandshakeState::HANDSHAKE_STEP2_SIZE);
  192|  3.36k|    bob_handshake->WriteMsgES(transport);
  193|       |
  194|  3.36k|    bool damage_es = MaybeDamage(provider, transport);
  195|       |
  196|       |    // This ignores the remote possibility that the fuzzer finds two equivalent
  197|       |    // EllSwift encodings by flipping a single ephemeral key bit.
  198|  3.36k|    assert(alice_handshake->ReadMsgES(transport) == (valid_certificate && !damage_e && !damage_es));
  ------------------
  |  Branch (198:5): [True: 1.59k, False: 1.76k]
  |  Branch (198:5): [True: 1.20k, False: 387]
  |  Branch (198:5): [True: 1.07k, False: 127]
  |  Branch (198:5): [True: 3.36k, False: 0]
  ------------------
  199|       |
  200|  3.36k|    if (!valid_certificate || damage_e || damage_es) return;
  ------------------
  |  Branch (200:9): [True: 1.76k, False: 1.59k]
  |  Branch (200:31): [True: 387, False: 1.20k]
  |  Branch (200:43): [True: 127, False: 1.07k]
  ------------------
  201|       |
  202|       |    // Construct Sv2Cipher from the Sv2HandshakeState and test transport
  203|  1.07k|    auto alice{Sv2Cipher(/*initiator=*/true, std::move(alice_handshake))};
  204|  1.07k|    auto bob{Sv2Cipher(/*initiator=*/false, std::move(bob_handshake))};
  205|  1.07k|    alice.FinishHandshake();
  206|  1.07k|    bob.FinishHandshake();
  207|       |
  208|       |    // Use deterministic RNG to generate content rather than creating it from
  209|       |    // the fuzzer input.
  210|  1.07k|    InsecureRandomContext rng(provider.ConsumeIntegral<uint64_t>());
  211|       |
  212|  1.07k|    LIMITED_WHILE(provider.remaining_bytes(), 1000)
  ------------------
  |  |   23|  41.6k|    for (unsigned _count{limit}; (condition) && _count; --_count)
  |  |  ------------------
  |  |  |  Branch (23:34): [True: 41.0k, False: 551]
  |  |  |  Branch (23:49): [True: 41.0k, False: 0]
  |  |  ------------------
  ------------------
  213|  41.0k|    {
  214|  41.0k|        ClearShrink(transport);
  215|       |
  216|       |        // Alice or Bob sends a message
  217|  41.0k|        bool from_alice = provider.ConsumeBool();
  218|       |
  219|       |        // Set content length (slightly above NOISE_MAX_CHUNK_SIZE)
  220|  41.0k|        unsigned length = provider.ConsumeIntegralInRange<unsigned>(0, NOISE_MAX_CHUNK_SIZE + 100);
  221|  41.0k|        std::vector<std::byte> plain(length);
  222|  41.0k|        for (auto& val : plain)
  ------------------
  |  Branch (222:24): [True: 643M, False: 41.0k]
  ------------------
  223|   643M|            val = std::byte{(uint8_t)rng()};
  224|       |
  225|  41.0k|        const size_t encrypted_size = Sv2Cipher::EncryptedMessageSize(plain.size());
  226|  41.0k|        transport.resize(encrypted_size);
  227|       |
  228|  41.0k|        assert((from_alice ? alice : bob).EncryptMessage(plain, transport));
  ------------------
  |  Branch (228:9): [True: 3.24k, False: 37.8k]
  |  Branch (228:9): [True: 41.0k, False: 0]
  ------------------
  229|       |
  230|  41.0k|        const bool damage = MaybeDamage(provider, transport);
  231|       |
  232|  41.0k|        std::vector<std::byte> plain_read;
  233|  41.0k|        plain_read.resize(plain.size());
  234|       |
  235|  41.0k|        bool ok = (from_alice ? bob : alice).DecryptMessage(transport, plain_read);
  ------------------
  |  Branch (235:20): [True: 3.24k, False: 37.8k]
  ------------------
  236|  41.0k|        assert(!ok == damage);
  ------------------
  |  Branch (236:9): [True: 41.0k, False: 0]
  ------------------
  237|  41.0k|        if (!ok) break;
  ------------------
  |  Branch (237:13): [True: 528, False: 40.5k]
  ------------------
  238|       |
  239|  41.0k|        assert(plain == plain_read);
  ------------------
  |  Branch (239:9): [True: 40.5k, False: 0]
  ------------------
  240|  40.5k|    }
  241|       |
  242|  1.07k|    const char* sabotage_env = std::getenv("SV2_FUZZ_SABOTAGE");
  243|  1.07k|    if (sabotage_env && sabotage_env[0] == '1') {
  ------------------
  |  Branch (243:9): [True: 1.07k, False: 0]
  |  Branch (243:25): [True: 0, False: 1.07k]
  ------------------
  244|      0|#if defined(__GNUC__)
  245|      0|        __builtin_trap();
  246|       |#else
  247|       |        std::abort();
  248|       |#endif
  249|      0|    }
  250|  1.07k|}

_ZN20Sv2BasicTestingSetupD2Ev:
   42|      2|{
   43|      2|    SetMockTime(std::chrono::seconds{0});
   44|       |
   45|      2|    try {
   46|      2|        fs::remove_all(m_tmp_root);
   47|      2|    } catch (const std::exception&) {
   48|       |        // Best effort cleanup.
   49|      0|    }
   50|      2|    m_ecc.reset();
   51|      2|}

_Z27MakeSkewTolerantCertificateRK4CKeyS1_RjS2_S2_jt:
   36|  1.27k|{
   37|  1.27k|    const auto now = GetTime<std::chrono::seconds>();
   38|  1.27k|    const int64_t now_count = now.count();
   39|  1.27k|    const int64_t clamped_now = std::max<int64_t>(0, now_count);
   40|  1.27k|    out_now = static_cast<uint32_t>(clamped_now);
   41|       |
   42|  1.27k|    const int64_t backdated = std::max<int64_t>(0, clamped_now - static_cast<int64_t>(backdate_secs));
   43|  1.27k|    out_valid_from = static_cast<uint32_t>(backdated);
   44|  1.27k|    out_valid_to = std::numeric_limits<unsigned int>::max();
   45|       |
   46|  1.27k|    return Sv2SignatureNoiseMessage(version, out_valid_from, out_valid_to,
   47|  1.27k|                                    XOnlyPubKey(static_key.GetPubKey()), authority_key);
   48|  1.27k|}

__gcov_reset:
   13|      2|extern "C" __attribute__((weak)) void __gcov_reset(void) {}

_Z22SeedRandomStateForTest8SeedRand:
   20|  3.36k|{
   21|  3.36k|    constexpr auto RANDOM_CTX_SEED{"RANDOM_CTX_SEED"};
   22|       |
   23|       |    // Do this once, on the first call, regardless of seedtype, because once
   24|       |    // MakeRandDeterministicDANGEROUS is called, the output of GetRandHash is
   25|       |    // no longer truly random. It should be enough to get the seed once for the
   26|       |    // process.
   27|  3.36k|    static const auto g_ctx_seed = []() -> std::optional<uint256> {
   28|  3.36k|        if (EnableFuzzDeterminism()) return {};
   29|       |        // If RANDOM_CTX_SEED is set, use that as seed.
   30|  3.36k|        if (const char* num{std::getenv(RANDOM_CTX_SEED)}) {
   31|  3.36k|            if (auto num_parsed{uint256::FromUserHex(num)}) {
   32|  3.36k|                return *num_parsed;
   33|  3.36k|            } else {
   34|  3.36k|                std::cerr << RANDOM_CTX_SEED << " must consist of up to " << uint256::size() * 2 << " hex digits (\"0x\" prefix allowed), it was set to: '" << num << "'.\n";
   35|  3.36k|                std::abort();
   36|  3.36k|            }
   37|  3.36k|        }
   38|       |        // Otherwise use a (truly) random value.
   39|  3.36k|        return GetRandHash();
   40|  3.36k|    }();
   41|       |
   42|  3.36k|    g_seeded_g_prng_zero = seedtype == SeedRand::ZEROS;
   43|  3.36k|    if (EnableFuzzDeterminism()) {
  ------------------
  |  Branch (43:9): [True: 3.36k, False: 0]
  ------------------
   44|  3.36k|        Assert(g_seeded_g_prng_zero); // Only SeedRandomStateForTest(SeedRand::ZEROS) is allowed in fuzz tests
  ------------------
  |  |  106|  3.36k|#define Assert(val) inline_assertion_check<true>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
   45|  3.36k|        Assert(!g_used_g_prng);       // The global PRNG must not have been used before SeedRandomStateForTest(SeedRand::ZEROS)
  ------------------
  |  |  106|  3.36k|#define Assert(val) inline_assertion_check<true>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
   46|  3.36k|    }
   47|  3.36k|    const uint256& seed{seedtype == SeedRand::FIXED_SEED ? g_ctx_seed.value() : uint256::ZERO};
  ------------------
  |  Branch (47:25): [True: 0, False: 3.36k]
  ------------------
   48|  3.36k|    LogInfo("Setting random seed for current tests to %s=%s\n", RANDOM_CTX_SEED, seed.GetHex());
  ------------------
  |  |  240|  3.36k|#define LogInfo(...) LogPrintLevel_(BCLog::LogFlags::ALL, BCLog::Level::Info, __VA_ARGS__)
  |  |  ------------------
  |  |  |  |  235|  3.36k|#define LogPrintLevel_(category, level, ...) LogPrintFormatInternal(std::source_location::current(), category, level, __VA_ARGS__)
  |  |  ------------------
  ------------------
   49|  3.36k|    MakeRandDeterministicDANGEROUS(seed);
   50|  3.36k|}

_ZN12StdLockGuardC2ER8StdMutex:
   75|  9.68k|    explicit StdLockGuard(StdMutex& cs) EXCLUSIVE_LOCK_FUNCTION(cs) : std::lock_guard<StdMutex>(cs) {}

_ZN10tinyformat6formatIJNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEES7_NS_17FormatStringCheckIXsZT_EEEDpRKT_:
 1088|  1.48k|{
 1089|  1.48k|    std::ostringstream oss;
 1090|  1.48k|    format(oss, fmt, args...);
 1091|  1.48k|    return oss.str();
 1092|  1.48k|}
_ZN10tinyformat6formatIJNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEEvRNS1_13basic_ostreamIcS4_EENS_17FormatStringCheckIXsZT_EEEDpRKT_:
 1080|  1.48k|{
 1081|  1.48k|    vformat(out, fmt, makeFormatList(args...));
 1082|  1.48k|}
_ZN10tinyformat14makeFormatListIJNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEENS_6detail11FormatListNIXsZT_EEEDpRKT_:
 1044|  1.48k|{
 1045|  1.48k|    return detail::FormatListN<sizeof...(args)>(args...);
 1046|  1.48k|}
_ZN10tinyformat6detail9FormatArg10formatImplINSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEvRNS3_13basic_ostreamIcS6_EEPKcSE_iPKv:
  558|  4.84k|        {
  559|  4.84k|            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));
  560|  4.84k|        }
_ZN10tinyformat11formatValueINSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEEvRNS1_13basic_ostreamIcS4_EEPKcSC_iRKT_:
  351|  4.84k|{
  352|  4.84k|#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
  353|       |    // Since we don't support printing of wchar_t using "%ls", make it fail at
  354|       |    // compile time in preference to printing as a void* at runtime.
  355|  4.84k|    typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;
  356|  4.84k|    (void) DummyType(); // avoid unused type warning with gcc-4.8
  357|  4.84k|#endif
  358|       |    // The mess here is to support the %c and %p conversions: if these
  359|       |    // conversions are active we try to convert the type to a char or const
  360|       |    // void* respectively and format that instead of the value itself.  For the
  361|       |    // %p conversion it's important to avoid dereferencing the pointer, which
  362|       |    // could otherwise lead to a crash when printing a dangling (const char*).
  363|  4.84k|    const bool canConvertToChar = detail::is_convertible<T,char>::value;
  364|  4.84k|    const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;
  365|  4.84k|    if (canConvertToChar && *(fmtEnd-1) == 'c')
  ------------------
  |  Branch (365:9): [Folded, False: 4.84k]
  |  Branch (365:29): [True: 0, False: 0]
  ------------------
  366|      0|        detail::formatValueAsType<T, char>::invoke(out, value);
  367|  4.84k|    else if (canConvertToVoidPtr && *(fmtEnd-1) == 'p')
  ------------------
  |  Branch (367:14): [Folded, False: 4.84k]
  |  Branch (367:37): [True: 0, False: 0]
  ------------------
  368|      0|        detail::formatValueAsType<T, const void*>::invoke(out, value);
  369|       |#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
  370|       |    else if (detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;
  371|       |#endif
  372|  4.84k|    else if (ntrunc >= 0) {
  ------------------
  |  Branch (372:14): [True: 0, False: 4.84k]
  ------------------
  373|       |        // Take care not to overread C strings in truncating conversions like
  374|       |        // "%.4s" where at most 4 characters may be read.
  375|      0|        detail::formatTruncated(out, value, ntrunc);
  376|      0|    }
  377|  4.84k|    else
  378|  4.84k|        out << value;
  379|  4.84k|}
_ZN10tinyformat17FormatStringCheckILj1EEcvPKcEv:
  197|  1.48k|    operator const char*() { return fmt; }
_ZN10tinyformat6formatIJPKcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEES9_NS_17FormatStringCheckIXsZT_EEEDpRKT_:
 1088|  3.36k|{
 1089|  3.36k|    std::ostringstream oss;
 1090|  3.36k|    format(oss, fmt, args...);
 1091|  3.36k|    return oss.str();
 1092|  3.36k|}
_ZN10tinyformat6formatIJPKcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEEvRNS3_13basic_ostreamIcS6_EENS_17FormatStringCheckIXsZT_EEEDpRKT_:
 1080|  3.36k|{
 1081|  3.36k|    vformat(out, fmt, makeFormatList(args...));
 1082|  3.36k|}
_ZN10tinyformat14makeFormatListIJPKcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEENS_6detail11FormatListNIXsZT_EEEDpRKT_:
 1044|  3.36k|{
 1045|  3.36k|    return detail::FormatListN<sizeof...(args)>(args...);
 1046|  3.36k|}
_ZN10tinyformat6detail11FormatListNILi2EEC2IJPKcNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEEEDpRKT_:
  990|  3.36k|            : FormatList(&m_formatterStore[0], N),
  991|  3.36k|            m_formatterStore { FormatArg(args)... }
  992|  3.36k|        { static_assert(sizeof...(args) == N, "Number of args must be N"); }
_ZN10tinyformat6detail9FormatArgC2IPKcEERKT_:
  534|  3.36k|            : m_value(static_cast<const void*>(&value)),
  535|  3.36k|            m_formatImpl(&formatImpl<T>),
  536|  3.36k|            m_toIntImpl(&toIntImpl<T>)
  537|  3.36k|        { }
_ZN10tinyformat6detail9FormatArg10formatImplIPKcEEvRNSt3__113basic_ostreamIcNS5_11char_traitsIcEEEES4_S4_iPKv:
  558|  3.36k|        {
  559|  3.36k|            formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));
  560|  3.36k|        }
_ZN10tinyformat11formatValueIPKcEEvRNSt3__113basic_ostreamIcNS3_11char_traitsIcEEEES2_S2_iRKT_:
  351|  3.36k|{
  352|  3.36k|#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
  353|       |    // Since we don't support printing of wchar_t using "%ls", make it fail at
  354|       |    // compile time in preference to printing as a void* at runtime.
  355|  3.36k|    typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;
  356|  3.36k|    (void) DummyType(); // avoid unused type warning with gcc-4.8
  357|  3.36k|#endif
  358|       |    // The mess here is to support the %c and %p conversions: if these
  359|       |    // conversions are active we try to convert the type to a char or const
  360|       |    // void* respectively and format that instead of the value itself.  For the
  361|       |    // %p conversion it's important to avoid dereferencing the pointer, which
  362|       |    // could otherwise lead to a crash when printing a dangling (const char*).
  363|  3.36k|    const bool canConvertToChar = detail::is_convertible<T,char>::value;
  364|  3.36k|    const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;
  365|  3.36k|    if (canConvertToChar && *(fmtEnd-1) == 'c')
  ------------------
  |  Branch (365:9): [Folded, False: 3.36k]
  |  Branch (365:29): [True: 0, False: 0]
  ------------------
  366|      0|        detail::formatValueAsType<T, char>::invoke(out, value);
  367|  3.36k|    else if (canConvertToVoidPtr && *(fmtEnd-1) == 'p')
  ------------------
  |  Branch (367:14): [True: 3.36k, Folded]
  |  Branch (367:37): [True: 0, False: 3.36k]
  ------------------
  368|      0|        detail::formatValueAsType<T, const void*>::invoke(out, value);
  369|       |#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
  370|       |    else if (detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/;
  371|       |#endif
  372|  3.36k|    else if (ntrunc >= 0) {
  ------------------
  |  Branch (372:14): [True: 0, False: 3.36k]
  ------------------
  373|       |        // Take care not to overread C strings in truncating conversions like
  374|       |        // "%.4s" where at most 4 characters may be read.
  375|      0|        detail::formatTruncated(out, value, ntrunc);
  376|      0|    }
  377|  3.36k|    else
  378|  3.36k|        out << value;
  379|  3.36k|}
_ZNK10tinyformat6detail9FormatArg6formatERNSt3__113basic_ostreamIcNS2_11char_traitsIcEEEEPKcS9_i:
  541|  8.20k|        {
  542|  8.20k|            TINYFORMAT_ASSERT(m_value);
  ------------------
  |  |  153|  8.20k|#   define TINYFORMAT_ASSERT(cond) assert(cond)
  ------------------
  |  Branch (542:13): [True: 8.20k, False: 0]
  ------------------
  543|  8.20k|            TINYFORMAT_ASSERT(m_formatImpl);
  ------------------
  |  |  153|  8.20k|#   define TINYFORMAT_ASSERT(cond) assert(cond)
  ------------------
  |  Branch (543:13): [True: 8.20k, False: 0]
  ------------------
  544|  8.20k|            m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);
  545|  8.20k|        }
_ZN10tinyformat10FormatListC2EPNS_6detail9FormatArgEi:
  966|  4.84k|            : m_args(args), m_N(N) { }
_ZN10tinyformat6detail21parseWidthOrPrecisionERiRPKcbPKNS0_9FormatArgES1_i:
  593|  8.20k|{
  594|  8.20k|    if (*c >= '0' && *c <= '9') {
  ------------------
  |  Branch (594:9): [True: 8.20k, False: 0]
  |  Branch (594:22): [True: 0, False: 8.20k]
  ------------------
  595|      0|        n = parseIntAndAdvance(c);
  596|      0|    }
  597|  8.20k|    else if (*c == '*') {
  ------------------
  |  Branch (597:14): [True: 0, False: 8.20k]
  ------------------
  598|      0|        ++c;
  599|      0|        n = 0;
  600|      0|        if (positionalMode) {
  ------------------
  |  Branch (600:13): [True: 0, False: 0]
  ------------------
  601|      0|            int pos = parseIntAndAdvance(c) - 1;
  602|      0|            if (*c != '$')
  ------------------
  |  Branch (602:17): [True: 0, False: 0]
  ------------------
  603|      0|                TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  604|      0|            if (pos >= 0 && pos < numArgs)
  ------------------
  |  Branch (604:17): [True: 0, False: 0]
  |  Branch (604:29): [True: 0, False: 0]
  ------------------
  605|      0|                n = args[pos].toInt();
  606|      0|            else
  607|      0|                TINYFORMAT_ERROR("tinyformat: Positional argument out of range");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  608|      0|            ++c;
  609|      0|        }
  610|      0|        else {
  611|      0|            if (argIndex < numArgs)
  ------------------
  |  Branch (611:17): [True: 0, False: 0]
  ------------------
  612|      0|                n = args[argIndex++].toInt();
  613|      0|            else
  614|      0|                TINYFORMAT_ERROR("tinyformat: Not enough arguments to read variable width or precision");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  615|      0|        }
  616|      0|    }
  617|  8.20k|    else {
  618|  8.20k|        return false;
  619|  8.20k|    }
  620|      0|    return true;
  621|  8.20k|}
_ZN10tinyformat6detail24printFormatStringLiteralERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEEPKc:
  629|  13.0k|{
  630|  13.0k|    const char* c = fmt;
  631|   190k|    for (;; ++c) {
  632|   190k|        if (*c == '\0') {
  ------------------
  |  Branch (632:13): [True: 4.84k, False: 185k]
  ------------------
  633|  4.84k|            out.write(fmt, c - fmt);
  634|  4.84k|            return c;
  635|  4.84k|        }
  636|   185k|        else if (*c == '%') {
  ------------------
  |  Branch (636:18): [True: 8.20k, False: 177k]
  ------------------
  637|  8.20k|            out.write(fmt, c - fmt);
  638|  8.20k|            if (*(c+1) != '%')
  ------------------
  |  Branch (638:17): [True: 8.20k, False: 0]
  ------------------
  639|  8.20k|                return c;
  640|       |            // for "%%", tack trailing % onto next literal section.
  641|      0|            fmt = ++c;
  642|      0|        }
  643|   190k|    }
  644|  13.0k|}
_ZN10tinyformat6detail21streamStateFromFormatERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEERbS7_RiPKcPKNS0_9FormatArgES8_i:
  685|  8.20k|{
  686|  8.20k|    TINYFORMAT_ASSERT(*fmtStart == '%');
  ------------------
  |  |  153|  8.20k|#   define TINYFORMAT_ASSERT(cond) assert(cond)
  ------------------
  |  Branch (686:5): [True: 8.20k, False: 0]
  ------------------
  687|       |    // Reset stream state to defaults.
  688|  8.20k|    out.width(0);
  689|  8.20k|    out.precision(6);
  690|  8.20k|    out.fill(' ');
  691|       |    // Reset most flags; ignore irrelevant unitbuf & skipws.
  692|  8.20k|    out.unsetf(std::ios::adjustfield | std::ios::basefield |
  693|  8.20k|               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
  694|  8.20k|               std::ios::showpoint | std::ios::showpos | std::ios::uppercase);
  695|  8.20k|    bool precisionSet = false;
  696|  8.20k|    bool widthSet = false;
  697|  8.20k|    int widthExtra = 0;
  698|  8.20k|    const char* c = fmtStart + 1;
  699|       |
  700|       |    // 1) Parse an argument index (if followed by '$') or a width possibly
  701|       |    // preceded with '0' flag.
  702|  8.20k|    if (*c >= '0' && *c <= '9') {
  ------------------
  |  Branch (702:9): [True: 8.20k, False: 0]
  |  Branch (702:22): [True: 0, False: 8.20k]
  ------------------
  703|      0|        const char tmpc = *c;
  704|      0|        int value = parseIntAndAdvance(c);
  705|      0|        if (*c == '$') {
  ------------------
  |  Branch (705:13): [True: 0, False: 0]
  ------------------
  706|       |            // value is an argument index
  707|      0|            if (value > 0 && value <= numArgs)
  ------------------
  |  Branch (707:17): [True: 0, False: 0]
  |  Branch (707:30): [True: 0, False: 0]
  ------------------
  708|      0|                argIndex = value - 1;
  709|      0|            else
  710|      0|                TINYFORMAT_ERROR("tinyformat: Positional argument out of range");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  711|      0|            ++c;
  712|      0|            positionalMode = true;
  713|      0|        }
  714|      0|        else if (positionalMode) {
  ------------------
  |  Branch (714:18): [True: 0, False: 0]
  ------------------
  715|      0|            TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  716|      0|        }
  717|      0|        else {
  718|      0|            if (tmpc == '0') {
  ------------------
  |  Branch (718:17): [True: 0, False: 0]
  ------------------
  719|       |                // Use internal padding so that numeric values are
  720|       |                // formatted correctly, eg -00010 rather than 000-10
  721|      0|                out.fill('0');
  722|      0|                out.setf(std::ios::internal, std::ios::adjustfield);
  723|      0|            }
  724|      0|            if (value != 0) {
  ------------------
  |  Branch (724:17): [True: 0, False: 0]
  ------------------
  725|       |                // Nonzero value means that we parsed width.
  726|      0|                widthSet = true;
  727|      0|                out.width(value);
  728|      0|            }
  729|      0|        }
  730|      0|    }
  731|  8.20k|    else if (positionalMode) {
  ------------------
  |  Branch (731:14): [True: 0, False: 8.20k]
  ------------------
  732|      0|        TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  733|      0|    }
  734|       |    // 2) Parse flags and width if we did not do it in previous step.
  735|  8.20k|    if (!widthSet) {
  ------------------
  |  Branch (735:9): [True: 8.20k, False: 0]
  ------------------
  736|       |        // Parse flags
  737|  8.20k|        for (;; ++c) {
  738|  8.20k|            switch (*c) {
  739|      0|                case '#':
  ------------------
  |  Branch (739:17): [True: 0, False: 8.20k]
  ------------------
  740|      0|                    out.setf(std::ios::showpoint | std::ios::showbase);
  741|      0|                    continue;
  742|      0|                case '0':
  ------------------
  |  Branch (742:17): [True: 0, False: 8.20k]
  ------------------
  743|       |                    // overridden by left alignment ('-' flag)
  744|      0|                    if (!(out.flags() & std::ios::left)) {
  ------------------
  |  Branch (744:25): [True: 0, False: 0]
  ------------------
  745|       |                        // Use internal padding so that numeric values are
  746|       |                        // formatted correctly, eg -00010 rather than 000-10
  747|      0|                        out.fill('0');
  748|      0|                        out.setf(std::ios::internal, std::ios::adjustfield);
  749|      0|                    }
  750|      0|                    continue;
  751|      0|                case '-':
  ------------------
  |  Branch (751:17): [True: 0, False: 8.20k]
  ------------------
  752|      0|                    out.fill(' ');
  753|      0|                    out.setf(std::ios::left, std::ios::adjustfield);
  754|      0|                    continue;
  755|      0|                case ' ':
  ------------------
  |  Branch (755:17): [True: 0, False: 8.20k]
  ------------------
  756|       |                    // overridden by show positive sign, '+' flag.
  757|      0|                    if (!(out.flags() & std::ios::showpos))
  ------------------
  |  Branch (757:25): [True: 0, False: 0]
  ------------------
  758|      0|                        spacePadPositive = true;
  759|      0|                    continue;
  760|      0|                case '+':
  ------------------
  |  Branch (760:17): [True: 0, False: 8.20k]
  ------------------
  761|      0|                    out.setf(std::ios::showpos);
  762|      0|                    spacePadPositive = false;
  763|      0|                    widthExtra = 1;
  764|      0|                    continue;
  765|  8.20k|                default:
  ------------------
  |  Branch (765:17): [True: 8.20k, False: 0]
  ------------------
  766|  8.20k|                    break;
  767|  8.20k|            }
  768|  8.20k|            break;
  769|  8.20k|        }
  770|       |        // Parse width
  771|  8.20k|        int width = 0;
  772|  8.20k|        widthSet = parseWidthOrPrecision(width, c, positionalMode,
  773|  8.20k|                                         args, argIndex, numArgs);
  774|  8.20k|        if (widthSet) {
  ------------------
  |  Branch (774:13): [True: 0, False: 8.20k]
  ------------------
  775|      0|            if (width < 0) {
  ------------------
  |  Branch (775:17): [True: 0, False: 0]
  ------------------
  776|       |                // negative widths correspond to '-' flag set
  777|      0|                out.fill(' ');
  778|      0|                out.setf(std::ios::left, std::ios::adjustfield);
  779|      0|                width = -width;
  780|      0|            }
  781|      0|            out.width(width);
  782|      0|        }
  783|  8.20k|    }
  784|       |    // 3) Parse precision
  785|  8.20k|    if (*c == '.') {
  ------------------
  |  Branch (785:9): [True: 0, False: 8.20k]
  ------------------
  786|      0|        ++c;
  787|      0|        int precision = 0;
  788|      0|        parseWidthOrPrecision(precision, c, positionalMode,
  789|      0|                              args, argIndex, numArgs);
  790|       |        // Presence of `.` indicates precision set, unless the inferred value
  791|       |        // was negative in which case the default is used.
  792|      0|        precisionSet = precision >= 0;
  793|      0|        if (precisionSet)
  ------------------
  |  Branch (793:13): [True: 0, False: 0]
  ------------------
  794|      0|            out.precision(precision);
  795|      0|    }
  796|       |    // 4) Ignore any C99 length modifier
  797|  8.20k|    while (*c == 'l' || *c == 'h' || *c == 'L' ||
  ------------------
  |  Branch (797:12): [True: 0, False: 8.20k]
  |  Branch (797:25): [True: 0, False: 8.20k]
  |  Branch (797:38): [True: 0, False: 8.20k]
  ------------------
  798|  8.20k|           *c == 'j' || *c == 'z' || *c == 't') {
  ------------------
  |  Branch (798:12): [True: 0, False: 8.20k]
  |  Branch (798:25): [True: 0, False: 8.20k]
  |  Branch (798:38): [True: 0, False: 8.20k]
  ------------------
  799|      0|        ++c;
  800|      0|    }
  801|       |    // 5) We're up to the conversion specifier character.
  802|       |    // Set stream flags based on conversion specifier (thanks to the
  803|       |    // boost::format class for forging the way here).
  804|  8.20k|    bool intConversion = false;
  805|  8.20k|    switch (*c) {
  806|      0|        case 'u': case 'd': case 'i':
  ------------------
  |  Branch (806:9): [True: 0, False: 8.20k]
  |  Branch (806:19): [True: 0, False: 8.20k]
  |  Branch (806:29): [True: 0, False: 8.20k]
  ------------------
  807|      0|            out.setf(std::ios::dec, std::ios::basefield);
  808|      0|            intConversion = true;
  809|      0|            break;
  810|      0|        case 'o':
  ------------------
  |  Branch (810:9): [True: 0, False: 8.20k]
  ------------------
  811|      0|            out.setf(std::ios::oct, std::ios::basefield);
  812|      0|            intConversion = true;
  813|      0|            break;
  814|      0|        case 'X':
  ------------------
  |  Branch (814:9): [True: 0, False: 8.20k]
  ------------------
  815|      0|            out.setf(std::ios::uppercase);
  816|      0|            [[fallthrough]];
  817|      0|        case 'x': case 'p':
  ------------------
  |  Branch (817:9): [True: 0, False: 8.20k]
  |  Branch (817:19): [True: 0, False: 8.20k]
  ------------------
  818|      0|            out.setf(std::ios::hex, std::ios::basefield);
  819|      0|            intConversion = true;
  820|      0|            break;
  821|      0|        case 'E':
  ------------------
  |  Branch (821:9): [True: 0, False: 8.20k]
  ------------------
  822|      0|            out.setf(std::ios::uppercase);
  823|      0|            [[fallthrough]];
  824|      0|        case 'e':
  ------------------
  |  Branch (824:9): [True: 0, False: 8.20k]
  ------------------
  825|      0|            out.setf(std::ios::scientific, std::ios::floatfield);
  826|      0|            out.setf(std::ios::dec, std::ios::basefield);
  827|      0|            break;
  828|      0|        case 'F':
  ------------------
  |  Branch (828:9): [True: 0, False: 8.20k]
  ------------------
  829|      0|            out.setf(std::ios::uppercase);
  830|      0|            [[fallthrough]];
  831|      0|        case 'f':
  ------------------
  |  Branch (831:9): [True: 0, False: 8.20k]
  ------------------
  832|      0|            out.setf(std::ios::fixed, std::ios::floatfield);
  833|      0|            break;
  834|      0|        case 'A':
  ------------------
  |  Branch (834:9): [True: 0, False: 8.20k]
  ------------------
  835|      0|            out.setf(std::ios::uppercase);
  836|      0|            [[fallthrough]];
  837|      0|        case 'a':
  ------------------
  |  Branch (837:9): [True: 0, False: 8.20k]
  ------------------
  838|       |#           ifdef _MSC_VER
  839|       |            // Workaround https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html
  840|       |            // by always setting maximum precision on MSVC to avoid precision
  841|       |            // loss for doubles.
  842|       |            out.precision(13);
  843|       |#           endif
  844|      0|            out.setf(std::ios::fixed | std::ios::scientific, std::ios::floatfield);
  845|      0|            break;
  846|      0|        case 'G':
  ------------------
  |  Branch (846:9): [True: 0, False: 8.20k]
  ------------------
  847|      0|            out.setf(std::ios::uppercase);
  848|      0|            [[fallthrough]];
  849|      0|        case 'g':
  ------------------
  |  Branch (849:9): [True: 0, False: 8.20k]
  ------------------
  850|      0|            out.setf(std::ios::dec, std::ios::basefield);
  851|       |            // As in boost::format, let stream decide float format.
  852|      0|            out.flags(out.flags() & ~std::ios::floatfield);
  853|      0|            break;
  854|      0|        case 'c':
  ------------------
  |  Branch (854:9): [True: 0, False: 8.20k]
  ------------------
  855|       |            // Handled as special case inside formatValue()
  856|      0|            break;
  857|  8.20k|        case 's':
  ------------------
  |  Branch (857:9): [True: 8.20k, False: 0]
  ------------------
  858|  8.20k|            if (precisionSet)
  ------------------
  |  Branch (858:17): [True: 0, False: 8.20k]
  ------------------
  859|      0|                ntrunc = static_cast<int>(out.precision());
  860|       |            // Make %s print Booleans as "true" and "false"
  861|  8.20k|            out.setf(std::ios::boolalpha);
  862|  8.20k|            break;
  863|      0|        case 'n':
  ------------------
  |  Branch (863:9): [True: 0, False: 8.20k]
  ------------------
  864|       |            // Not supported - will cause problems!
  865|      0|            TINYFORMAT_ERROR("tinyformat: %n conversion spec not supported");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  866|      0|            break;
  867|      0|        case '\0':
  ------------------
  |  Branch (867:9): [True: 0, False: 8.20k]
  ------------------
  868|      0|            TINYFORMAT_ERROR("tinyformat: Conversion spec incorrectly "
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  869|      0|                             "terminated by end of string");
  870|      0|            return c;
  871|      0|        default:
  ------------------
  |  Branch (871:9): [True: 0, False: 8.20k]
  ------------------
  872|      0|            break;
  873|  8.20k|    }
  874|  8.20k|    if (intConversion && precisionSet && !widthSet) {
  ------------------
  |  Branch (874:9): [True: 0, False: 8.20k]
  |  Branch (874:26): [True: 0, False: 0]
  |  Branch (874:42): [True: 0, False: 0]
  ------------------
  875|       |        // "precision" for integers gives the minimum number of digits (to be
  876|       |        // padded with zeros on the left).  This isn't really supported by the
  877|       |        // iostreams, but we can approximately simulate it with the width if
  878|       |        // the width isn't otherwise used.
  879|      0|        out.width(out.precision() + widthExtra);
  880|      0|        out.setf(std::ios::internal, std::ios::adjustfield);
  881|      0|        out.fill('0');
  882|      0|    }
  883|  8.20k|    return c+1;
  884|  8.20k|}
_ZN10tinyformat6detail10formatImplERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEEPKcPKNS0_9FormatArgEi:
  891|  4.84k|{
  892|       |    // Saved stream state
  893|  4.84k|    std::streamsize origWidth = out.width();
  894|  4.84k|    std::streamsize origPrecision = out.precision();
  895|  4.84k|    std::ios::fmtflags origFlags = out.flags();
  896|  4.84k|    char origFill = out.fill();
  897|       |
  898|       |    // "Positional mode" means all format specs should be of the form "%n$..."
  899|       |    // with `n` an integer. We detect this in `streamStateFromFormat`.
  900|  4.84k|    bool positionalMode = false;
  901|  4.84k|    int argIndex = 0;
  902|  13.0k|    while (true) {
  ------------------
  |  Branch (902:12): [True: 13.0k, Folded]
  ------------------
  903|  13.0k|        fmt = printFormatStringLiteral(out, fmt);
  904|  13.0k|        if (*fmt == '\0') {
  ------------------
  |  Branch (904:13): [True: 4.84k, False: 8.20k]
  ------------------
  905|  4.84k|            if (!positionalMode && argIndex < numArgs) {
  ------------------
  |  Branch (905:17): [True: 4.84k, False: 0]
  |  Branch (905:36): [True: 0, False: 4.84k]
  ------------------
  906|      0|                TINYFORMAT_ERROR("tinyformat: Not enough conversion specifiers in format string");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  907|      0|            }
  908|  4.84k|            break;
  909|  4.84k|        }
  910|  8.20k|        bool spacePadPositive = false;
  911|  8.20k|        int ntrunc = -1;
  912|  8.20k|        const char* fmtEnd = streamStateFromFormat(out, positionalMode, spacePadPositive, ntrunc, fmt,
  913|  8.20k|                                                   args, argIndex, numArgs);
  914|       |        // NB: argIndex may be incremented by reading variable width/precision
  915|       |        // in `streamStateFromFormat`, so do the bounds check here.
  916|  8.20k|        if (argIndex >= numArgs) {
  ------------------
  |  Branch (916:13): [True: 0, False: 8.20k]
  ------------------
  917|      0|            TINYFORMAT_ERROR("tinyformat: Too many conversion specifiers in format string");
  ------------------
  |  |  135|      0|#define TINYFORMAT_ERROR(reasonString) throw tinyformat::format_error(reasonString)
  ------------------
  918|      0|            return;
  919|      0|        }
  920|  8.20k|        const FormatArg& arg = args[argIndex];
  921|       |        // Format the arg into the stream.
  922|  8.20k|        if (!spacePadPositive) {
  ------------------
  |  Branch (922:13): [True: 8.20k, False: 0]
  ------------------
  923|  8.20k|            arg.format(out, fmt, fmtEnd, ntrunc);
  924|  8.20k|        }
  925|      0|        else {
  926|       |            // The following is a special case with no direct correspondence
  927|       |            // between stream formatting and the printf() behaviour.  Simulate
  928|       |            // it crudely by formatting into a temporary string stream and
  929|       |            // munging the resulting string.
  930|      0|            std::ostringstream tmpStream;
  931|      0|            tmpStream.copyfmt(out);
  932|      0|            tmpStream.setf(std::ios::showpos);
  933|      0|            arg.format(tmpStream, fmt, fmtEnd, ntrunc);
  934|      0|            std::string result = tmpStream.str(); // allocates... yuck.
  935|      0|            for (size_t i = 0, iend = result.size(); i < iend; ++i) {
  ------------------
  |  Branch (935:54): [True: 0, False: 0]
  ------------------
  936|      0|                if (result[i] == '+')
  ------------------
  |  Branch (936:21): [True: 0, False: 0]
  ------------------
  937|      0|                    result[i] = ' ';
  938|      0|            }
  939|      0|            out << result;
  940|      0|        }
  941|  8.20k|        if (!positionalMode)
  ------------------
  |  Branch (941:13): [True: 8.20k, False: 0]
  ------------------
  942|  8.20k|            ++argIndex;
  943|  8.20k|        fmt = fmtEnd;
  944|  8.20k|    }
  945|       |
  946|       |    // Restore stream state
  947|  4.84k|    out.width(origWidth);
  948|  4.84k|    out.precision(origPrecision);
  949|  4.84k|    out.flags(origFlags);
  950|  4.84k|    out.fill(origFill);
  951|  4.84k|}
_ZN10tinyformat7vformatERNSt3__113basic_ostreamIcNS0_11char_traitsIcEEEEPKcRKNS_10FormatListE:
 1070|  4.84k|{
 1071|  4.84k|    detail::formatImpl(out, fmt, list.m_args, list.m_N);
 1072|  4.84k|}
_ZN10tinyformat6detail11FormatListNILi1EEC2IJNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEEEDpRKT_:
  990|  1.48k|            : FormatList(&m_formatterStore[0], N),
  991|  1.48k|            m_formatterStore { FormatArg(args)... }
  992|  1.48k|        { static_assert(sizeof...(args) == N, "Number of args must be N"); }
_ZN10tinyformat6detail9FormatArgC2INSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEERKT_:
  534|  4.84k|            : m_value(static_cast<const void*>(&value)),
  535|  4.84k|            m_formatImpl(&formatImpl<T>),
  536|  4.84k|            m_toIntImpl(&toIntImpl<T>)
  537|  4.84k|        { }
_ZN10tinyformat17FormatStringCheckILj1EEC2EN4util21ConstevalFormatStringILj1EEE:
  196|  1.48k|    FormatStringCheck(util::ConstevalFormatString<num_params> str) : fmt{str.fmt} {}
_ZN10tinyformat17FormatStringCheckILj2EEcvPKcEv:
  197|  3.36k|    operator const char*() { return fmt; }
_ZN10tinyformat17FormatStringCheckILj2EEC2EN4util21ConstevalFormatStringILj2EEE:
  196|  3.36k|    FormatStringCheck(util::ConstevalFormatString<num_params> str) : fmt{str.fmt} {}

_ZNK9base_blobILj256EE6GetHexEv:
   12|  3.36k|{
   13|  3.36k|    uint8_t m_data_rev[WIDTH];
   14|   110k|    for (int i = 0; i < WIDTH; ++i) {
  ------------------
  |  Branch (14:21): [True: 107k, False: 3.36k]
  ------------------
   15|   107k|        m_data_rev[i] = m_data[WIDTH - 1 - i];
   16|   107k|    }
   17|  3.36k|    return HexStr(m_data_rev);
   18|  3.36k|}

_ZNK9base_blobILj256EE9SerializeI10DataStreamEEvRT_:
  113|  7.70k|    {
  114|  7.70k|        s << std::span(m_data);
  115|  7.70k|    }
_ZN7uint256C2ENSt3__14spanIKhLm18446744073709551615EEE:
  203|  21.2k|    constexpr explicit uint256(std::span<const unsigned char> vch) : base_blob<256>(vch) {}
_ZN9base_blobILj256EEC2ENSt3__14spanIKhLm18446744073709551615EEE:
   41|  21.2k|    {
   42|  21.2k|        assert(vch.size() == WIDTH);
  ------------------
  |  Branch (42:9): [True: 21.2k, False: 0]
  ------------------
   43|  21.2k|        std::copy(vch.begin(), vch.end(), m_data.begin());
   44|  21.2k|    }
_ZNK9base_blobILj256EE5beginEv:
  104|  31.2k|    constexpr const unsigned char* begin() const { return m_data.data(); }
_ZN7uint160C2Ev:
  187|  23.5k|    constexpr uint160() = default;
_ZN9base_blobILj160EEC2Ev:
   35|  23.5k|    constexpr base_blob() : m_data() {}
_ZN9base_blobILj160EE4dataEv:
   99|  23.5k|    constexpr unsigned char* data() { return m_data.data(); }
_ZN9base_blobILj160EE4sizeEv:
  107|  23.5k|    static constexpr unsigned int size() { return WIDTH; }
_ZN9base_blobILj256EE5beginEv:
  101|  66.6k|    constexpr unsigned char* begin() { return m_data.data(); }
_ZNK9base_blobILj256EE9SerializeI10HashWriterEEvRT_:
  113|  32.0k|    {
  114|  32.0k|        s << std::span(m_data);
  115|  32.0k|    }
_ZN9base_blobILj256EE4dataEv:
   99|  13.4k|    constexpr unsigned char* data() { return m_data.data(); }
_ZN9base_blobILj256EE4sizeEv:
  107|  66.4k|    static constexpr unsigned int size() { return WIDTH; }
_ZNK9base_blobILj256EE4dataEv:
   98|  40.5k|    constexpr const unsigned char* data() const { return m_data.data(); }
_ZN7uint256C2Ev:
  200|  71.3k|    constexpr uint256() = default;
_ZN9base_blobILj256EEC2Ev:
   35|  71.3k|    constexpr base_blob() : m_data() {}

_Z22inline_assertion_checkILb1ERPKNSt3__18functionIFvNS0_4spanIKhLm18446744073709551615EEEEEEEOT0_SB_PKciSD_SD_:
   77|  3.36k|{
   78|  3.36k|    if (IS_ASSERT || std::is_constant_evaluated() || G_FUZZING_BUILD || G_ABORT_ON_FAILED_ASSUME) {
  ------------------
  |  Branch (78:9): [True: 3.36k, Folded]
  |  Branch (78:22): [Folded, False: 0]
  |  Branch (78:54): [True: 0, Folded]
  |  Branch (78:73): [Folded, False: 0]
  ------------------
   79|  3.36k|        if (!val) {
  ------------------
  |  Branch (79:13): [True: 0, False: 3.36k]
  ------------------
   80|      0|            assertion_fail(file, line, func, assertion);
   81|      0|        }
   82|  3.36k|    }
   83|  3.36k|    return std::forward<T>(val);
   84|  3.36k|}
_Z22inline_assertion_checkILb0EbEOT0_S1_PKciS3_S3_:
   77|   316k|{
   78|   316k|    if (IS_ASSERT || std::is_constant_evaluated() || G_FUZZING_BUILD || G_ABORT_ON_FAILED_ASSUME) {
  ------------------
  |  Branch (78:9): [Folded, False: 0]
  |  Branch (78:22): [Folded, False: 0]
  |  Branch (78:54): [True: 0, Folded]
  |  Branch (78:73): [Folded, False: 0]
  ------------------
   79|   316k|        if (!val) {
  ------------------
  |  Branch (79:13): [True: 0, False: 316k]
  ------------------
   80|      0|            assertion_fail(file, line, func, assertion);
   81|      0|        }
   82|   316k|    }
   83|   316k|    return std::forward<T>(val);
   84|   316k|}
_Z22inline_assertion_checkILb0ERNSt3__18optionalI24Sv2SignatureNoiseMessageEEEOT0_S6_PKciS8_S8_:
   77|  3.36k|{
   78|  3.36k|    if (IS_ASSERT || std::is_constant_evaluated() || G_FUZZING_BUILD || G_ABORT_ON_FAILED_ASSUME) {
  ------------------
  |  Branch (78:9): [Folded, False: 0]
  |  Branch (78:22): [Folded, False: 0]
  |  Branch (78:54): [True: 0, Folded]
  |  Branch (78:73): [Folded, False: 0]
  ------------------
   79|  3.36k|        if (!val) {
  ------------------
  |  Branch (79:13): [True: 0, False: 3.36k]
  ------------------
   80|      0|            assertion_fail(file, line, func, assertion);
   81|      0|        }
   82|  3.36k|    }
   83|  3.36k|    return std::forward<T>(val);
   84|  3.36k|}
_Z22inline_assertion_checkILb0ERNSt3__18optionalI11XOnlyPubKeyEEEOT0_S6_PKciS8_S8_:
   77|  2.56k|{
   78|  2.56k|    if (IS_ASSERT || std::is_constant_evaluated() || G_FUZZING_BUILD || G_ABORT_ON_FAILED_ASSUME) {
  ------------------
  |  Branch (78:9): [Folded, False: 0]
  |  Branch (78:22): [Folded, False: 0]
  |  Branch (78:54): [True: 0, Folded]
  |  Branch (78:73): [Folded, False: 0]
  ------------------
   79|  2.56k|        if (!val) {
  ------------------
  |  Branch (79:13): [True: 0, False: 2.56k]
  ------------------
   80|      0|            assertion_fail(file, line, func, assertion);
   81|      0|        }
   82|  2.56k|    }
   83|  2.56k|    return std::forward<T>(val);
   84|  2.56k|}
_Z22inline_assertion_checkILb0ERNSt3__110unique_ptrI17Sv2HandshakeStateNS0_14default_deleteIS2_EEEEEOT0_S8_PKciSA_SA_:
   77|  2.15k|{
   78|  2.15k|    if (IS_ASSERT || std::is_constant_evaluated() || G_FUZZING_BUILD || G_ABORT_ON_FAILED_ASSUME) {
  ------------------
  |  Branch (78:9): [Folded, False: 0]
  |  Branch (78:22): [Folded, False: 0]
  |  Branch (78:54): [True: 0, Folded]
  |  Branch (78:73): [Folded, False: 0]
  ------------------
   79|  2.15k|        if (!val) {
  ------------------
  |  Branch (79:13): [True: 0, False: 2.15k]
  ------------------
   80|      0|            assertion_fail(file, line, func, assertion);
   81|      0|        }
   82|  2.15k|    }
   83|  2.15k|    return std::forward<T>(val);
   84|  2.15k|}
_Z21EnableFuzzDeterminismv:
   35|  3.36k|{
   36|  3.36k|    if constexpr (G_FUZZING_BUILD) {
   37|  3.36k|        return true;
   38|       |    } else if constexpr (!G_ABORT_ON_FAILED_ASSUME) {
   39|       |        // Running fuzz tests is always disabled if Assume() doesn't abort
   40|       |        // (ie, non-fuzz non-debug builds), as otherwise tests which
   41|       |        // should fail due to a failing Assume may still pass. As such,
   42|       |        // we also statically disable fuzz determinism in that case.
   43|       |        return false;
   44|       |    } else {
   45|       |        return g_enable_dynamic_fuzz_determinism;
   46|       |    }
   47|  3.36k|}
_Z22inline_assertion_checkILb1ERNSt3__16atomicIbEEEOT0_S5_PKciS7_S7_:
   77|  3.36k|{
   78|  3.36k|    if (IS_ASSERT || std::is_constant_evaluated() || G_FUZZING_BUILD || G_ABORT_ON_FAILED_ASSUME) {
  ------------------
  |  Branch (78:9): [True: 3.36k, Folded]
  |  Branch (78:22): [Folded, False: 0]
  |  Branch (78:54): [True: 0, Folded]
  |  Branch (78:73): [Folded, False: 0]
  ------------------
   79|  3.36k|        if (!val) {
  ------------------
  |  Branch (79:13): [True: 0, False: 3.36k]
  ------------------
   80|      0|            assertion_fail(file, line, func, assertion);
   81|      0|        }
   82|  3.36k|    }
   83|  3.36k|    return std::forward<T>(val);
   84|  3.36k|}
_Z22inline_assertion_checkILb1EbEOT0_S1_PKciS3_S3_:
   77|  11.3k|{
   78|  11.3k|    if (IS_ASSERT || std::is_constant_evaluated() || G_FUZZING_BUILD || G_ABORT_ON_FAILED_ASSUME) {
  ------------------
  |  Branch (78:9): [True: 11.3k, Folded]
  |  Branch (78:22): [Folded, False: 0]
  |  Branch (78:54): [True: 0, Folded]
  |  Branch (78:73): [Folded, False: 0]
  ------------------
   79|  11.3k|        if (!val) {
  ------------------
  |  Branch (79:13): [True: 0, False: 11.3k]
  ------------------
   80|      0|            assertion_fail(file, line, func, assertion);
   81|      0|        }
   82|  11.3k|    }
   83|  11.3k|    return std::forward<T>(val);
   84|  11.3k|}

_Z10CheckedAddImENSt3__18optionalIT_EES2_S2_:
   27|  10.2k|{
   28|  10.2k|    if (AdditionOverflow(i, j)) {
  ------------------
  |  Branch (28:9): [True: 0, False: 10.2k]
  ------------------
   29|      0|        return std::nullopt;
   30|      0|    }
   31|  10.2k|    return i + j;
   32|  10.2k|}
_Z16AdditionOverflowImEbT_S0_:
   16|  10.2k|{
   17|  10.2k|    static_assert(std::is_integral_v<T>, "Integral required.");
   18|       |    if constexpr (std::numeric_limits<T>::is_signed) {
   19|       |        return (i > 0 && j > std::numeric_limits<T>::max() - i) ||
   20|       |               (i < 0 && j < std::numeric_limits<T>::min() - i);
   21|       |    }
   22|  10.2k|    return std::numeric_limits<T>::max() - i < j;
   23|  10.2k|}

_ZN4util21ThreadGetInternalNameEv:
   45|  4.84k|std::string util::ThreadGetInternalName() { return g_thread_name; }

_ZN9NodeClock3nowEv:
   27|  8.47k|{
   28|  8.47k|    const auto mocktime{g_mock_time.load(std::memory_order_relaxed)};
   29|  8.47k|    if (!mocktime.count()) {
  ------------------
  |  Branch (29:9): [True: 0, False: 8.47k]
  ------------------
   30|      0|        g_used_system_time = true;
   31|      0|    }
   32|  8.47k|    const auto ret{
   33|  8.47k|        mocktime.count() ?
  ------------------
  |  Branch (33:9): [True: 8.47k, False: 0]
  ------------------
   34|  8.47k|            mocktime :
   35|  8.47k|            std::chrono::system_clock::now().time_since_epoch()};
   36|  8.47k|    assert(ret > 0s);
  ------------------
  |  Branch (36:5): [True: 8.47k, False: 0]
  ------------------
   37|  8.47k|    return time_point{ret};
   38|  8.47k|};
_Z11SetMockTimeNSt3__16chrono8durationIxNS_5ratioILl1ELl1EEEEE:
   43|  7.99k|{
   44|  7.99k|    Assert(mock_time_in >= 0s);
  ------------------
  |  |  106|  7.99k|#define Assert(val) inline_assertion_check<true>(val, __FILE__, __LINE__, __func__, #val)
  ------------------
   45|  7.99k|    g_mock_time.store(mock_time_in, std::memory_order_relaxed);
   46|  7.99k|}
_Z11GetMockTimev:
   49|  4.84k|{
   50|  4.84k|    return g_mock_time.load(std::memory_order_relaxed);
   51|  4.84k|}

_Z7GetTimeINSt3__16chrono8durationIxNS0_5ratioILl1ELl1EEEEEET_v:
  127|  8.47k|{
  128|  8.47k|    return Now<std::chrono::time_point<NodeClock, T>>().time_since_epoch();
  129|  8.47k|}
_Z3NowINSt3__16chrono10time_pointI9NodeClockNS1_8durationIxNS0_5ratioILl1ELl1EEEEEEEET_v:
  121|  8.47k|{
  122|  8.47k|    return std::chrono::time_point_cast<typename T::duration>(T::clock::now());
  123|  8.47k|}

_Z11ClearShrinkINSt3__16vectorISt4byteNS0_9allocatorIS2_EEEEEvRT_:
   57|  44.4k|{
   58|       |    // There are various ways to clear a vector and release its memory:
   59|       |    //
   60|       |    // 1. V{}.swap(v)
   61|       |    // 2. v = V{}
   62|       |    // 3. v = {}; v.shrink_to_fit();
   63|       |    // 4. v.clear(); v.shrink_to_fit();
   64|       |    //
   65|       |    // (2) does not appear to release memory in glibc debug mode, even if v.shrink_to_fit()
   66|       |    // follows. (3) and (4) rely on std::vector::shrink_to_fit, which is only a non-binding
   67|       |    // request. Therefore, we use method (1).
   68|       |
   69|  44.4k|    V{}.swap(v);
   70|  44.4k|}

